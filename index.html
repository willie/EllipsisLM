<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    
    <!-- PWA and iOS Home Screen Support -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="AI Storyteller">
    <link rel="apple-touch-icon" href="https://storage.googleapis.com/pai-images/22e56a81615f4e6691238e2124c6536b.png">

    <!-- External Libraries -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/jszip/dist/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
    
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,400;1,400&family=Dancing+Script:wght@700&family=EB+Garamond:ital,wght@0,400;1,400&family=Inter:wght@400;500;700&family=Lora:ital,wght@0,400;1,400&family=Nunito+Sans:ital,wght@0,400;1,400&family=Roboto+Slab:wght@400;700&family=Source+Code+Pro:ital,wght@0,400;1,400&display=swap" rel="stylesheet">

    <!-- Link to External Stylesheet -->
    <style>
	<!-- PASTE content of style.css HERE -->
:root {
    --font-primary: 'Inter', sans-serif;
    --text-primary: #e5e7eb;
    --text-secondary: #cbd5e1;
    --text-accent: #a5b4fc;
    
    --surface-glass: rgba(17, 24, 39, 0.15);
    --surface-card: rgba(55, 65, 81, 0.6);
    --surface-overlay: rgba(0, 0, 0, 0.4);
    
    --border-primary: var(--border-hue-color, rgba(75, 85, 99, 0.8));
    --border-hue-color: rgba(75, 85, 99, 0.8);
    --brand-color: #6366f1; /* Indigo */
    --brand-color-toggle: #4f46e5;
    
    --scrollbar-thumb: #4b5563;
    
    --border-radius-md: 0.75rem;
    --border-radius-sm: 4px;
    
    --transition-fast: 0.2s ease-in-out;
    --transition-medium: 0.4s ease-out;
    --transition-slow: 0.5s ease-in-out;

    /* New Appearance Variables */
    --chat-font-size: 16px;
    --bubble-image-size: 100px;
}

html, body {
    height: 100%;
    overflow: hidden;
}

body { 
    font-family: var(--font-primary); 
    color: #e5e7eb; 
}

/* Global styles for form elements to ensure readability on dark backgrounds */
input, textarea, select {
    color: var(--text-primary);
    background-color: rgba(0,0,0,0.7);
    border: 1px solid var(--border-primary);
}
input::placeholder, textarea::placeholder {
    color: #9ca3af; /* Tailwind gray-400 */
}
input:focus, textarea:focus, select:focus {
    outline: 2px solid var(--brand-color);
    outline-offset: -1px;
    border-color: var(--brand-color);
}


.glass-bg { 
    background-color: var(--surface-glass); 
    backdrop-filter: blur(5px); 
}

/* --- Scrollbar Styling --- */
/* --- Visible Chat Scrollbar (Horizontal) --- */
body.layout-horizontal #chat-window::-webkit-scrollbar-track {
    background: rgba(31, 41, 55, 0.5); /* dark-gray-800 at 50% opacity */
}
body.layout-horizontal #chat-window::-webkit-scrollbar-thumb {
    background: rgba(31, 41, 55, 0.5);
}
::-webkit-scrollbar { width: 12px; }
::-webkit-scrollbar-track { background: transparent; }
::-webkit-scrollbar-thumb { 
    background: var(--scrollbar-thumb); 
    border-radius: var(--border-radius-sm); 
}

/* --- Component Styling --- */
.character-card { 
    background-color: var(--surface-card); 
    backdrop-filter: blur(4px); 
    border: 1px solid var(--border-primary); 
    border-radius: var(--border-radius-md); 
}

.modal-overlay { 
    background-color: var(--surface-overlay); 
}

.details-scroll-container::-webkit-scrollbar-track {
    background: rgba(31, 41, 55, 0.5); /* dark-gray-800 at 50% opacity */
}

.toggle-bg:after { 
    content: ''; 
    position: absolute; 
    top: 0.125rem; 
    left: 0.125rem; 
    background-color: white; 
    border-radius: 9999px; 
    height: 1.25rem; 
    width: 1.25rem; 
    /* MODIFICATION: Animate 'left' instead of 'transform' */
    transition: left var(--transition-fast), background-color var(--transition-fast);
}

input:checked + .toggle-bg { 
    background-color: rgb(56 189 248 / var(--tw-text-opacity, 1)); 
}

input:checked + .toggle-bg:after { 
    /* This value is (Bar Width) - (Knob Width) - (Right Padding) */
    /* 3rem - 1.25rem - 0.125rem = 1.625rem */
    left: 1.625rem;
}



/* --- New Character Roster Button Styling --- */
.char-roster-btn {
    position: relative;
    background-size: cover;
    background-position: center 25%; /* Focus on the upper part of the image */
    border-radius: 0.75rem;
    overflow: hidden;
    aspect-ratio: 3 / 4;
    transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
    border: 1px solid var(--border-primary);
    cursor: pointer;
}
.char-roster-btn:hover {
    transform: scale(1.03);
    box-shadow: 0 0 15px rgba(129, 140, 248, 0.4);
}
.char-roster-btn::after {
    content: '';
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    height: 70%;
    background: linear-gradient(to top, rgba(0,0,0,0.95), transparent);
    pointer-events: none;
}
.char-roster-content {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    padding: 1rem;
    z-index: 10;
}
/* --- End New Character Roster Button Styling --- */


/* --- Chat Components --- */
#chat-window {
    display: flex;
    flex-direction: column;
    align-items: center;
}
#chat-window h1, 
#chat-window h2, 
#chat-window h3 { 
    font-weight: bold; 
    margin-bottom: 0.0rem;
}
#chat-window h1 { font-size: 1.5em; } 
#chat-window h2 { font-size: 1.25em; } 
#chat-window h3 { font-size: 1.1em; }

#chat-window blockquote {
    border-left: 3px solid var(--brand-color);
    padding-left: 1rem;
    margin: 0.5rem 0;
    color: var(--text-secondary);
    font-style: italic;
    font-weight: bold;
}

#chat-window em {
    color: var(--text-accent);
    font-style: italic;
}

.chat-bubble-container {
    width: 100%;
    max-width: 1000px;
	align-content: center;
}

.bubble-header {
    position: relative;
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.5rem 0.25rem;
}

.bubble-header .timestamp {
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
}

.bubble-char-image {
    float: left;
    width: var(--bubble-image-size);
    height: auto;
    border-radius: 0.5rem;
    margin-right: 1rem;
    margin-bottom: 0.5rem;
}

.bubble-body { font-size: var(--chat-font-size); }
.bubble-body .whitespace-pre-wrap {
    overflow: hidden; /* BFC to contain the float */
    white-space: normal;
}
.bubble-body .whitespace-pre-wrap p {
    margin: 0;
    white-space: normal;
}
.bubble-body .whitespace-pre-wrap p + p {
    margin-top: 0.75em;
}

/* Style for scrolling memory lists */
#static-entries-list, #dynamic-entries-list {
    overflow-y: auto;
    /* max-height: 20rem; Corresponds to roughly 6-7 entries */
    min-height: 0; /* Important for flex/grid children to respect max-height */
}

/* --- Hover & Animation Effects --- */
.chat-bubble-container:hover .action-btn-group,
.chat-bubble-container:hover .timestamp { 
    opacity: 1; 
}

.action-btn-group, .timestamp { 
    opacity: 0; 
    transition: opacity var(--transition-fast);
}

#character-portrait-container img { 
    transition: opacity var(--transition-slow); 
}

@keyframes fadeIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
}

@keyframes pulseOpacity {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.6; }
}

.typing-bubble-pulse {
    animation: pulseOpacity 1.5s ease-in-out infinite;
}

.chat-bubble-container.new-message {
    animation: fadeIn var(--transition-medium);
}

/* --- Layout Management & Responsiveness --- */

/* Default to Vertical/Mobile layout first */
#desktop-header { display: none; }
#mobile-header { display: flex; }

body.layout-vertical #app-container { padding: 0; }
body.layout-vertical #main-header { position: fixed; top: calc(.0rem + env(safe-area-inset-top)); left: 0; right: 0; z-index: 52; margin: 0; padding: 0.5rem; background: transparent; pointer-events: none; }
body.layout-vertical #hamburger-menu-button-container { opacity: 0.3; transition: opacity 0.3s ease; pointer-events: auto; position: relative; z-index: 52;}
body.layout-vertical #hamburger-menu-button-container:hover { opacity: 1; }
body.layout-vertical #mobile-story-title-overlay { 
    position: fixed; 
    top: 0; 
    left: 0; 
    width: 100%; 
    z-index: 51; /* Increased to 51 to sit above the main header */
    background: linear-gradient(to bottom, rgba(0,0,0,0.7), transparent); 
    padding: .3rem;
	padding-top: calc(.3rem + env(safe-area-inset-top)); /* Pushes text below the notch */
    text-align: center; 
    opacity: 0; 
    transition: opacity 0.3s ease; 
    pointer-events: auto; 
}

/* NEW RULE: Keeps the title visible when you hover over it or click to edit */
body.layout-vertical #mobile-story-title-overlay:hover,
body.layout-vertical #mobile-story-title-overlay:focus {
    opacity: 1 !important;
}
body.layout-vertical #chat-window-container { justify-content: center; border-radius: 0; margin-bottom: 0 !important; }
body.layout-vertical #chat-window { width: 99%; }
body.layout-vertical #character-portrait-container { display: none; }
body.layout-vertical #chat-input-container { 
    padding-top: 1rem;
    padding-left: 1rem;
    padding-right: 1rem;

    /* We use calc() to add your original 1rem padding
      to the OS's reported safe-area-inset-bottom.
      This is 0px on desktop but has a value on mobile.
    */
    padding-bottom: calc(1rem + env(safe-area-inset-bottom));

    border-top: 1px solid;
	border-top-color: color-mix(in srgb, var(--chat-text-color) 50%, transparent);
}

/* Horizontal (Desktop) Layout Overrides */
body.layout-horizontal #desktop-header { display: flex; }
body.layout-horizontal #mobile-header { display: none; }
body.layout-horizontal #app-container { padding: 0.5rem; }
body.layout-horizontal #chat-window-container { justify-content: space-between; }
body.layout-horizontal #chat-window { width: 66.66%; }
body.layout-horizontal #character-portrait-container { display: flex; width: 33.33%; }
body.layout-horizontal #mobile-header-elements { display: none !important; }

/* --- Cinematic Mode Overhaul --- */
body[data-mode="cinematic_overlay"] #cinematic-bg-1,
body[data-mode="cinematic_overlay"] #cinematic-bg-2 {
    position: fixed;
    inset: 0;
    z-index: 0;
    background-size: auto 100%; /* Sets height to 100%, width scales automatically */
    /* This centers the image horizontally, so it crops from the sides: */
    background-position: center top; 
    background-repeat: no-repeat;
}
body[data-mode="cinematic_overlay"] #app-container {
    background: transparent;
    backdrop-filter: none; /* Prevents containing the fixed-position background */
	padding: 0rem;
}
body[data-mode="cinematic_overlay"] main {
    display: flex;
    flex-direction: column;
    justify-content: flex-end; /* Pushes content to the bottom */
}
body[data-mode="cinematic_overlay"] #chat-window-container {
    flex-grow: 0; /* Prevent it from taking full height */
    height: 33.33vh;
    background: transparent;
    position: relative; /* For the gradient */
}
body[data-mode="cinematic_overlay"] #chat-window-container::before {
    content: '';
    position: absolute;
    top: -100px;
    left: 0;
    right: 0;
    height: 100px;
    background: linear-gradient(to bottom, transparent, rgba(17, 24, 39, 0.8));
    pointer-events: none;
    z-index: 20;
}
body[data-mode="cinematic_overlay"] #chat-window {
    background: transparent;
}
body[data-mode="cinematic_overlay"] #chat-input-container {
    background-color: rgba(17, 24, 39, 0.7); 
    backdrop-filter: blur(5px);
}
/* Specific fix for horizontal cinematic mode */
body.layout-horizontal[data-mode="cinematic_overlay"] #character-portrait-container {
    display: none;
}
body.layout-horizontal[data-mode="cinematic_overlay"] #chat-window {
    width: 100%; /* Take full width since side portrait is gone */
}

/* Make header float over cinematic background in horizontal mode */
body.layout-horizontal[data-mode="cinematic_overlay"] #main-header {
    position: absolute;
    top: 0.0rem;      /* Match app-container padding */
    left: 0.5rem;
    right: 0.5rem;
    z-index: 50;      /* Ensure it's on top of other elements */
    margin-bottom: 0; /* Override default margin */
    padding-top: 1rem;
	padding-left: 1rem;
    padding-right: 1rem;
    background: linear-gradient(to bottom, rgba(17, 24, 39, 0.6), transparent);
    border-radius: 0.75rem 0.75rem 0 0;
}

/* Styling for quoted dialogue in chat bubbles */
.dialogue-quote {
	filter: saturate(175%) opacity(75%) drop-shadow(1px 1px 5px black);
    font-weight: 500;          /* Makes the text slightly bolder than normal */
}

/* Push the first message bubble down from the top so that it's controls are accessible. */
#chat-window .chat-bubble-container:first-child {
    margin-top: 3rem; /* Adjust this value as needed */
}

#chat-window .chat-bubble-container:last-child {
    margin-bottom: 1rem; /* Adjust this value as needed */
}

/* By default (mobile-first / layout-vertical), show the title and hide the balancer */
.story-details-title-input {
    display: block;
}
.story-details-title-balancer {
    display: none;
}

/* When in horizontal/desktop layout, hide the title and show the balancer */
body.layout-horizontal .story-details-title-input {
    display: none;
}
body.layout-horizontal .story-details-title-balancer {
    display: block;
}
	</style>
</head>
<body data-mode="none" class="bg-gray-900 min-h-screen flex flex-col">
    
    <!-- This is where the main user interface will be inserted. -->
    <!-- PASTE content of main_ui.html HERE -->
    <!-- Background Image Container -->
<div id="global-background" class="fixed inset-0 -z-10 bg-gray-900 bg-cover bg-center transition-all duration-500"></div>

<!-- Main Application Container -->
<div class="w-full h-full flex flex-col glass-bg" id="app-container">
    
    <!-- Header -->
    <header class="mb-4 flex justify-between items-center" id="main-header">
        <!-- Desktop Header -->
        <div id="desktop-header" class="justify-between items-center w-full">

            <div class="flex items-center space-x-2">
				<button onclick="Controller.openModal('story-library-modal')" class="bg-gray-700/80 hover:bg-gray-600/80 text-white font-bold py-2 px-4 rounded-lg"  title="Story Library" style="border-color: color-mix(in srgb, var(--chat-text-color) 50%, transparent); border-width: 2px;"><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h7"></path><path d="M4 6h16M4 12h16M4 18h7" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"></path><path d="M18 18v-6" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"></path><path d="M15 12h6" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"></path></svg></button>
                
                <input type="text" id="story-title-input" class="text-2xl font-bold bg-transparent text-white p-1 rounded focus:outline-none focus:bg-black/20 w-96">
            </div>

            <div class="flex space-x-2">
                 <button onclick="Controller.openModal('characters-modal')" class="bg-gray-700/80 hover:bg-gray-600/80 text-white font-bold py-2 px-4 rounded-lg" title="Characters"><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4.354a4 4 0 110 5.292M15 21H3v-1a6 6 0 0112 0v1zm0 0h6v-1a6 6 0 00-9-5.197M15 21a6 6 0 00-9-5.197m0 0A5.965 5.965 0 0112 13a5.965 5.965 0 013 1.803"></path></svg></button>
                 <button onclick="Controller.openModal('world-map-modal')" class="bg-gray-700/80 hover:bg-gray-600/80 text-white font-bold py-2 px-4 rounded-lg" title="World Map"><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 20l-5.447-2.724A1 1 0 013 16.382V5.618a1 1 0 011.447-.894L9 7m0 13l6-3m-6 3V7m6 10l5.447 2.724A1 1 0 0021 18.382V7.618a1 1 0 00-1.447-.894L15 9m-6 4v.01"></path></svg></button>
                 <button onclick="Controller.openModal('knowledge-modal')" class="bg-gray-700/80 hover:bg-gray-600/80 text-white font-bold py-2 px-4 rounded-lg" title="Knowledge"><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.246 18 16.5 18c-1.746 0-3.332.477-4.5 1.253z"></path></svg></button>
                 <button onclick="Controller.checkWorldInfoAgent()" class="bg-gray-700/80 hover:bg-gray-600/80 text-white font-bold py-2 px-4 rounded-lg" title="Update Static Memory"><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"></path></svg></button>
                 <button onclick="Controller.openModal('settings-modal')" class="bg-gray-700/80 hover:bg-gray-600/80 text-white font-bold py-2 px-4 rounded-lg" title="Settings"><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066 2.573c-.94-1.543.826 3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path></svg></button>
            </div>
        </div>

        <!-- Mobile Header -->
        <div id="mobile-header" class="justify-end items-center w-full">
            <div class="relative" id="hamburger-menu-button-container">
                <button id="hamburger-menu-button" class="bg-gray-700/80 hover:bg-gray-600/80 text-white p-2 rounded-lg">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path></svg>
                </button>
                <div id="mobile-menu" class="hidden absolute right-0 mt-2 w-56 bg-gray-800/90 backdrop-blur-md rounded-lg shadow-xl z-50">
                    <a href="#" onclick="Controller.openModal('story-library-modal'); Controller.toggleMobileMenu(); return false;" class="block px-4 py-3 text-white hover:bg-gray-700">Story Library</a>
					<div class="px-4 py-2 text-gray-400 text-sm font-bold border-t border-gray-700">Narrative Settings</div>
                    <a href="#" onclick="Controller.openModal('characters-modal'); Controller.toggleMobileMenu(); return false;" class="block px-4 py-3 text-white hover:bg-gray-700">Characters</a>
                    <a href="#" onclick="Controller.openModal('world-map-modal'); Controller.toggleMobileMenu(); return false;" class="block px-4 py-3 text-white hover:bg-gray-700">World Map</a>
                    <a href="#" onclick="Controller.openModal('knowledge-modal'); Controller.toggleMobileMenu(); return false;" class="block px-4 py-3 text-white hover:bg-gray-700">Knowledge</a>
                    <a href="#" onclick="Controller.checkWorldInfoAgent(); Controller.toggleMobileMenu(); return false;" class="block px-4 py-3 text-white hover:bg-gray-700">Update Static</a>
                    <div class="px-4 py-2 text-gray-400 text-sm font-bold border-t border-gray-700">Settings</div>
                    <a href="#" onclick="Controller.openSettingsToTab('appearance'); Controller.toggleMobileMenu(); return false;" class="block pl-8 pr-4 py-3 text-white hover:bg-gray-700">Appearance</a>
                    <a href="#" onclick="Controller.openSettingsToTab('prompt'); Controller.toggleMobileMenu(); return false;" class="block pl-8 pr-4 py-3 text-white hover:bg-gray-700">Prompt</a>
                    <a href="#" onclick="Controller.openSettingsToTab('model'); Controller.toggleMobileMenu(); return false;" class="block pl-8 pr-4 py-3 text-white hover:bg-gray-700">Model</a>
                </div>
            </div>
        </div>
    </header>
    <!-- /Header -->

    <div id="mobile-header-elements">
         <input type="text" id="mobile-story-title-overlay" class="text-xl font-bold text-white truncate text-center bg-transparent focus:bg-black/20 w-1/2">
    </div>

    <!-- Main Content Area -->
    <main class="flex-grow min-h-0 flex flex-col relative">
        <div id="title-trigger-area" class="absolute top-0 left-0 w-full h-16 z-40" style="height: 2rem;"></div>
         <!-- Chat Window & Portrait -->
         <div id="chat-window-container" class="relative flex-grow p-2 flex min-h-0 bg-black/30 rounded-lg overflow-hidden" style="
    padding-bottom: revert; padding-top: revert;">
            <div id="cinematic-bg-1" class="absolute inset-0 bg-cover bg-no-repeat bg-center transition-opacity duration-1000 pointer-events-none opacity-0"></div>
            <div id="cinematic-bg-2" class="absolute inset-0 bg-cover bg-no-repeat bg-center transition-opacity duration-1000 pointer-events-none opacity-0"></div>
            <div id="chat-window" class="relative z-10 flex-grow overflow-y-auto"></div>
            <div id="character-portrait-container" class="flex-shrink-0 flex-col justify-center items-center" style="padding-right: 0.5rem;"></div>
         </div>
         <!-- /Chat Window & Portrait -->
         
         <!-- Chat Input & Controls -->
         <div id="chat-input-container" class="flex items-start space-x-2 sm:space-x-4" style="padding: 1rem; border-top: 1px solid; border-top-color: 
 color-mix(in srgb, var(--chat-text-color) 50%, transparent);">
             <textarea id="chat-input" class="flex-grow bg-black/30 border border-gray-600 rounded-lg p-2 color: black" placeholder="Enter your message..." rows="4" style="color: var(--chat-text-color)" ></textarea>
             <div class="flex flex-col space-y-2">
                 <select id="ai-character-selector" class="bg-black/30 border border-gray-600 rounded-lg p-2 w-full mb-2"></select>
                 <div class="flex items-center justify-center space-x-1">
                     <button id="primary-action-btn" class="bg-indigo-600/50 hover:bg-indigo-600/80 text-white font-bold p-1.5 rounded-lg" title="Send / Write for Me"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14 5l7 7m0 0l-7 7m7-7H3"></path></svg></button>
                     <button id="regen-btn" class="bg-sky-600/40 hover:bg-sky-600/70 text-white font-bold p-1.5 rounded-lg" title="Regenerate / New Response"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h5M20 20v-5h-5"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 9a9 9 0 0114.65-5.32L20 5M20 15a9 9 0 01-14.65 5.32L4 19"></path></svg></button>
                     <button id="undo-btn" class="bg-gray-600/40 hover:bg-gray-500/70 text-white font-bold p-1.5 rounded-lg" title="Undo"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 10h10a8 8 0 018 8v2M3 10l4-4m-4 4l4 4"></path></svg></button>
                 </div>
             </div>
         </div>
         <!-- /Chat Input & Controls -->
    </main>
    <!-- /Main Content Area -->

</div>
<!-- /Main Application Container -->


    <!-- This is where all the modal dialogs and templates will be inserted. -->
    <!-- PASTE content of modals.html HERE -->
<!-- Modals -->
<!-- Story Library Modal -->
<div id="story-library-modal" class="fixed inset-0 z-50 items-center justify-center hidden">
    <div class="modal-overlay absolute inset-0" onclick="Controller.closeModal('story-library-modal')"></div>
    <div class="bg-gray-800/80 backdrop-blur-md rounded-lg shadow-xl relative flex flex-col" style="width: 100%; max-height: 100%">
        <div class="p-6 border-b border-gray-700 flex justify-between items-center">
            <h2 class="text-2xl font-semibold">Story Library</h2>
            <div class="flex space-x-2">
                <button onclick="Controller.openModal('io-hub-modal')" class="bg-teal-600/80 hover:bg-teal-700/80 text-white font-bold py-2 px-4 rounded-lg">Import / Export</button>
                <button onclick="Controller.createNewStory()" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg">New Story</button>
            </div>
        </div>
        <div id="library-content-container" class="flex-grow flex min-h-0"></div>
        <div class="p-4 bg-black/20 border-t border-gray-700 flex justify-end">
            <button onclick="Controller.closeModal('story-library-modal')" class="bg-gray-600 hover:bg-gray-700 font-bold py-2 px-4 rounded-lg">Close</button>
        </div>
    </div>
</div>

<!-- [NEW] Import/Export Hub Modal -->
<div id="io-hub-modal" class="fixed inset-0 z-[60] items-center justify-center hidden">
    <div class="modal-overlay absolute inset-0 bg-black/50" onclick="Controller.closeModal('io-hub-modal')"></div>
    <div id="io-hub-modal-content" class="bg-gray-800/80 backdrop-blur-md rounded-lg shadow-xl w-11/12 max-w-4xl relative flex flex-col max-h-[90vh]">
        <!-- Content injected by UIManager.renderIOHubModal -->
    </div>
</div>

<!-- [NEW] Bulk Import Report Modal -->
<div id="report-modal" class="fixed inset-0 z-[70] items-center justify-center hidden">
    <div class="modal-overlay absolute inset-0 bg-black/60" onclick="Controller.closeModal('report-modal')"></div>
    <div id="report-modal-content" class="bg-gray-800/80 backdrop-blur-md rounded-lg shadow-xl w-11/12 max-w-2xl relative flex flex-col max-h-[90vh]">
        <!-- Content injected by UIManager.showBulkImportReport -->
    </div>
</div>

<!-- [NEW] Loading Spinner Overlay -->
<div id="loading-spinner" class="fixed inset-0 z-[80] bg-black/60 backdrop-blur-sm flex-col items-center justify-center hidden" style="display: none;">
    <div class="w-16 h-16 border-4 border-t-indigo-500 border-gray-600 rounded-full animate-spin"></div>
    <p id="spinner-message" class="mt-4 text-white font-semibold">Loading...</p>
</div>


<!-- Story Details Modal (for mobile view) -->
<div id="story-details-modal" class="fixed inset-0 z-50 items-center justify-center hidden"><div class="modal-overlay absolute inset-0" onclick="Controller.closeModal('story-details-modal')"></div><div class="bg-gray-800/80 backdrop-blur-md rounded-lg shadow-xl relative flex flex-col" style="width: 100%; max-width: 1200px; height: 100%;"><div id="story-details-content-mobile" class="flex-grow flex flex-col min-h-0"></div><div class="p-4 bg-black/20 border-t border-gray-700 flex justify-end"><button onclick="Controller.closeModal('story-details-modal')" class="bg-gray-600 hover:bg-gray-700 font-bold py-2 px-4 rounded-lg">Back to Library</button></div></div></div>

<!-- Characters Modal -->
<div id="characters-modal" class="fixed inset-0 z-50 items-center justify-center hidden"><div class="modal-overlay absolute inset-0" onclick="Controller.closeModal('characters-modal')"></div><div class="bg-gray-800/80 backdrop-blur-md rounded-lg shadow-xl w-11/12 md:w-3/4 lg:w-2/3 relative flex flex-col max-h-[90vh]"><div class="p-6 border-b border-gray-700 flex justify-between items-center"><h2 class="text-2xl font-semibold">Character Roster</h2><button onclick="Controller.addCharacter()" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg">Add Character</button></div><div class="p-6 overflow-y-auto"><div id="characters-container" class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6"></div></div><div class="p-4 bg-black/20 border-t border-gray-700 flex justify-end"><button onclick="Controller.closeModal('characters-modal')" class="bg-gray-600 hover:bg-gray-700 font-bold py-2 px-4 rounded-lg">Done</button></div></div></div>

<!-- Individual Character Detail Modal -->
<div id="character-detail-modal" class="fixed inset-0 z-[60] items-center justify-center hidden">
    <div class="modal-overlay absolute inset-0 bg-black/50" onclick="Controller.closeModal('character-detail-modal')"></div>
    <div id="character-detail-modal-content" class="bg-gray-800/80 backdrop-blur-md rounded-lg shadow-xl relative flex flex-col max-h-[90vh]" style="width: 95%; max-width: 1200px;">
        <!-- Content will be injected by JS -->
    </div>
</div>

<!-- Knowledge Modal (Static & Dynamic) -->
<div id="knowledge-modal" class="fixed inset-0 z-50 items-center justify-center hidden p-4">
    <div class="modal-overlay absolute inset-0" onclick="Controller.closeModal('knowledge-modal')"></div>
    <div class="bg-gray-800/80 backdrop-blur-md rounded-lg shadow-xl relative flex flex-col w-full max-w-6xl max-h-[90vh] overflow-hidden">
        
        <div class="p-4 flex-shrink-0 flex justify-between items-center border-b border-gray-700">
            <div class="flex space-x-4">
                <button id="knowledge-tab-static" onclick="Controller.switchKnowledgeTab('static')" class="py-2 px-2 font-semibold text-lg border-b-2 border-indigo-500 text-white">Static</button>
                <button id="knowledge-tab-dynamic" onclick="Controller.switchKnowledgeTab('dynamic')" class="py-2 px-2 font-semibold text-lg border-b-2 border-transparent text-gray-400 hover:text-white">Dynamic</button>
            </div>
            <div class="flex items-center space-x-2">
                <button id="knowledge-add-button" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg text-sm">Add Entry</button>
                <button onclick="Controller.closeModal('knowledge-modal')" class="bg-gray-700 hover:bg-gray-600 text-gray-300 hover:text-white p-2 rounded-lg transition-colors" title="Close">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </div>
        </div>

        <div class="p-4 flex-grow overflow-y-auto min-h-0">
            
            <div id="knowledge-static-content" class="h-full flex flex-col md:flex-row gap-4">
                <div id="static-entries-list" class="w-full md:w-1/3 bg-black/30 rounded-lg p-4 overflow-y-auto h-48 md:h-full flex-shrink-0"></div>
                <div id="static-entry-details" class="w-full md:w-2/3 bg-black/30 rounded-lg p-4 overflow-y-auto flex-grow">
                    <div id="static-entry-details-content" class="h-full">
                        <div class="text-gray-400 flex items-center justify-center h-full">Select a static entry.</div>
                    </div>
                </div>
            </div>

            <div id="knowledge-dynamic-content" class="hidden h-full flex flex-col md:flex-row gap-4">
                <div id="dynamic-entries-list" class="w-full md:w-1/3 bg-black/30 rounded-lg p-4 overflow-y-auto h-48 md:h-full flex-shrink-0"></div>
                <div id="dynamic-entry-details" class="w-full md:w-2/3 bg-black/30 rounded-lg p-4 overflow-y-auto flex-grow">
                    <div id="dynamic-entry-details-content" class="h-full">
                        <div class="text-gray-400 flex items-center justify-center h-full">Select a dynamic entry.</div>
                    </div>
                </div>
            </div>
        </div>
        </div>
</div>

<!-- World Map Modal -->
<div id="world-map-modal" class="fixed inset-0 z-50 items-center justify-center hidden">
    <div class="modal-overlay absolute inset-0" onclick="Controller.closeModal('world-map-modal')"></div>
    <div id="world-map-modal-content" class="bg-gray-800/80 backdrop-blur-md rounded-lg shadow-xl w-11/12 max-w-6xl relative flex flex-col max-h-[90vh] min-h-[50vh]">
        <!-- Content injected by JS -->
    </div>
</div>

<!-- Settings Modal -->
<div id="settings-modal" class="fixed inset-0 z-50 items-center justify-center hidden p-4">
    <div class="modal-overlay absolute inset-0" onclick="Controller.closeModal('settings-modal')"></div>
    <div class="bg-gray-800/80 backdrop-blur-md rounded-lg shadow-xl w-full max-w-2xl max-h-[90vh] relative flex flex-col">
        
        <div class="p-6 flex-shrink-0 border-b border-gray-700 flex justify-between items-start">
            <div>
                <h2 class="text-2xl font-semibold mb-4">Settings</h2>
                <div class="flex -mb-px space-x-4">
                    <button id="settings-tab-appearance" onclick="Controller.switchSettingsTab('appearance')" class="pb-2 font-semibold border-b-2 border-indigo-500 text-white transition-colors">Appearance</button>
                    <button id="settings-tab-prompt" onclick="Controller.switchSettingsTab('prompt')" class="pb-2 font-semibold border-b-2 border-transparent text-gray-400 hover:text-white transition-colors">Prompt</button>
                    <button id="settings-tab-model" onclick="Controller.switchSettingsTab('model')" class="pb-2 font-semibold border-b-2 border-transparent text-gray-400 hover:text-white transition-colors">Model</button>
                </div>
            </div>
            <button onclick="Controller.closeModal('settings-modal')" class="bg-gray-700 hover:bg-gray-600 text-gray-300 hover:text-white p-2 rounded-lg transition-colors -mt-2" title="Close">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
        </div>

        <div class="p-6 overflow-y-auto flex-grow min-h-0" id="settings-content-container">
            ...
        </div>
        </div>
</div>

<!-- Edit Response Modal -->
<div id="edit-response-modal" class="fixed inset-0 z-50 items-center justify-center hidden">
    <div class="modal-overlay absolute inset-0" onclick="Controller.closeModal('edit-response-modal')"></div>
    <div class="bg-gray-800/80 backdrop-blur-md rounded-lg shadow-xl w-11/12 md:w-2/3 lg:w-1/2 relative flex flex-col max-h-[75vh]">
        <div class="p-6 border-b border-gray-700 flex-shrink-0"> <h3 class="text-xl font-bold">Edit Response</h3> </div>
        <div class="p-6 overflow-y-auto"> <textarea id="edit-modal-input" class="w-full bg-gray-900 border-gray-700 rounded-lg p-2 resize-none"></textarea> </div>
        <div class="p-4 bg-black/20 border-t border-gray-700 flex justify-end space-x-4 flex-shrink-0">
            <button onclick="Controller.closeModal('edit-response-modal')" class="bg-gray-600 hover:bg-gray-700 font-bold py-2 px-4 rounded-lg">Cancel</button>
            <button id="edit-modal-save-button" class="bg-indigo-600 hover:bg-indigo-700 font-bold py-2 px-4 rounded-lg">Save</button>
        </div>
    </div>
</div>

<!-- View Raw Prompt Modal -->
<div id="view-raw-prompt-modal" class="fixed inset-0 z-50 items-center justify-center hidden"><div class="modal-overlay absolute inset-0" onclick="Controller.closeModal('view-raw-prompt-modal')"></div><div class="bg-gray-800/80 backdrop-blur-md rounded-lg shadow-xl w-11/12 md:w-3/4 lg:w-2/3 relative flex flex-col max-h-[90vh]"><div class="p-6 border-b border-gray-700"><h2 class="text-2xl font-semibold">Raw Prompt</h2></div><div class="p-6 overflow-y-auto flex-grow bg-gray-900"><pre id="raw-prompt-content" class="text-sm whitespace-pre-wrap"></pre></div><div class="p-4 bg-black/20 border-t border-gray-700 flex justify-end"><button onclick="Controller.closeModal('view-raw-prompt-modal')" class="bg-gray-600 hover:bg-gray-700 font-bold py-2 px-4 rounded-lg">Done</button></div></div></div>

<!-- Example Dialogue Modal -->
<div id="example-dialogue-modal" class="fixed inset-0 z-[60] items-center justify-center hidden">
    <div class="modal-overlay absolute inset-0 bg-black/50" onclick="Controller.closeModal('example-dialogue-modal')"></div>
    <div class="bg-gray-800/80 backdrop-blur-md rounded-lg shadow-xl w-11/12 md:w-3/4 lg:w-2/3 relative flex flex-col max-h-[90vh]">
        <div class="p-6 border-b border-gray-700 flex justify-between items-center">
            <h2 class="text-2xl font-semibold">Edit Example Dialogue</h2>
            <button onclick="Controller.addExampleDialogueTurn()" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg">Add Turn</button>
        </div>
        <div id="example-dialogue-container" class="p-6 overflow-y-auto flex-grow space-y-4"></div>
        <div class="p-4 bg-black/20 border-t border-gray-700 flex justify-end">
            <button onclick="Controller.closeModal('example-dialogue-modal')" class="bg-gray-600 hover:bg-gray-700 font-bold py-2 px-4 rounded-lg">Done</button>
        </div>
    </div>
</div>

<!-- Generic Confirmation Modal -->
<div id="confirmation-modal" class="fixed inset-0 z-[70] items-center justify-center hidden">
    <div class="modal-overlay absolute inset-0 bg-black/60" onclick="Controller.closeModal('confirmation-modal')"></div>
    <div class="bg-gray-800/80 backdrop-blur-md rounded-lg shadow-xl w-11/12 max-w-md relative flex flex-col">
        <div class="p-6">
            <h3 class="text-xl font-bold mb-4">Are you sure?</h3>
            <p id="confirmation-modal-message" class="text-gray-300">This action cannot be undone.</p>
        </div>
        <div class="p-4 bg-black/20 border-t border-gray-700 flex justify-end space-x-4">
            <button onclick="Controller.closeModal('confirmation-modal')" class="bg-gray-600 hover:bg-gray-700 font-bold py-2 px-4 rounded-lg">Cancel</button>
            <button id="confirmation-modal-confirm-button" class="bg-red-600 hover:bg-red-700 font-bold py-2 px-4 rounded-lg">Confirm</button>
        </div>
    </div>
</div>
<!-- OpenRouter Model Selector Modal -->
<div id="openrouter-model-modal" class="fixed inset-0 z-[80] items-center justify-center hidden">
    <div class="modal-overlay absolute inset-0 bg-black/60" onclick="Controller.closeModal('openrouter-model-modal')"></div>
    <div class="bg-gray-800/95 backdrop-blur-md rounded-lg shadow-xl w-11/12 max-w-2xl relative flex flex-col max-h-[85vh]">
        <div class="p-4 border-b border-gray-700 flex justify-between items-center">
            <h3 class="text-xl font-bold">Select OpenRouter Model</h3>
            <button onclick="Controller.closeModal('openrouter-model-modal')" class="text-gray-400 hover:text-white">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
        </div>
        <div class="p-4 border-b border-gray-700">
            <input type="text" id="openrouter-model-search" class="w-full rounded-lg p-3 bg-gray-900/50 border border-gray-600 focus:border-indigo-500 focus:outline-none" placeholder="Search models by name or provider...">
        </div>
        <div id="openrouter-model-list" class="flex-1 overflow-y-auto p-2 min-h-[300px]">
            <div class="flex items-center justify-center h-full text-gray-400">
                <span id="openrouter-model-loading">Loading models...</span>
            </div>
        </div>
        <div class="p-4 bg-black/20 border-t border-gray-700">
            <p class="text-sm text-gray-400">Selected: <span id="openrouter-selected-model-display" class="text-indigo-400 font-medium">None</span></p>
        </div>
    </div>
</div>
<!-- /Modals -->

<!-- Hidden template for settings tabs -->
<div id="settings-templates" class="hidden">
    <div id="settings-appearance-content" class="space-y-6">
        <div>
            <div class="grid grid-cols-2 gap-4">
                <div>
                    <label for="font-selector" class="text-gray-400 text-sm block mb-2">Chat Font</label>
                    <select id="font-selector" class="w-full rounded-lg p-2">
                        <option value="'Inter', sans-serif">Inter (Sans-Serif)</option>
                        <option value="'Nunito Sans', sans-serif">Nunito Sans (Sans-Serif)</option>
                        <option value="'Lora', serif">Lora (Serif)</option>
                        <option value="'Roboto Slab', serif">Roboto Slab</option>
                        <option value="'EB Garamond', serif">EB Garamond</option>
                        <option value="'Cormorant Garamond', serif">Cormorant Garamond</option>
                        <option value="'Dancing Script', cursive">Dancing Script</option>
                        <option value="'Source Code Pro', monospace">Source Code Pro</option>
                    </select>
                </div>
                <div><label for="chat-text-color" class="text-gray-400 text-sm block mb-2">Chat Text Color</label><input type="color" id="chat-text-color" class="w-full rounded-lg p-1 h-10"></div>
            </div>
		<div>
                <label for="background-image-upload" class="text-gray-400 text-sm block mb-2">Background Image</label>
                <div class="flex space-x-2">
                    <input type="file" id="background-image-upload" accept="image/*" class="block w-full text-sm text-gray-400 file:mr-4 file:py-1 file:px-3 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-gray-700 file:text-gray-200 hover:file:bg-gray-600 cursor-pointer">
                    <button id="background-image-clear" class="bg-red-600/80 hover:bg-red-700/80 text-white font-bold py-1 px-3 rounded-lg">Clear</button>
                </div>
            </div>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-4">
                <div><label for="bubble-opacity-slider" class="text-gray-400 text-sm block mb-2">Chat Bubble Opacity</label><div class="flex items-center space-x-4"><input type="range" id="bubble-opacity-slider" class="w-full" min="0" max="1" step="0.05"><span id="bubble-opacity-value" class="text-sm text-gray-400 w-12 text-right"></span></div></div>
                <div><label for="blur-slider" class="text-gray-400 text-sm block mb-2">Background Blur (px)</label><div class="flex items-center space-x-4"><input type="range" id="blur-slider" class="w-full" min="0" max="20" step="1"><span id="blur-value" class="text-sm text-gray-400 w-12 text-right"></span></div></div>
                <div><label for="text-size-slider" class="text-gray-400 text-sm block mb-2">Text Size (px)</label><div class="flex items-center space-x-4"><input type="range" id="text-size-slider" class="w-full" min="12" max="24" step="1"><span id="text-size-value" class="text-sm text-gray-400 w-12 text-right"></span></div></div>
                <div><label for="bubble-image-size-slider" class="text-gray-400 text-sm block mb-2">Bubble Image Size (px)</label><div class="flex items-center space-x-4"><input type="range" id="bubble-image-size-slider" class="w-full" min="50" max="200" step="10"><span id="bubble-image-size-value" class="text-sm text-gray-400 w-12 text-right"></span></div></div>
            </div>
            <label class="text-gray-400 text-sm block mt-4 mb-2">Character Image Display</label><div class="flex space-x-4" id="character-image-display"><label class="flex items-center space-x-2 cursor-pointer"><input type="radio" name="imageDisplayMode" value="none" checked><span>None</span></label><label class="flex items-center space-x-2 cursor-pointer"><input type="radio" name="imageDisplayMode" value="cinematic_overlay"><span>Cinematic</span></label><label class="flex items-center space-x-2 cursor-pointer"><input type="radio" name="imageDisplayMode" value="bubble"><span>Bubble</span></label></div>
        </div>
    </div>
    <!-- Replaced the Prompt tab content with individual, collapsible <details> sections for better organization. -->
    <div id="settings-prompt-content" class="space-y-2">
        <details><summary class="font-semibold text-lg cursor-pointer hover:text-indigo-300 py-2">Core Prompts</summary><div class="p-4 space-y-4 bg-black/20 rounded-b-lg"><div><h3 class="text-base font-medium mb-2">System Prompt (Global Fallback)</h3><p class="text-gray-400 text-sm mb-2">Used by AI characters who don't have their own specific instructions.</p><textarea id="system-prompt-input" class="w-full rounded-lg p-2 resize-y" rows="4"></textarea></div><hr class="border-gray-700"><div><h3 class="text-base font-medium mb-2">Event Master Prompt</h3><p class="text-gray-400 text-sm mb-2">Define the base instruction for the Event Master, which injects surprise events.</p><textarea id="event-master-prompt-input" class="w-full rounded-lg p-2 resize-y" rows="4"></textarea></div></div></details>
        <details><summary class="font-semibold text-lg cursor-pointer hover:text-indigo-300 py-2">Persona Generation Prompt</summary><div class="p-4 bg-black/20 rounded-b-lg"><p class="text-gray-400 text-sm mb-2">Used by the AI button on a character's persona. Use <code>{concept}</code> for the existing text.</p><textarea id="prompt-persona-gen-input" class="w-full rounded-lg p-2 resize-y" rows="4"></textarea></div></details>
        <details><summary class="font-semibold text-lg cursor-pointer hover:text-indigo-300 py-2">World Map Generation Prompt</summary><div class="p-4 bg-black/20 rounded-b-lg"><p class="text-gray-400 text-sm mb-2">Used to generate the entire world map. Use <code>{characters}</code>, <code>{static}</code>, and <code>{recent}</code>.</p><textarea id="prompt-world-map-gen-input" class="w-full rounded-lg p-2 resize-y" rows="6"></textarea></div></details>
        <details><summary class="font-semibold text-lg cursor-pointer hover:text-indigo-300 py-2">Location Prompt Generation</summary><div class="p-4 bg-black/20 rounded-b-lg"><p class="text-gray-400 text-sm mb-2">Used to generate a location's detailed prompt. Use <code>{name}</code> and <code>{description}</code>.</p><textarea id="prompt-location-gen-input" class="w-full rounded-lg p-2 resize-y" rows="4"></textarea></div></details>
        <details><summary class="font-semibold text-lg cursor-pointer hover:text-indigo-300 py-2">Memory Entry Generation</summary><div class="p-4 bg-black/20 rounded-b-lg"><p class="text-gray-400 text-sm mb-2">Used for Static/Dynamic memory entries. Use <code>{title}</code> and <code>{triggers}</code>.</p><textarea id="prompt-entry-gen-input" class="w-full rounded-lg p-2 resize-y" rows="4"></textarea></div></details>
        <details><summary class="font-semibold text-lg cursor-pointer hover:text-indigo-300 py-2">Location Memory Summary</summary><div class="p-4 bg-black/20 rounded-b-lg"><p class="text-gray-400 text-sm mb-2">Used to auto-summarize events when you leave a location. Use <code>{transcript}</code>.</p><textarea id="prompt-location-memory-gen-input" class="w-full rounded-lg p-2 resize-y" rows="4"></textarea></div></details>
        <div class="flex space-x-2 pt-4"><button onclick="Controller.openViewRawPromptModal()" class="bg-gray-600/80 hover:bg-gray-500/80 text-white font-bold py-2 px-4 rounded-lg">View Raw Prompt</button><button onclick="Controller.openModal('example-dialogue-modal')" class="bg-sky-600/80 hover:bg-sky-500/80 text-white font-bold py-2 px-4 rounded-lg">Edit Example Dialogue</button></div>
    </div>
<div id="settings-model-content" class="space-y-6">
        <p class="text-sm text-amber-300 bg-amber-900/50 p-3 rounded-lg -mt-2 mb-4"><strong>Note:</strong> These model settings are persistent and apply globally to all stories.</p>
        
        <div><h3 class="text-lg font-medium mb-2">AI Provider</h3><div class="flex space-x-4"><label class="flex items-center space-x-2 cursor-pointer"><input type="radio" name="apiProvider" value="gemini" onchange="Controller.setApiProvider('gemini')"><span>Gemini</span></label><label class="flex items-center space-x-2 cursor-pointer"><input type="radio" name="apiProvider" value="openrouter" onchange="Controller.setApiProvider('openrouter')"><span>OpenRouter</span></label><label class="flex items-center space-x-2 cursor-pointer"><input type="radio" name="apiProvider" value="koboldcpp" onchange="Controller.setApiProvider('koboldcpp')"><span>KoboldCPP</span></label><label class="flex items-center space-x-2 cursor-pointer"><input type="radio" name="apiProvider" value="lmstudio" onchange="Controller.setApiProvider('lmstudio')"><span>LM Studio</span></label></div></div><div id="gemini-settings"><h3 class="text-lg font-medium">Gemini API Settings</h3><p class="text-gray-400 text-sm mb-2">Required for text generation.</p><input type="password" id="gemini-api-key-input" class="w-full rounded-lg p-2" placeholder="Enter Gemini API key"></div><div id="openrouter-settings"><h3 class="text-lg font-medium">OpenRouter API Settings</h3><p class="text-gray-400 text-sm mb-2">Your key and model selection.</p><input type="password" id="openrouter-api-key-input" class="w-full rounded-lg p-2" placeholder="Enter OpenRouter API key"><div class="mt-3"><label class="text-gray-400 text-sm block mb-2">Model</label><div class="flex items-center gap-2"><span id="openrouter-model-display" class="flex-1 bg-gray-900/50 rounded-lg p-2 text-gray-300 truncate">No model selected</span><button onclick="Controller.openOpenRouterModelSelector()" class="bg-indigo-600 hover:bg-indigo-700 px-4 py-2 rounded-lg text-white font-medium whitespace-nowrap">Browse Models</button></div></div></div><div id="koboldcpp-settings"><h3 class="text-lg font-medium">KoboldCPP Settings</h3><p class="text-amber-400 text-sm mb-2 bg-amber-900/50 p-2 rounded-md">Ensure your local server is running with default URL.</p><div><label for="koboldcpp-template-selector" class="text-gray-400 text-sm block mb-2">Prompt Template</label><select id="koboldcpp-template-selector" class="w-full rounded-lg p-2"><option value="none">None (Raw Text)</option><option value="mistral">Mistral</option><option value="chatml">ChatML</option><option value="alpaca">Alpaca</option></select></div><div><label for="koboldcpp-min-p-slider" class="text-gray-400 text-sm block mt-4 mb-2">Min P</label><div class="flex items-center space-x-4"><input type="range" id="koboldcpp-min-p-slider" class="w-full" min="0" max="1" step="0.05"><span id="koboldcpp-min-p-value" class="text-sm text-gray-400 w-12 text-right"></span></div></div><div><label for="koboldcpp-dry-slider" class="text-gray-400 text-sm block mt-4 mb-2">DRY (Repetition Penalty)</label><div class="flex items-center space-x-4"><input type="range" id="koboldcpp-dry-slider" class="w-full" min="0" max="1" step="0.05"><span id="koboldcpp-dry-value" class="text-sm text-gray-400 w-12 text-right"></span></div></div></div><div id="lmstudio-settings"><h3 class="text-lg font-medium">LM Studio Settings</h3><p class="text-amber-400 text-sm mb-2 bg-amber-900/50 p-2 rounded-md">Ensure LM Studio is running with a model loaded. Default URL is http://localhost:1234</p><div><label for="lmstudio-url-input" class="text-gray-400 text-sm block mb-2">LM Studio Server URL</label><input type="text" id="lmstudio-url-input" class="w-full rounded-lg p-2" placeholder="http://localhost:1234"></div></div>
    </div>
</div>


    <!-- Application Logic - The order of these scripts is important! -->
    <script>
    <!-- PASTE content of modules.js HERE -->
// Utility function to prevent a function from being called too frequently.
const debounce = (func, wait) => { let timeout; return function(...args) { const context = this; clearTimeout(timeout); timeout = setTimeout(() => func.apply(context, args), wait); }; };

/**
 * DBService (resilient, fail-soft, self-initializing)
 * - Never throws during app init; callers can await methods safely.
 * - Gracefully handles blocked upgrades, missing IDB (private mode), and transient errors.
 * - All public methods resolve to sensible defaults instead of rejecting.
 */
const DBService = {
  db: null,
  DB_NAME: "EllipsisDB",
  OPEN_TIMEOUT_MS: 3000, // soft guard so init can't hang the UI indefinitely

  /**
   * Open the database (version 1) and create the store if needed.
   * Never rejects; resolves to true if usable, false if unavailable.
   */
  _open(version = 1) {
    return new Promise((resolve) => {
      try {
        if (this.db) return resolve(true);
        if (!("indexedDB" in window)) {
          console.warn("IndexedDB not supported in this environment.");
          return resolve(false);
        }

        const request = indexedDB.open(this.DB_NAME, version);

        // Soft timeout so a blocked upgrade can't lock the app
        const timeout = setTimeout(() => {
          console.warn("IDB open timed out (likely blocked). Failing soft.");
          // Let the app continue without image cache
          resolve(false);
        }, this.OPEN_TIMEOUT_MS);

        request.onerror = (event) => {
          clearTimeout(timeout);
          console.warn("IndexedDB open error (fail-soft):", event?.target?.error);
          resolve(false);
        };

        request.onblocked = () => {
          clearTimeout(timeout);
          console.warn(
            "IndexedDB upgrade is blocked by another tab/window. Continuing without cache."
          );
          resolve(false);
        };

		request.onupgradeneeded = (event) => {
          try {
            const db = event.target.result;
            
            // 1. Create/check characterImages store
            if (!db.objectStoreNames.contains("characterImages")) {
              db.createObjectStore("characterImages");
              console.log("Object store created: characterImages");
            }

            // 2. Create stories store (metadata)
            // We will use the story 'id' (a UUID) as the keyPath.
            // This tells IDB to use the 'id' field on the object as its primary key.
            if (!db.objectStoreNames.contains("stories")) {
              db.createObjectStore("stories", { keyPath: "id" });
              console.log("Object store created: stories");
            }

            // 3. Create narratives store (heavy data)
            // We will also use the narrative 'id' as the keyPath.
            if (!db.objectStoreNames.contains("narratives")) {
              db.createObjectStore("narratives", { keyPath: "id" });
              console.log("Object store created: narratives");
            }
          } catch (e) {
            console.warn("onupgradeneeded failed (fail-soft):", e);
          }
        };

        request.onsuccess = (event) => {
          clearTimeout(timeout);
          try {
            this.db = event.target.result;
            // Close politely if a future upgrade happens elsewhere
            this.db.onversionchange = () => {
              console.warn("IDB version change detected; closing DB.");
              try { this.db.close(); } catch {}
              this.db = null;
            };
            console.log("IndexedDB ready.");
            resolve(true);
          } catch (e) {
            console.warn("IDB onsuccess handler failed (fail-soft):", e);
            resolve(false);
          }
        };
      } catch (err) {
        console.warn("IDB _open threw (fail-soft):", err);
        resolve(false);
      }
    });
  },

  /**
   * Public init. Never throws; resolves to void.
   */
  async init() {
    if (this.db) return;
    const ok = await this._open(2);
    if (!ok) {
      // Keep running without a DB; callers will no-op gracefully.
      return;
    }
  },

  /**
   * Ensure DB is ready. Returns boolean (true if usable).
   */
  async ensure() {
    if (this.db) return true;
    await this.init();
    return !!this.db;
  },

  /**
   * Save a Blob under a string key. Resolves boolean (success).
   */
  async saveImage(id, blob) {
    if (!(await this.ensure())) return false;
    return new Promise((resolve) => {
		try {
		  const tx = this.db.transaction(["characterImages"], "readwrite");
		  const store = tx.objectStore("characterImages");

        tx.onabort = () => resolve(false);
        tx.onerror = () => resolve(false);

        const req = store.put(blob, id);
        req.onsuccess = () => resolve(true);
        req.onerror = () => resolve(false);
      } catch (e) {
        console.warn("saveImage failed (fail-soft):", e);
        resolve(false);
      }
    });
  },

  /**
   * Fetch a Blob by id. Resolves Blob|null.
   */
  async getImage(id) {
    if (!(await this.ensure())) return null;
    return new Promise((resolve) => {
		try {
		  const tx = this.db.transaction(["characterImages"], "readonly");
		  const store = tx.objectStore("characterImages");

        tx.onabort = () => resolve(null);
        tx.onerror = () => resolve(null);

        const req = store.get(id);
        req.onsuccess = () => resolve(req.result ?? null);
        req.onerror = () => resolve(null);
      } catch (e) {
        console.warn("getImage failed (fail-soft):", e);
        resolve(null);
      }
    });
  },

  /**
   * Delete a key. Resolves boolean (success).
   */
  async deleteImage(id) {
    if (!(await this.ensure())) return false;
    return new Promise((resolve) => {
		try {
		  const tx = this.db.transaction(["characterImages"], "readwrite");
		  const store = tx.objectStore("characterImages");

        tx.onabort = () => resolve(false);
        tx.onerror = () => resolve(false);

        const req = store.delete(id);
        req.onsuccess = () => resolve(true);
        req.onerror = () => resolve(false);
      } catch (e) {
        console.warn("deleteImage failed (fail-soft):", e);
        resolve(false);
      }
    });
  },

  /**
   * Clear the store. Resolves boolean (success).
   */
  async clear() {
    if (!(await this.ensure())) return false;
    return new Promise((resolve) => {
	try {
	  const tx = this.db.transaction(["characterImages"], "readwrite");
	  const store = tx.objectStore("characterImages");

        tx.onabort = () => resolve(false);
        tx.onerror = () => resolve(false);

        const req = store.clear();
        req.onsuccess = () => resolve(true);
        req.onerror = () => resolve(false);
      } catch (e) {
        console.warn("clear failed (fail-soft):", e);
        resolve(false);
      }
    });
  },

  /**
   * Close the DB handle.
   */
  close() {
    try {
      if (this.db) this.db.close();
    } catch (e) {
      console.warn("DB close failed (ignored):", e);
    } finally {
      this.db = null;
    }
  },
  // ===================================================================
  // NEW CRUD METHODS FOR STORIES & NARRATIVES
  // These are "dumb" functions. They only do one job, which is
  // why we will build a StoryService to orchestrate them.
  // ===================================================================

  /**
   * Saves or updates a single story object in the 'stories' store.
   * @param {object} story - The story object (metadata only).
   * @returns {Promise<boolean>} True on success, false on failure.
   */
  async saveStory(story) {
    if (!(await this.ensure())) return false;
    return new Promise((resolve) => {
      try {
        const tx = this.db.transaction(["stories"], "readwrite");
        const store = tx.objectStore("stories");
        // 'put' will add or update the record based on its keyPath ('id')
        const req = store.put(story);
        req.onsuccess = () => resolve(true);
        req.onerror = (e) => {
          console.warn("saveStory failed (fail-soft):", e.target.error);
          resolve(false);
        };
        tx.onabort = () => resolve(false);
        tx.onerror = () => resolve(false);
      } catch (e) {
        console.warn("saveStory threw (fail-soft):", e);
        resolve(false);
      }
    });
  },

  /**
   * Retrieves a single story by its ID.
   * @param {string} storyId
   * @returns {Promise<object|null>} The story object or null.
   */
  async getStory(storyId) {
    if (!(await this.ensure())) return null;
    return new Promise((resolve) => {
      try {
        const tx = this.db.transaction(["stories"], "readonly");
        const store = tx.objectStore("stories");
        const req = store.get(storyId);
        req.onsuccess = () => resolve(req.result ?? null);
        req.onerror = () => resolve(null);
        tx.onabort = () => resolve(null);
        tx.onerror = () => resolve(null);
      } catch (e) {
        console.warn("getStory threw (fail-soft):", e);
        resolve(null);
      }
    });
  },

  /**
   * Retrieves ALL stories from the 'stories' store.
   * This is for the main library view.
   * @returns {Promise<Array<object>>} An array of story objects.
   */
  async getAllStories() {
    if (!(await this.ensure())) return [];
    return new Promise((resolve) => {
      try {
        const tx = this.db.transaction(["stories"], "readonly");
        const store = tx.objectStore("stories");
        const req = store.getAll(); // Efficiently gets all records
        req.onsuccess = () => resolve(req.result ?? []);
        req.onerror = () => resolve([]);
        tx.onabort = () => resolve([]);
        tx.onerror = () => resolve([]);
      } catch (e) {
        console.warn("getAllStories threw (fail-soft):", e);
        resolve([]);
      }
    });
  },

  /**
   * Deletes a single story by its ID.
   * @param {string} storyId
   * @returns {Promise<boolean>} True on success.
   */
  async deleteStory(storyId) {
    if (!(await this.ensure())) return false;
    return new Promise((resolve) => {
      try {
        const tx = this.db.transaction(["stories"], "readwrite");
        const store = tx.objectStore("stories");
        const req = store.delete(storyId);
        req.onsuccess = () => resolve(true);
        req.onerror = () => resolve(false);
        tx.onabort = () => resolve(false);
        tx.onerror = () => resolve(false);
      } catch (e) {
        console.warn("deleteStory threw (fail-soft):", e);
        resolve(false);
      }
    });
  },

  /**
   * Saves or updates a single narrative object in the 'narratives' store.
   * @param {object} narrative - The narrative object (with chat history).
   * @returns {Promise<boolean>} True on success.
   */
  async saveNarrative(narrative) {
    if (!(await this.ensure())) return false;
    return new Promise((resolve) => {
      try {
        const tx = this.db.transaction(["narratives"], "readwrite");
        const store = tx.objectStore("narratives");
        const req = store.put(narrative);
        req.onsuccess = () => resolve(true);
        req.onerror = () => resolve(false);
        tx.onabort = () => resolve(false);
        tx.onerror = () => resolve(false);
      } catch (e) {
        console.warn("saveNarrative threw (fail-soft):", e);
        resolve(false);
      }
    });
  },

  /**
   * Retrieves a single narrative by its ID.
   * @param {string} narrativeId
   * @returns {Promise<object|null>} The narrative object or null.
   */
  async getNarrative(narrativeId) {
    if (!(await this.ensure())) return null;
    return new Promise((resolve) => {
      try {
        const tx = this.db.transaction(["narratives"], "readonly");
        const store = tx.objectStore("narratives");
        const req = store.get(narrativeId);
        req.onsuccess = () => resolve(req.result ?? null);
        req.onerror = () => resolve(null);
        tx.onabort = () => resolve(null);
        tx.onerror = () => resolve(null);
      } catch (e) {
        console.warn("getNarrative threw (fail-soft):", e);
        resolve(null);
      }
    });
  },

  /**
   * Retrieves ALL narratives from the 'narratives' store.
   * @returns {Promise<Array<object>>} An array of narrative objects.
   */
  async getAllNarratives() {
    if (!(await this.ensure())) return [];
    return new Promise((resolve) => {
      try {
        const tx = this.db.transaction(["narratives"], "readonly");
        const store = tx.objectStore("narratives");
        const req = store.getAll();
        req.onsuccess = () => resolve(req.result ?? []);
        req.onerror = () => resolve([]);
        tx.onabort = () => resolve([]);
        tx.onerror = () => resolve([]);
      } catch (e) {
        console.warn("getAllNarratives threw (fail-soft):", e);
        resolve([]);
      }
    });
  },

  /**
   * Deletes a single narrative by its ID.
   * @param {string} narrativeId
   * @returns {Promise<boolean>} True on success.
   */
  async deleteNarrative(narrativeId) {
    if (!(await this.ensure())) return false;
    return new Promise((resolve) => {
      try {
        const tx = this.db.transaction(["narratives"], "readwrite");
        const store = tx.objectStore("narratives");
        const req = store.delete(narrativeId);
        req.onsuccess = () => resolve(true);
        req.onerror = () => resolve(false);
        tx.onabort = () => resolve(false);
        tx.onerror = () => resolve(false);
      } catch (e) {
        console.warn("deleteNarrative threw (fail-soft):", e);
        resolve(false);
      }
    });
  },
  
  

  /**
   * A generic helper to get all [key, value] pairs from any store.
   * We will use this to export all images.
   * @param {string} storeName - The name of the object store.
   * @returns {Promise<Array<[string, any]>>} An array of [key, value] tuples.
   */
  async getAllEntries(storeName) {
    if (!(await this.ensure())) return [];
    return new Promise((resolve) => {
      try {
        const tx = this.db.transaction([storeName], "readonly");
        const store = tx.objectStore(storeName);
        const entries = [];
        const req = store.openCursor();
        
        req.onsuccess = (event) => {
          const cursor = event.target.result;
          if (cursor) {
            entries.push([cursor.key, cursor.value]);
            cursor.continue();
          } else {
            resolve(entries);
          }
        };
        req.onerror = () => resolve([]);
        tx.onabort = () => resolve([]);
        tx.onerror = () => resolve([]);
      } catch (e) {
        console.warn(`getAllEntries (${storeName}) threw (fail-soft):`, e);
        resolve([]);
      }
    });
  },

  /**
   * Clears all data from a specific object store.
   * We will use this for a clean import.
   * @param {string} storeName - The name of the object store to clear.
   * @returns {Promise<boolean>} True on success.
   */
  async clearStore(storeName) {
    if (!(await this.ensure())) return false;
    return new Promise((resolve) => {
      try {
        const tx = this.db.transaction([storeName], "readwrite");
        const store = tx.objectStore(storeName);
        const req = store.clear();
        req.onsuccess = () => resolve(true);
        req.onerror = () => resolve(false);
        tx.onabort = () => resolve(false);
        tx.onerror = () => resolve(false);
      } catch (e) {
        console.warn(`clearStore (${storeName}) threw (fail-soft):`, e);
        resolve(false);
      }
    });
  }
};

/**
 * =================================================================================================
 * [NEW] StoryService Module (The Data Abstraction Layer)
 * =================================================================================================
 * This module is the single source of truth for all complex data orchestration.
 * The Controller calls this service, and this service calls DBService.
 * This keeps all database logic in one place and out of the Controller.
 */
const StoryService = {

    /**
     * Loads the full data needed to start the application.
     * Fetches all story stubs for the library AND the full data for the active session.
     * @returns {Promise<object>} An object containing { storyStubs, activeStory, activeNarrative }
     */
    async loadApplicationData() {
        console.log("StoryService: Loading application data...");
        // 1. Get the list of story stubs for the library view
        const storyStubs = await DBService.getAllStories();
        
        // 2. Get the active session IDs from localStorage
        const activeStoryId = localStorage.getItem('active_story_id');
        const activeNarrativeId = localStorage.getItem('active_narrative_id');
        
        let activeStory = null;
        let activeNarrative = null;

        // 3. If there is an active session, fetch the FULL data for it
        if (activeStoryId && activeNarrativeId) {
            console.log(`StoryService: Found active session. Story: ${activeStoryId}, Narrative: ${activeNarrativeId}`);
            // We get these in parallel for speed
            const storyPromise = DBService.getStory(activeStoryId);
            const narrativePromise = DBService.getNarrative(activeNarrativeId);
            
            const [story, narrative] = await Promise.all([storyPromise, narrativePromise]);
            
            if (story && narrative) {
                activeStory = story;
                activeNarrative = narrative;
            } else {
                // Data mismatch (e.g., story exists but narrative was deleted)
                // Clear the bad IDs to prevent a broken state
                console.warn("StoryService: Active session data mismatch. Clearing active IDs.");
                localStorage.removeItem('active_story_id');
                localStorage.removeItem('active_narrative_id');
            }
        } else {
            console.log("StoryService: No active session found.");
        }
        
        return { storyStubs, activeStory, activeNarrative };
    },

    /**
     * Saves the entire active state by splitting it into its
     * respective database tables ('stories' and 'narratives').
     * @param {object} currentState - The full activeNarrativeState object from StateManager.
     * @param {Array<object>} narrativeStubs - The current list of stubs for this story.
     */
/**
     * Saves the entire active state by splitting it into Story (Metadata + Characters)
     * and Narrative (Chat + Active Status).
     */
    async saveActiveState(currentState, narrativeStubs) {
        if (!currentState || !currentState.id || !currentState.narrativeId) {
            console.warn("StoryService: saveActiveState skipped (invalid state).");
            return; 
        }

        // 1. Extract Active Character IDs for the Narrative
        // The narrative only cares *who* is here, not *what* they look like.
        const activeCharacterIds = (currentState.characters || [])
            .filter(c => c.is_active)
            .map(c => c.id);

        // 2. Create the 'story' object
        // This holds the MASTER LIST of character definitions.
        const storyData = {
            id: currentState.id,
            name: currentState.name,
            last_modified: new Date().toISOString(),
            created_date: currentState.created_date,
            creator_notes: currentState.creator_notes,
            tags: currentState.tags,
            // UI settings & Prompts
            font: currentState.font,
            backgroundImageURL: currentState.backgroundImageURL,
            bubbleOpacity: currentState.bubbleOpacity,
            chatTextColor: currentState.chatTextColor,
            characterImageMode: currentState.characterImageMode,
            backgroundBlur: currentState.backgroundBlur,
            textSize: currentState.textSize,
            bubbleImageSize: currentState.bubbleImageSize,
            system_prompt: currentState.system_prompt,
            event_master_base_prompt: currentState.event_master_base_prompt,
            event_master_prompt: currentState.event_master_prompt, 
            prompt_persona_gen: currentState.prompt_persona_gen,
            prompt_world_map_gen: currentState.prompt_world_map_gen,
            prompt_location_gen: currentState.prompt_location_gen,
            prompt_entry_gen: currentState.prompt_entry_gen,
            prompt_location_memory_gen: currentState.prompt_location_memory_gen,
            // Data
            characters: currentState.characters, // Save full definitions here
            dynamic_entries: currentState.dynamic_entries,
            scenarios: currentState.scenarios,
            narratives: narrativeStubs || []
        };

        // 3. Create the 'narrative' object
        const narrativeData = {
            id: currentState.narrativeId,
            name: currentState.narrativeName,
            last_modified: new Date().toISOString(),
            // NEW: Store the list of IDs that are active in this specific narrative
            active_character_ids: activeCharacterIds, 
            state: {
                chat_history: currentState.chat_history,
                messageCounter: currentState.messageCounter,
                static_entries: currentState.static_entries,
                worldMap: currentState.worldMap
            }
        };

        // 4. Save both
        await Promise.all([
            DBService.saveStory(storyData),
            DBService.saveNarrative(narrativeData)
        ]);
    },

    /**
     * Creates the very first story and narrative for a new user.
     * @returns {Promise<object>} { newStory, newNarrative }
     */
    async createDefaultStoryAndNarrative() {
        // 1. Create the Story object (metadata)
        const newStory = {
            id: UTILITY.uuid(), name: "My First Story", last_modified: new Date().toISOString(), created_date: new Date().toISOString(),
            ...UTILITY.getDefaultApiSettings(), ...UTILITY.getDefaultUiSettings(), ...UTILITY.getDefaultSystemPrompts(), ...UTILITY.getDefaultStorySettings(),
            characters: [
                { id: UTILITY.uuid(), name: "You", description: "The protagonist.", short_description: "The main character.", model_instructions: "Write a response for {character} in a creative and descriptive style.", is_user: true, is_active: true, image_url: '', extra_portraits: [], tags:[], is_narrator: false }, 
                { id: UTILITY.uuid(), name: "Narrator", description: "Describes the world.", short_description: "The storyteller.", model_instructions: "Act as a world-class storyteller.", is_user: false, is_active: true, image_url: '', extra_portraits: [], tags:[], color: { base: '#334155', bold: '#94a3b8' }, is_narrator: true }
            ], 
            dynamic_entries: [{id: UTILITY.uuid(), title: "Example Lorebook Entry", triggers: "example, .01%", content_fields: ["This is a sample dynamic lore entry."], current_index: 0, triggered_at_turn: null }],
            scenarios: [{ id: UTILITY.uuid(), name: "Default Start", message: "The story begins..." }],
            narratives: [] // This will be populated with a stub
        };
        
        // 2. Create the Narrative object (heavy data)
        const defaultScenario = newStory.scenarios[0];
        const newNarrative = {
            id: UTILITY.uuid(), name: `${defaultScenario.name} - Chat`, last_modified: new Date().toISOString(),
            state: {
                chat_history: [], messageCounter: 0,
                static_entries: [{ id: UTILITY.uuid(), title: "World Overview", content: "A high-fantasy world." }],
                worldMap: { grid: UTILITY.createDefaultMapGrid(), currentLocation: { x: 4, y: 4 }, destination: { x: null, y: null }, path: [] }
            }
        };
        
        // 3. Add first message to narrative
        const firstSpeaker = newStory.characters.find(c => !c.is_user);
        newNarrative.state.chat_history.push({
            character_id: firstSpeaker.id, content: defaultScenario.message, type: 'chat', emotion: 'neutral', timestamp: new Date().toISOString(),
        });
        newNarrative.state.messageCounter = 1;

        // 4. Add the narrative stub to the story's list
        newStory.narratives.push({ id: newNarrative.id, name: newNarrative.name });

        // 5. Save both to IndexedDB
        await DBService.saveStory(newStory);
        await DBService.saveNarrative(newNarrative);
        
        // 6. Return the new objects
        return { newStory, newNarrative };
    },

    /**
     * Creates a new, blank story and saves it to the database.
     * @returns {Promise<object>} The new story object (stub).
     */
    async createNewStory() {
        const newStory = {
            id: UTILITY.uuid(), name: "New Story", last_modified: new Date().toISOString(), created_date: new Date().toISOString(),
            ...UTILITY.getDefaultApiSettings(), ...UTILITY.getDefaultUiSettings(), ...UTILITY.getDefaultSystemPrompts(), ...UTILITY.getDefaultStorySettings(),
            search_index: "new story",
            characters: [
                { id: UTILITY.uuid(), name: "You", description: "The protagonist.", short_description: "The main character.", model_instructions: "Write a response for {character} in a creative and descriptive style.", is_user: true, is_active: true, image_url: '', extra_portraits: [], tags:[], is_narrator: false }, 
                { id: UTILITY.uuid(), name: "Narrator", description: "Describes the world.", short_description: "The storyteller.", model_instructions: "Act as a world-class storyteller.", is_user: false, is_active: true, image_url: '', extra_portraits: [], tags:[], color: { base: '#334155', bold: '#94a3b8' }, is_narrator: true }
            ], 
            dynamic_entries: [{id: UTILITY.uuid(), title: "Example Lorebook Entry", triggers: "example, 100%", content_fields: ["This is a sample dynamic lore entry."], current_index: 0, triggered_at_turn: null }],
            scenarios: [{ id: UTILITY.uuid(), name: "Default Start", message: "The story begins..." }],
            narratives: [] // No narratives created by default
        };
        
        await DBService.saveStory(newStory);
        return newStory;
    },

    /**
     * Deletes a story and ALL its associated data (narratives, images).
     * This is the orchestration logic.
     * @param {string} storyId - The ID of the story to delete.
     */
    async deleteStory(storyId) {
        // 1. Get the story object to find its children
        const story = await DBService.getStory(storyId);
        if (!story) return; // Story already deleted

        // 2. Delete all associated Narratives
        const deleteNarrativePromises = (story.narratives || []).map(n_stub => 
            DBService.deleteNarrative(n_stub.id)
        );
        
        // 3. Delete all associated Images
        const deleteImagePromises = (story.characters || []).map(c => {
            // Delete base image
            const baseDelete = DBService.deleteImage(c.id);
            // Delete all emotion images
            const emotionDeletes = (c.extra_portraits || []).map(p => {
                const emoKey = `${c.id}::emotion::${p.emotion}`;
                return DBService.deleteImage(emoKey);
            });
            return Promise.all([baseDelete, ...emotionDeletes]);
        });
        
        // TODO: Also delete "locationImages" if you implement that

        // 4. Wait for all children to be deleted
        await Promise.all([...deleteNarrativePromises, ...deleteImagePromises]);

        // 5. Delete the Story itself
        await DBService.deleteStory(storyId);
    },

    /**
     * Deletes just one narrative from the database and updates its parent story.
     * @param {string} storyId - The parent story ID.
     * @param {string} narrativeId - The narrative to delete.
     * @returns {Promise<object>} The updated story object.
     */
    async deleteNarrative(storyId, narrativeId) {
        // 1. Get the parent story
        const story = await DBService.getStory(storyId);
        if (!story) throw new Error("Parent story not found.");

        // 2. Delete the narrative itself from its store
        await DBService.deleteNarrative(narrativeId);
        
        // 3. Update the parent story's list of narrative stubs
        story.narratives = story.narratives.filter(n => n.id !== narrativeId);
        
        // 4. Save the updated story
        await DBService.saveStory(story);
        return story; // Return the updated story
    },

    /**
     * Creates a new narrative from a scenario and saves all data.
     * @param {string} storyId
     * @param {string} scenarioId
     * @returns {Promise<object>} The newly created (and saved) narrative object.
     */
/**
     * Creates a new narrative and RESTORES the Story State from a scenario snapshot.
     */
    async createNarrativeFromScenario(storyId, scenarioId) {
        // 1. Get the full story
        const story = await DBService.getStory(storyId);
        if (!story) throw new Error("Story not found");
        
        // 2. Find the scenario to use as a template
        const scenario = story.scenarios.find(sc => sc.id === scenarioId);
        if (!scenario) throw new Error("Scenario not found");

        // --- RESTORE STORY-LEVEL DATA ---
        // If the scenario has snapshot data, we overwrite the current Story settings
        // with the data preserved in the scenario.
		if (scenario.dynamic_entries) story.dynamic_entries = JSON.parse(JSON.stringify(scenario.dynamic_entries));
        if (scenario.prompts) Object.assign(story, scenario.prompts);
		
		// Determine Active IDs from Scenario
        // If the scenario has a specific list, use it. Otherwise, default to all.
        const activeIDs = scenario.active_character_ids || story.characters.map(c => c.id);
		
        // 3. Create the new full narrative object
		const newNarrative = {
            id: UTILITY.uuid(),
            name: `${scenario.name} - Chat`,
            last_modified: new Date().toISOString(),
            // --- Save the active IDs ---
            active_character_ids: activeIDs,
            state: {
                chat_history: [],
                messageCounter: 0,
                static_entries: scenario.static_entries ? JSON.parse(JSON.stringify(scenario.static_entries)) : [{ id: UTILITY.uuid(), title: "World Overview", content: "A high-fantasy world." }],
                worldMap: scenario.worldMap ? JSON.parse(JSON.stringify(scenario.worldMap)) : { grid: UTILITY.createDefaultMapGrid(), currentLocation: { x: 4, y: 4 }, destination: { x: null, y: null }, path: [] }
            }
        };

        // 4. Inject Example Dialogue
        if (scenario.example_dialogue && Array.isArray(scenario.example_dialogue)) {
            newNarrative.state.chat_history.push(...JSON.parse(JSON.stringify(scenario.example_dialogue)));
        }

        // 5. Add the first visible message
        const firstMessage = scenario.message;
        if (firstMessage) {
            const firstSpeaker = story.characters.find(c => !c.is_user && c.is_active);
            if (firstSpeaker) {
                newNarrative.state.chat_history.push({
                    character_id: firstSpeaker.id, content: firstMessage, type: 'chat',
                    emotion: 'neutral', timestamp: new Date().toISOString(), isNew: true
                });
                newNarrative.state.messageCounter = 1;
            }
        }
        
        // 6. Save the new narrative
        await DBService.saveNarrative(newNarrative);
        
        // 7. Add the stub AND Save the UPDATED Story (with restored settings)
        story.narratives.push({ id: newNarrative.id, name: newNarrative.name });
        await DBService.saveStory(story);
        
        return newNarrative;
    },

    /**
     * Updates a single field on a story object (e.g., name, tags).
     * @param {string} storyId
     * @param {string} field - The key to update (e.g., 'name', 'creator_notes')
     * @param {*} value - The new value.
     * @returns {Promise<object>} The updated story object.
     */
    async updateStoryField(storyId, field, value) {
        // 1. Get the full story object
        const story = await DBService.getStory(storyId);
        if (!story) throw new Error("Story not found.");

        // 2. Update the field
        story[field] = value;
        story.last_modified = new Date().toISOString();
        
        // 3. Save the updated story back to the DB
        await DBService.saveStory(story);
        return story;
    },

    /**
     * Exports the entire library (all stories, narratives, and images)
     * from IndexedDB into a single ZIP file.
     * @returns {Promise<Blob>} A promise that resolves with the ZIP blob.
     */
    async exportLibraryAsZip() {
        console.log("StoryService: Starting library export...");
        const zip = new JSZip();
        
        // 1. Create folders in the zip
        const dataFolder = zip.folder("data");
        const imageFolder = zip.folder("images");

        // 2. Get all data from IndexedDB
        const stories = await DBService.getAllStories();
        const narratives = await DBService.getAllNarratives();
        const images = await DBService.getAllEntries("characterImages"); 
        // TODO: Also get "locationImages" from their store if you add one
        // const locationImages = await DBService.getAllEntries("locationImages");

        // 3. Add JSON data to the zip
        dataFolder.file("stories.json", JSON.stringify(stories, null, 2));
        dataFolder.file("narratives.json", JSON.stringify(narratives, null, 2));
        
        // 4. Add all images to the zip
        if (images.length > 0) {
          images.forEach(([key, blob]) => {
            // The key (e.g., character ID) becomes the filename
            imageFolder.file(key, blob);
          });
        }
        // if (locationImages.length > 0) { ... }

        console.log(`StoryService: Exporting ${stories.length} stories, ${narratives.length} narratives, and ${images.length} images.`);

        // 5. Generate the final ZIP blob
        return zip.generateAsync({
          type: "blob",
          compression: "DEFLATE",
          compressionOptions: {
            level: 6 // A good balance of speed and size
          }
        });
    },

    /**
     * Imports a library from a ZIP file, completely replacing the
     * existing library in IndexedDB.
     * @param {File} file - The .zip file to import.
     * @returns {Promise<void>}
     */
    async importLibraryFromZip(file) {
        console.log("StoryService: Starting library import from ZIP...");
        
        // 1. Load the ZIP file
        const zip = await JSZip.loadAsync(file);

        // 2. Clear all existing data from the database
        // We run these in parallel for speed
        await Promise.all([
          DBService.clearStore("stories"),
          DBService.clearStore("narratives"),
          DBService.clearStore("characterImages")
          // TODO: Also clear "locationImages"
        ]);
        console.log("StoryService: Existing database cleared.");

        // 3. Import JSON data
        // --- Import Stories ---
        const storiesFile = zip.file("data/stories.json");
        if (storiesFile) {
          const stories = JSON.parse(await storiesFile.async("string"));
          // Save each story one by one. Promise.all is fastest.
          await Promise.all(stories.map(story => DBService.saveStory(story)));
          console.log(`StoryService: Imported ${stories.length} stories.`);
        }

        // --- Import Narratives ---
        const narrativesFile = zip.file("data/narratives.json");
        if (narrativesFile) {
          const narratives = JSON.parse(await narrativesFile.async("string"));
          await Promise.all(narratives.map(narrative => DBService.saveNarrative(narrative)));
          console.log(`StoryService: Imported ${narratives.length} narratives.`);
        }

        // 4. Import Images
        const imageFolder = zip.folder("images");
        if (imageFolder) {
          const imageFiles = [];
          imageFolder.forEach((relativePath, file) => {
            // relativePath is the filename (e.g., character ID)
            imageFiles.push({ key: relativePath, file: file });
          });

          // Process them all in parallel
          await Promise.all(imageFiles.map(async (img) => {
            const blob = await img.file.async("blob");
            // The key is the filename, which is our ID
            await DBService.saveImage(img.key, blob);
          }));
          console.log(`StoryService: Imported ${imageFiles.length} images.`);
        }
        
        console.log("StoryService: Library import complete.");
    },

    /**
     * Builds a context string for a story, fetching data as needed.
     * This is used by AI generation functions.
     * @param {string} storyId
     * @returns {Promise<string>} The context string.
     */
    async buildStoryContext(storyId) {
        // 1. Get the full story object
        const story = await DBService.getStory(storyId);
        if (!story) return "No story found.";

        let context = `Story Name: ${story.name}\n`;
        context += `Creator's Note: ${story.creator_notes || 'N/A'}\n`;

        // 2. Add character data
        context += "Characters:\n";
        (story.characters || []).forEach(c => {
            context += `- ${c.name}: ${c.short_description}\n`;
        });
        
        // 3. Get sample lore from the *first narrative*
        if (story.narratives && story.narratives.length > 0) {
            // Fetch the full narrative object from its store
            const firstNarrative = await DBService.getNarrative(story.narratives[0].id);
            if (firstNarrative && firstNarrative.state) {
                context += "\nWorld Lore (Sample):\n";
                (firstNarrative.state.static_entries || []).slice(0, 5).forEach(e => {
                    context += `- ${e.title}: ${e.content.substring(0, 100)}...\n`;
                });
            }
        }
        
        // 4. Add dynamic lore
        if (story.dynamic_entries && story.dynamic_entries.length > 0) {
            context += "\nDynamic Lore (Sample):\n";
            story.dynamic_entries.slice(0, 5).forEach(e => {
                context += `- ${e.title} (Triggers: ${e.triggers})\n`;
            });
        }
        return context;
    },

    /**
     * Runs the silent static update agent.
     * @param {string} narrativeId - The active narrative to scan.
     * @param {Array<object>} existingStaticEntries - The current list of static entries.
     * @param {Array<object>} characters - The list of characters.
     * @returns {Promise<number>} The number of new entries added.
     */
    async runSilentStaticUpdate(narrativeId, existingStaticEntries, characters) {
        // 1. Get the full narrative data
        const narrative = await DBService.getNarrative(narrativeId);
        if (!narrative || !narrative.state) {
            console.warn("Silent update skipped: No active narrative data.");
            return 0;
        }

        // 2. Get last 20 messages (approx 10 user turns)
        const recentChat = (narrative.state.chat_history || [])
            .filter(m => m.type === 'chat')
            .slice(-20);

        if (recentChat.length < 1) {
            console.log("Silent update skipped: No recent chat.");
            return 0;
        }

        // 3. Build the transcript
        let chatTranscript = "";
        recentChat.forEach(msg => {
            const c = (characters || []).find(i => i.id === msg.character_id);
            if (c) chatTranscript += `${c.name}: ${msg.content}\n`;
        });

        // 4. Build the prompt
        const prompt = `
You are an AI Archivist. Your job is to read a chat transcript and identify NEW facts, character developments, or world-building details that are NOT already covered in the existing static knowledge.
Respond with a valid JSON object: { "new_entries": [{"title": "A concise title", "content": "A detailed paragraph summarizing the new fact."}] } or { "new_entries": [] } if nothing new was established.

EXISTING STATIC KNOWLEDGE (Do NOT repeat info from here):
${JSON.stringify(existingStaticEntries.map(e => e.title))}

CHAT TRANSCRIPT:
${chatTranscript}

Respond with JSON:
`;
        // 5. Call the AI
        const updatesJson = await APIService.callAI(prompt, true);
        const updates = JSON.parse(updatesJson);

        // 6. Process the results
        if (updates.new_entries && updates.new_entries.length > 0) {
            let addedCount = 0;
            updates.new_entries.forEach(item => {
                // Check for duplicates
                if (item.title && !existingStaticEntries.some(e => e.title.toLowerCase() === item.title.toLowerCase())) {
                    existingStaticEntries.push({ id: UTILITY.uuid(), ...item });
                    addedCount++;
                }
            });
            // The calling function (Controller) is responsible for saving the state
            return addedCount;
        }
        return 0; // No new entries
    },

}; // <-- This is the final closing brace for StoryService	



/**
 * =================================================================================================
 * StateManager Module
 * =================================================================================================
 * This module is the single source of truth for all application data.
 * It handles loading from and saving to localStorage, and provides controlled access
 * to the library and the active narrative state. All data mutations should happen
 * through this manager's methods to ensure consistency.
 */
const StateManager = {
    // Private data store. Should not be accessed directly from outside this module.
data: {
        library: {
            active_story_id: null,
            active_narrative_id: null,
            stories: [],
            tag_cache: []
        },
        globalSettings: {},
        // This holds the state of the *currently active* narrative.
        // It's a combination of story-level settings and narrative-specific data.
        activeNarrativeState: {},
    },

    CONSTANTS: {
		GLOBAL_SETTINGS_KEY: 'aiStorytellerGlobalSettings',
		ACTIVE_STORY_ID_KEY: 'active_story_id',
        ACTIVE_NARRATIVE_ID_KEY: 'active_narrative_id',
    },

/**
     * Loads the global app settings (like API keys) from localStorage.
     */
    loadGlobalSettings() {
        let parsedSettings = {};
        const defaults = UTILITY.getDefaultApiSettings();
        try {
            const savedSettingsJSON = localStorage.getItem(this.CONSTANTS.GLOBAL_SETTINGS_KEY);
            if (savedSettingsJSON) {
                parsedSettings = JSON.parse(savedSettingsJSON);
            }
        } catch (error) {
            console.error("Failed to parse global settings, using defaults.", error);
            parsedSettings = {};
        }
        
        // Merge defaults to ensure all keys exist
        this.data.globalSettings = { ...defaults, ...parsedSettings };
        // Note: You could add a one-time migration here to pull settings 
        // from the user's most recent story if parsedSettings is empty.
    },
    
    /**
     * Persists the global app settings to localStorage.
     */
    saveGlobalSettings() {
        localStorage.setItem(this.CONSTANTS.GLOBAL_SETTINGS_KEY, JSON.stringify(this.data.globalSettings));
    },

    // --- Public Getters ---
    // Provide read-only access to the state from other parts of the application.
    
    /** @returns {object} The active narrative state object. */
    getState() {
        return this.data.activeNarrativeState;
    },

    /** @returns {object} The entire story library object. */
    getLibrary() {
        return this.data.library;
    },

    // --- State Initialization and Persistence ---
    
    /**
     * Loads the entire story library from localStorage into the state manager.
     * Performs data migration for older story formats to ensure compatibility.
     * This is the first step in the application's data lifecycle.
     */
	async loadLibrary() {
        // 1. Load non-story global settings (e.g., API keys)
        this.loadGlobalSettings();

        try {
            // 2. Call the StoryService to get all data
            const { storyStubs, activeStory, activeNarrative } = await StoryService.loadApplicationData();

            // 3. Populate the in-memory library with story stubs
            this.data.library.stories = storyStubs || [];
            this.data.library.active_story_id = activeStory ? activeStory.id : null;
            this.data.library.active_narrative_id = activeNarrative ? activeNarrative.id : null;

			// 4. Populate the activeNarrativeState if data was returned
            if (activeStory && activeNarrative) {
                // hydrate Character Active State
                
                // 1. Get the list of active IDs.
                // If the list is undefined/null (old narrative), we'll use a fallback.
                const idList = activeNarrative.active_character_ids;

                // 2. Create the Set of active IDs.
                // IF idList is null/undefined (old narrative): default to ALL characters in the story being active.
                // ELSE (new narrative): use the specific list from the narrative.
                const activeIDs = (idList === null || idList === undefined)
                    ? new Set((activeStory.characters || []).map(c => c.id)) // <--- MIGRATION FIX: Default to all active
                    : new Set(idList);                                        // <--- STANDARD: Use saved list
                
                // 2. Map over story characters and set is_active flag
                const hydratedCharacters = (activeStory.characters || []).map(char => ({
                    ...char,
                    // It is active IF it's in the narrative's list
                    // Exception: The User character is ALWAYS active
                    is_active: char.is_user || activeIDs.has(char.id) // <--- This logic now works
                }));
				this.data.activeNarrativeState = {
                    ...activeStory,                // Story settings
                    ...this.data.globalSettings,   // Global settings
                    ...activeNarrative.state,      // Narrative state (chat history, etc)
                    characters: hydratedCharacters,
					narrativeId: activeNarrative.id, // <-- Store the narrative ID
                    narrativeName: activeNarrative.name
                };

                // [MIGRATION] Keep your existing migration check
                // any loaded narrative has a valid world map.
                if (!this.data.activeNarrativeState.worldMap || !this.data.activeNarrativeState.worldMap.grid || this.data.activeNarrativeState.worldMap.grid.length === 0) {
                     this.data.activeNarrativeState.worldMap = { 
                        grid: UTILITY.createDefaultMapGrid(), 
                        currentLocation: { x: 4, y: 4 }, 
                        destination: { x: null, y: null }, 
                        path: [] 
                    };
                }
            } else {
                this.data.activeNarrativeState = {};
            }
        } catch (error) {
            console.error("Failed to load application data.", error);
            this.data.library = { stories: [], tag_cache: [] };
            this.data.activeNarrativeState = {};
        }
		
		// 5. Rebuild tag cache (this logic is fine, just remove save)
        this.updateTagCache(); 
    },
    
    /**
     * Persists the *active session IDs* to localStorage.
     * The full state is saved via saveState().
     */
    saveLibrary() {
        try {
            // This function now ONLY saves the active session IDs
            localStorage.setItem(this.CONSTANTS.ACTIVE_STORY_ID_KEY, this.data.library.active_story_id);
            localStorage.setItem(this.CONSTANTS.ACTIVE_NARRATIVE_ID_KEY, this.data.library.active_narrative_id);
        } catch (e) {
            console.error("Failed to save active session IDs to localStorage.", e);
        }
    },
    
    /**
     * Loads the active narrative. This is now just a helper
     * to set the active IDs and reload the page.
     */
    loadActiveNarrative() {
        // The *actual* loading happens in loadLibrary() on page init.
        // This function's job is to set the IDs and trigger that reload.
        const { active_story_id, active_narrative_id } = this.data.library;
        
        if (!active_story_id || !active_narrative_id) {
            this.data.activeNarrativeState = {};
            return;
        }
        
        // This is the only part that's still relevant
        localStorage.setItem(this.CONSTANTS.ACTIVE_STORY_ID_KEY, active_story_id);
        localStorage.setItem(this.CONSTANTS.ACTIVE_NARRATIVE_ID_KEY, active_narrative_id);
    },

    /**
     * Saves the `activeNarrativeState` back into IndexedDB via the StoryService.
     */
    async saveState() {
        const { active_story_id, active_narrative_id, stories } = this.data.library;
        const currentState = this.data.activeNarrativeState;

        if (!active_story_id || !active_narrative_id || !currentState) {
            console.warn("Attempted to save state without an active story/narrative.");
            return;
        }

        try {
            // Find the narrative stubs for the current story
            const storyStubs = (stories.find(s => s.id === active_story_id) || {}).narratives || [];
            
            // Pass the full state and the stubs to the service
            await StoryService.saveActiveState(currentState, storyStubs);

            // Update the in-memory library list's last_modified date
            const storyInLibrary = this.data.library.stories.find(s => s.id === active_story_id);
            if (storyInLibrary) {
                storyInLibrary.last_modified = new Date().toISOString();
            }

        } catch (e) {
            console.error("Failed to save state via StoryService:", e);
        }
    },

    /**
     * Scans all stories and characters to build a unique, sorted list of all tags.
     */
/**
     * Scans all stories and characters to build a unique, sorted list of all tags.
     * [UPDATED] Normalizes to lowercase to combine duplicates.
     */
    updateTagCache() {
        const allTags = new Set();
        this.data.library.stories.forEach(story => {
            if (story.tags) story.tags.forEach(tag => allTags.add(tag.toLowerCase()));
            // We can still scan characters, as they are part of the story stub
            if (story.characters) {
                story.characters.forEach(char => {
                    if (char.tags) char.tags.forEach(tag => allTags.add(tag.toLowerCase()));
                });
            }
        });
        this.data.library.tag_cache = Array.from(allTags).sort();
    },
};

/**
 * =================================================================================================
 * APIService Module
 * =================================================================================================
 */
const APIService = {
    /**
     * Calls the configured AI provider with a given prompt.
     * @param {string} prompt - The prompt to send to the AI.
     * @param {boolean} [isJson=false] - Whether to expect a JSON response.
     * @param {AbortSignal|null} [signal=null] - An AbortSignal to cancel the request.
     * @returns {Promise<string>} The AI's response text.
     */
    async callAI(prompt, isJson = false, signal = null) {
        const state = StateManager.getState();
        let text = "";
        try {
            if (state.apiProvider === 'gemini') {
                text = await this.callGemini(prompt, signal);
            } else if (state.apiProvider === 'openrouter') {
                text = await this.callOpenRouter(prompt, signal);
            } else if (state.apiProvider === 'koboldcpp') {
                text = await this.callKoboldCPP(prompt, signal);
            } else if (state.apiProvider === 'lmstudio') {
                text = await this.callLMStudio(prompt, signal);
            }

            if (isJson) {
                const jsonMatch = text.match(/\{[\s\S]*\}/);
                if (jsonMatch && jsonMatch[0]) {
                    return jsonMatch[0];
                }
                console.error("AI did not return valid JSON for a JSON-expected call. Response:", text);
                throw new Error("AI response was not in the expected JSON format.");
            }
            return text.trim();
        } catch (error) {
            // Don't re-throw abort errors, as they are intentional.
            if (error.name === 'AbortError') {
                console.log("Fetch aborted by user.");
                throw error; // Re-throw to be caught by the controller
            }
            console.error(`AI call failed for provider ${state.apiProvider}:`, error);
            throw error;
        }
    },
    async callGemini(prompt, signal) {
        const state = StateManager.getState();
        if (!state.geminiApiKey) throw new Error("Gemini API key not set.");
        const res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${state.geminiApiKey}`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] }), signal });
        if (!res.ok) { let errorDetails = `Status: ${res.status} ${res.statusText}.`; try { errorDetails += ` Message: ${(await res.json()).error.message}`; } catch (e) { errorDetails += ` Response body: ${await res.text()}`; } throw new Error(`API Error: ${errorDetails}`); }
        const data = await res.json();
        return data.candidates?.[0]?.content?.parts?.[0]?.text || "";
    },
    async callOpenRouter(prompt, signal) {
        const state = StateManager.getState();
        if (!state.openRouterKey || !state.openRouterModel) throw new Error("OpenRouter API key or model not set.");
        const res = await fetch('https://openrouter.ai/api/v1/chat/completions', { method: 'POST', headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${state.openRouterKey}`}, body: JSON.stringify({ model: state.openRouterModel, messages: [{ role: 'user', content: prompt }] }), signal });
        if (!res.ok) { let errorDetails = `Status: ${res.status} ${res.statusText}.`; try { const errorJson = await res.json(); errorDetails += ` Message: ${errorJson.error.message || JSON.stringify(errorJson.error)}`; } catch (e) { errorDetails += ` Response body: ${await res.text()}`; } throw new Error(`API Error: ${errorDetails}`); }
        const data = await res.json();
        return data.choices[0].message.content;
    },
    async callKoboldCPP(prompt, signal) {
        const state = StateManager.getState();
        const payload = {
            prompt: prompt, use_story: false, use_memory: false, use_authors_note: false, use_world_info: false,
            max_context_length: 4096, max_length: 200, min_p: state.koboldcpp_min_p,
            rep_pen: 1.1, rep_pen_range: 2048, rep_pen_slope: 0.7, temperature: 0.65,
            tfs: 1, top_p: 0.92, top_k: 0, typical: 1, sampler_order: [6, 0, 1, 2, 3, 4, 5],
            mirostat: 2, mirostat_tau: 4, mirostat_eta: 0.1, dry: state.koboldcpp_dry,
        };
        const res = await fetch(`${state.koboldcpp_url}/api/v1/generate`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload), signal });
        if (!res.ok) { let errorDetails = `Status: ${res.status} ${res.statusText}.`; try { errorDetails += ` Message: ${(await res.json()).error.message}`; } catch (e) { errorDetails += ` Response body: ${await res.text()}`; } throw new Error(`KoboldCPP API Error: ${errorDetails}`); }
        const data = await res.json();
        return data.results[0].text.trim();
    },
    async callLMStudio(prompt, signal) {
        const state = StateManager.getState();
        if (!state.lmstudio_url) throw new Error("LM Studio URL not set.");
        const endpoint = `${state.lmstudio_url}/v1/chat/completions`;
        const res = await fetch(endpoint, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ messages: [{ role: 'user', content: prompt }], temperature: 0.7, stream: false }), signal });
        if (!res.ok) { let errorDetails = `Status: ${res.status} ${res.statusText}.`; try { const errorJson = await res.json(); errorDetails += ` Message: ${errorJson.error?.message || JSON.stringify(errorJson.error)}`; } catch (e) { errorDetails += ` Response body: ${await res.text()}`; } throw new Error(`LM Studio API Error: ${errorDetails}`); }
        const data = await res.json();
        return data.choices[0].message.content;
    },

    /**
     * Fetches available models from OpenRouter API.
     * @returns {Promise<Array>} Array of model objects with id, name, pricing info, etc.
     */
    async fetchOpenRouterModels() {
        const state = StateManager.getState();
        const headers = { 'Content-Type': 'application/json' };
        if (state.openRouterKey) {
            headers['Authorization'] = `Bearer ${state.openRouterKey}`;
        }
        const res = await fetch('https://openrouter.ai/api/v1/models', { method: 'GET', headers });
        if (!res.ok) {
            let errorDetails = `Status: ${res.status} ${res.statusText}.`;
            try { const errorJson = await res.json(); errorDetails += ` Message: ${errorJson.error?.message || JSON.stringify(errorJson.error)}`; } catch (e) { errorDetails += ` Response body: ${await res.text()}`; }
            throw new Error(`Failed to fetch OpenRouter models: ${errorDetails}`);
        }
        const data = await res.json();
        return data.data || [];
    },
};

/**
 * =================================================================================================
 * ModalManager Module
 * =================================================================================================
 */
const ModalManager = {
    RUNTIME: {
        carousel_interval: null,
    },
    open(modalId) {
        const modal = document.getElementById(modalId);
        if (modal) {
            modal.style.display = 'flex';
        }
    },
    close(modalId) {
        if (this.RUNTIME.carousel_interval) {
            clearInterval(this.RUNTIME.carousel_interval);
            this.RUNTIME.carousel_interval = null;
        }
        const modal = document.getElementById(modalId);
        if (modal) {
            modal.style.display = 'none';
        }
    }
};

/**
 * =================================================================================================
 * UTILITY Module
 * =================================================================================================
 */
const UTILITY = {
    uuid() { 
        return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c => (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)); 
    },
    escapeHTML(str) { 
        if(typeof str !== 'string') return ''; 
        const p = document.createElement("p"); 
        p.textContent = str; 
        return p.innerHTML; 
    },
    hexToRgba(hex, alpha) {
        let r = 0, g = 0, b = 0;
        if (hex.length == 4) { r = "0x" + hex[1] + hex[1]; g = "0x" + hex[2] + hex[2]; b = "0x" + hex[3] + hex[3]; } 
        else if (hex.length == 7) { r = "0x" + hex[1] + hex[2]; g = "0x" + hex[3] + hex[4]; b = "0x" + hex[5] + hex[6]; }
        return `rgba(${+r},${+g},${+b},${alpha})`;
    },
    darkenHex(hex, percent) {
        const num = parseInt(hex.replace("#", ""), 16);
        const amt = Math.round(2.55 * percent);
        const R = (num >> 16) - amt;
        const G = (num >> 8 & 0x00FF) - amt;
        const B = (num & 0x0000FF) - amt;
        return "#" + (0x1000000 + (R<255?R<1?0:R:255)*0x10000 + (G<255?G<1?0:G:255)*0x100 + (B<255?B<1?0:B:255)).toString(16).slice(1);
    },
    getDefaultApiSettings() {
        return {
            apiProvider: 'gemini', geminiApiKey: '', openRouterKey: '', openRouterModel: 'google/gemini-flash-1.5',
            koboldcpp_url: 'http://localhost:5001', koboldcpp_template: 'none', koboldcpp_min_p: 0.1, koboldcpp_dry: 0.25,
            lmstudio_url: 'http://localhost:1234',
        };
    },
    getDefaultUiSettings() {
        return {
            font: "'Inter', sans-serif", backgroundImageURL: '', bubbleOpacity: 0.85,
            chatTextColor: '#e5e7eb', characterImageMode: 'none',
            backgroundBlur: 5, textSize: 16, bubbleImageSize: 100,
        };
    },
	
	getDefaultStorySettings() {
        return {
            creator_notes: "",
            tags: [],
        };
    },
    getDefaultSystemPrompts() {
        return {
            system_prompt: 'You are a master storyteller. Follow instructions precisely.',
            event_master_base_prompt: 'You are a secret Event Master. Read the chat. Generate a brief, secret instruction for AI characters to introduce a logical but unexpected event.',
            event_master_prompt: '', 
            prompt_persona_gen: "Embellish this character concept into a rich, detailed, and compelling persona description. CONCEPT: \"{concept}\"",
            prompt_world_map_gen: "Based on the following story context, generate a genre-appropriate 8x8 grid of interconnected fantasy locations. The central location (4,4) should be a neutral starting point. Attempt to include locations mentioned in the context.\nCONTEXT:\nCHARACTERS:\n{characters}\n\nSTATIC LORE:\n{static}\n\nRECENT EVENTS:\n{recent}\n\nRespond with a valid JSON object: { \"grid\": [ { \"coords\": {\"x\":int, \"y\":int}, \"name\": \"string\", \"description\": \"string (one-line summary)\", \"prompt\": \"string (a rich, detailed paragraph for the AI)\", \"imageUrl\": \"\" } ] }. The grid must contain exactly 64 locations.",
            prompt_location_gen: "Generate a rich, detailed, and evocative paragraph-long prompt for a fantasy location named '{name}' which is briefly described as '{description}'. This prompt will be given to an AI storyteller to describe the scene.",
            prompt_entry_gen: "Generate a detailed and informative encyclopedia-style entry for a lore topic titled '{title}'. If relevant, use the following triggers as context: '{triggers}'.",
            prompt_location_memory_gen: "You are an archivist. Read the following chat transcript that occurred at a specific location. Summarize the key events, character developments, and important facts into a concise, single paragraph. This will serve as a memory for what happened at that location.\n\nTRANSCRIPT:\n{transcript}",
			prompt_story_notes_gen: "Based on the following story context (characters, lore), generate a brief, 1-2 sentence creator's note or 'blurb' for this story to show in a library.\n\nCONTEXT:\n{context}",
            prompt_story_tags_gen: "Based on the following story context (characters, lore), generate 3-5 relevant, one-word, comma-separated tags for this story (e.g., fantasy, sci-fi, mystery, horror, romance).\n\nCONTEXT:\n{context}"
        };
    },
    createDefaultMapGrid() {
        const grid = [];
        for (let y = 0; y < 8; y++) {
            for (let x = 0; x < 8; x++) {
                grid.push({
                    coords: { x, y },
                    name: "",
                    description: "",
                    prompt: "",
                    imageUrl: "",
                    local_static_entries: []
                });
            }
        }
        return grid;
    },
    findPath(grid, startCoords, endCoords) {
        const toKey = ({ x, y }) => `${x},${y}`;
        const fromKey = (key) => { const [x, y] = key.split(',').map(Number); return { x, y }; };

        const nodes = grid.map(loc => ({
            ...loc,
            g: Infinity,
            h: Infinity,
            f: Infinity,
            parent: null,
        }));

        const startNode = nodes.find(n => n.coords.x === startCoords.x && n.coords.y === startCoords.y);
        const endNode = nodes.find(n => n.coords.x === endCoords.x && n.coords.y === endCoords.y);

        if (!startNode || !endNode) return [];

        const heuristic = (a, b) => Math.abs(a.coords.x - b.coords.x) + Math.abs(a.coords.y - b.coords.y);

        let openSet = [startNode];
        let closedSet = new Set();

        startNode.g = 0;
        startNode.h = heuristic(startNode, endNode);
        startNode.f = startNode.h;

        while (openSet.length > 0) {
            openSet.sort((a, b) => a.f - b.f);
            let currentNode = openSet.shift();

            if (currentNode === endNode) {
                let path = [];
                let temp = currentNode;
                while (temp) {
                    path.push(temp.coords);
                    temp = temp.parent;
                }
                return path.reverse();
            }

            closedSet.add(toKey(currentNode.coords));

            const neighbors = nodes.filter(n => {
                const dx = Math.abs(n.coords.x - currentNode.coords.x);
                const dy = Math.abs(n.coords.y - currentNode.coords.y);
                return (dx === 1 && dy === 0) || (dx === 0 && dy === 1);
            });

            for (let neighbor of neighbors) {
                if (closedSet.has(toKey(neighbor.coords))) continue;

                let tentativeG = currentNode.g + 1;

                if (tentativeG < neighbor.g) {
                    neighbor.parent = currentNode;
                    neighbor.g = tentativeG;
                    neighbor.h = heuristic(neighbor, endNode);
                    neighbor.f = neighbor.g + neighbor.h;
                    if (!openSet.includes(neighbor)) {
                        openSet.push(neighbor);
                    }
                }
            }
        }
        return [];
    },
    weightedChoice(characters, weights, controller) {
        if (controller) {
            const scoresDataForModal = characters.map((char, index) => ({
                name: char.name,
                score: weights[index]
            })).sort((a, b) => b.score - a.score);
        }

        if (characters.length !== weights.length || characters.length === 0) {
            return null;
        }
    
        const totalWeight = weights.reduce((sum, weight) => sum + weight, 0);
        if (totalWeight <= 0) {
            return characters[Math.floor(Math.random() * characters.length)];
        }
        let random = Math.random() * totalWeight;
    
        for (let i = 0; i < characters.length; i++) {
            random -= weights[i];
            if (random <= 0) {
                return characters[i];
            }
        }
        
        return characters[characters.length - 1];
    },
    /**
     * [NEW] Checks if there is enough space in localStorage for an estimated import size.
     * @param {number} estimatedSize - The estimated size of the import in bytes.
     * @returns {boolean} - True if there is likely enough space, false otherwise.
     */
    checkLocalStorageQuota(estimatedSize) {
        try {
            const testKey = 'quota-check';
            const existingDataSize = JSON.stringify(localStorage).length;
            const availableSpace = (5 * 1024 * 1024) - existingDataSize; // Assuming 5MB limit
            
            if (estimatedSize > availableSpace) {
                return false;
            }
            
            localStorage.setItem(testKey, '1');
            localStorage.removeItem(testKey);
            return true;
        } catch (e) {
            return false;
        }
    }
};

/**
 * =================================================================================================
 * PromptBuilder Module
 * =================================================================================================
 */
const PromptBuilder = {
    _getReplacer(contextCharacter) {
        const state = StateManager.getState();
        const userChar = state.characters.find(c => c.is_user);
        const characterName = contextCharacter ? contextCharacter.name : '';
        const userName = userChar ? userChar.name : 'You';
        return (text) => {
            if (typeof text !== 'string') return '';
            let processedText = text.replace(/{character}/g, characterName);
            processedText = processedText.replace(/{user}/g, userName);
            return processedText;
        };
    },
	
	_getSmartHistorySlice(history, chatMessageCount) {
            let chatCount = 0;
            let startIndex = history.length; // Default to all if history is shorter
            
            for (let i = history.length - 1; i >= 0; i--) {
                startIndex = i; // Mark the start of the slice
                const msg = history[i];

                // Only count visible chat messages toward the quota
                if (msg.type === 'chat' && !msg.isHidden) {
                    chatCount++;
                }

                if (chatCount >= chatMessageCount) {
                    break; // We found our 10th chat message
                }
            }
            return history.slice(startIndex);
	},	
	
    buildPrompt(charToActId, isForUser = false) {
        const state = StateManager.getState();
        const charToAct = state.characters.find(c => c.id === charToActId);
        if (!charToAct) {
            console.error("PromptBuilder: Could not find character with ID:", charToActId);
            return ""; // Return empty string to prevent errors
        }
        const replacer = this._getReplacer(charToAct);
        const modelInstructions = charToAct.model_instructions || state.system_prompt;

	let locationContext = '';
        if (state.worldMap && state.worldMap.grid.length > 0) {
            const { grid, currentLocation, path } = state.worldMap;
            const currentLoc = grid.find(l => l.coords.x === currentLocation.x && l.coords.y === currentLocation.y);

            // --- 1. Add Current Location (only if name and prompt exist) ---
            if (currentLoc && currentLoc.name && currentLoc.prompt) {
                locationContext += `CURRENT LOCATION: ${currentLoc.name}\n${currentLoc.prompt}\n\n`;

                // Add local static entries if they exist
                if (currentLoc.local_static_entries && currentLoc.local_static_entries.length > 0) {
                    locationContext += "--- LOCATION-SPECIFIC KNOWLEDGE ---\n";
                    locationContext += currentLoc.local_static_entries
                        .map(l => `Title: ${l.title}\nContent: ${replacer(l.content)}`)
                        .join('\n\n') + "\n\n";
                }
            } else if (currentLoc && currentLoc.name) {
                 // Fallback if only name exists but prompt is missing (optional, remove if unwanted)
                 locationContext += `CURRENT LOCATION: ${currentLoc.name}\n(No detailed description available.)\n\n`;
            }

            // --- 2. Add Adjacent Locations (only if they have name AND description) ---
            if (currentLoc) { // Check currentLoc exists before checking neighbors
                const directions = [
                    { dir: 'North', x: 0, y: -1 }, { dir: 'South', x: 0, y: 1 },
                    { dir: 'East', x: 1, y: 0 }, { dir: 'West', x: -1, y: 0 },
                    { dir: 'Northeast', x: 1, y: -1 }, { dir: 'Northwest', x: -1, y: -1 },
                    { dir: 'Southeast', x: 1, y: 1 }, { dir: 'Southwest', x: -1, y: 1 }
                ];

                const validAdjacentLocations = directions
                    .map(({ dir, x, y }) => {
                        const adjLoc = grid.find(l => l.coords.x === currentLocation.x + x && l.coords.y === currentLocation.y + y);
                        // Require both name and description to be non-empty
                        if (adjLoc && adjLoc.name && adjLoc.description) {
                            return `- (${dir}): ${adjLoc.name} - ${adjLoc.description}`;
                        }
                        return null; // Ignore invalid/incomplete locations
                    })
                    .filter(Boolean); // Remove null entries

                // Only add the section if there are valid neighbors
                if (validAdjacentLocations.length > 0) {
                    locationContext += 'ADJACENT LOCATIONS:\n';
                    locationContext += validAdjacentLocations.join('\n') + '\n\n';
                }
            }

            // --- 3. Add Travel Path (only if path array exists and is not empty) ---
            if (path && path.length > 0) {
                const pathNames = path
                    .map(p => grid.find(l => l.coords.x === p.x && l.coords.y === p.y)?.name)
                    .filter(Boolean) // Filter out any potential undefined names
                    .join(' -> ');
                // Ensure pathNames isn't empty after filtering before adding
                if (pathNames) {
                    locationContext += `TRAVEL PATH TO DESTINATION: ${pathNames}\n`;
                }
            }
        }
        
        const components = {
            system_prompt: replacer(modelInstructions),
            event_master_prompt: replacer(state.event_master_prompt),
            static_entries: (state.static_entries || []).map(l => `### ${l.title}\n${replacer(l.content)}`).join('\n\n'),

            characters: (state.characters || []).filter(c => c.is_active).map(c => `### Character: ${c.name}\n\n${replacer(c.description)}`).join('\n\n'),
			history: this._getSmartHistorySlice(state.chat_history || [], 10),            charToAct: charToAct,
            isForUser: isForUser,
            location_context: locationContext,
        };
        
        if (state.event_master_prompt) { 
            state.event_master_prompt = ''; 
            StateManager.saveState(); 
        }

        if (state.apiProvider === 'koboldcpp') { 
            return this.buildKoboldTemplatedPrompt(components, replacer); 
        }
        return this.buildDefaultPrompt(components, replacer);
    },
    buildDefaultPrompt(components, replacer) {
        const state = StateManager.getState();
        let p = components.system_prompt + "\n\n";
        if (components.event_master_prompt) p += "--- SECRET EVENT MASTER INSTRUCTION ---\n" + components.event_master_prompt + "\n\n";
        if (components.location_context) p += "## LOCATION CONTEXT\n" + components.location_context + "\n\n";
        p += "## WORLD KNOWLEDGE\n" + components.static_entries + "\n\n";
        if (components.dynamic_entries) p += "## RECENTLY REVEALED DYNAMIC KNOWLEDGE\n" + components.dynamic_entries + "\n\n";
        p += "## CHARACTERS\n" + components.characters + "\n\n";

        const exampleDialogue = (state.chat_history || []).filter(m => m.isHidden);
        if(exampleDialogue.length > 0){
            p += "## EXAMPLE DIALOGUE\n";
            exampleDialogue.forEach(msg => {
                const char = state.characters.find(c => c.id === msg.character_id);
                if (char) p += `${char.name}: ${replacer(msg.content)}\n`;
            });
            p += "\n";
        }
        
        p += "## RECENT CONVERSATION & EVENTS\n";
		components.history.forEach(msg => { 
            // Skip example dialogue (which is 'chat' AND 'isHidden')
            if (msg.type === 'chat' && msg.isHidden) return;

            if (msg.type === 'chat') {
                const char = state.characters.find(c => c.id === msg.character_id); 
                if (char) p += `[${char.name}:]\n${replacer(msg.content)}\n\n`;
            } else if (msg.type === 'lore_reveal') {
                // This is the new part for inline knowledge
                p += `[System Note:\n${replacer(msg.content)}]\n\n`;
            } else if (msg.type === 'system_event') {
                 p += `[System Event: ${replacer(msg.content)}]\n\n`; // Added \n for spacing
            }
        });
        p += "\n### INSTRUCTION\n";
        p += components.isForUser ? `Generate the next creative response for the user's character, ${components.charToAct.name}.` : `Generate the next response for ${components.charToAct.name}. Stay in character.`;
        p += " Do not repeat the character's name in the response itself.\n[CHARACTER_TO_ACT]: " + components.charToAct.name;
        return p;
    },
    buildKoboldTemplatedPrompt(components, replacer) {
        const state = StateManager.getState();
        const template = state.koboldcpp_template;
        if (template === 'none') return this.buildDefaultPrompt(components, replacer);

        let system = [components.system_prompt];
        if (components.event_master_prompt) system.push("SECRET EVENT INSTRUCTION:\n" + components.event_master_prompt);
        if (components.location_context) system.push("LOCATION CONTEXT:\n" + components.location_context);
        system.push("STATIC KNOWLEDGE:\n" + components.static_entries);
        if (components.dynamic_entries) system.push("DYNAMIC KNOWLEDGE:\n" + components.dynamic_entries);
        system.push("CHARACTERS:\n" + components.characters);
        const system_prompt_str = system.join('\n\n');
        
        const history_str = components.history.map(msg => {
			// Skip example dialogue
            if (msg.type === 'chat' && msg.isHidden) return null;

            if (msg.type === 'chat') {
                const char = state.characters.find(c => c.id === msg.character_id); 
                if (char) return `${char.is_user ? 'user' : 'assistant'}:${char.name}:\n${replacer(msg.content)}`;
            } else if (msg.type === 'lore_reveal') {
                return `system:Dynamic Entry Revealed - ${msg.title}:\n${replacer(msg.content)}`;
            } else if (msg.type === 'system_event') {
                return `system:System Event:\n${replacer(msg.content)}`;
            }
            return null; // Fallback for other types
        }).filter(Boolean).join('\n');

        let instruction = components.isForUser ? `Write the next chat message for the user's character, ${components.charToAct.name}.` : `Write the next chat message for ${components.charToAct.name}. Stay in character.`;
        instruction += " Do not write any prefix like 'Character Name:'.";

switch (template) {
            case 'mistral':
                return `<s>[INST] ${system_prompt_str}\n\n${history_str}\n\n${instruction} [/INST]`;
            case 'chatml':
                const history_chatml = components.history.map(msg => {
                    // Skip example dialogue
                    if (msg.type === 'chat' && msg.isHidden) return null;

                    let role = 'system';
                    let content = '';

                    if (msg.type === 'chat') {
                        const char = state.characters.find(c => c.id === msg.character_id);
                        if (!char) return null;
                        role = char.is_user ? 'user' : 'assistant';
                        content = `${char.name}:\n${replacer(msg.content)}`;
                    } else if (msg.type === 'lore_reveal') {
                        content = `[Dynamic Entry Revealed - ${msg.title}]\n${replacer(msg.content)}`;
                    } else if (msg.type === 'system_event') {
                        content = `[System Event: ${replacer(msg.content)}]`;
                    } else {
                        return null;
                    }
                    
                    return `<|im_start|>${role}\n${content}<|im_end|>`;
                }).filter(Boolean).join('\n');
                
                return `<|im_start|>system\n${system_prompt_str}<|im_end|>\n${history_chatml}\n<|im_start|>user\n${instruction}<|im_end|>\n<|im_start|>assistant\n${components.charToAct.name}:\n`;
            case 'alpaca':
                 return `### Instruction:\n${system_prompt_str}\n\n${history_str}\n\n${instruction}\n\n### Response:\n`;
            default:
                return this.buildDefaultPrompt(components, replacer);
        }
    },
};

/**
 * =================================================================================================
 * [10/17/2025 Edit] ImageProcessor Module
 * =================================================================================================
 * Handles client-side image processing, such as resizing and format conversion.
 */
/**
 * =================================================================================================
 * [10/17/2025 Edit] ImageProcessor Module
 * =================================================================================================
 * Handles client-side image processing, such as resizing and format conversion.
 */
const ImageProcessor = {
    /**
     * Processes an image file, resizing it if necessary and converting it to a JPEG data URL.
     */
	async processImageAsBlob(imageFile) { // Renamed for clarity
		return new Promise((resolve, reject) => {
			const MAX_HEIGHT = 2000;
			const QUALITY = 0.85;

			const reader = new FileReader();
			reader.onload = (e) => {
				const img = new Image();
				img.onload = () => {
					let { width, height } = img;
					if (height > MAX_HEIGHT) {
						const ratio = MAX_HEIGHT / height;
						height = MAX_HEIGHT;
						width *= ratio;
					}
					const canvas = document.createElement('canvas');
					canvas.width = width;
					canvas.height = height;
					const ctx = canvas.getContext('2d');
					ctx.drawImage(img, 0, 0, width, height);

					canvas.toBlob((blob) => {
						if (blob) {
							resolve(blob);
						} else {
							reject(new Error('Canvas to Blob conversion failed.'));
						}
					}, 'image/jpeg', QUALITY); // Still saves as JPEG initially
				};
				img.onerror = (err) => reject(new Error('Failed to load image for processing.'));
				img.src = e.target.result;
			};
			reader.onerror = (err) => reject(new Error('Failed to read image file.'));
			reader.readAsDataURL(imageFile);
		});
	}, // <<< Make sure there is a comma here after the first function

    /**
     * Converts an image Blob (potentially JPEG) to a PNG Blob using a canvas.
     * @param {Blob} imageBlob - The input image Blob.
     * @returns {Promise<Blob>} A promise that resolves with the PNG Blob.
     */
    async convertBlobToPNGBlob(imageBlob) {
        return new Promise((resolve, reject) => {
            // Create an object URL from the input Blob
            const imageUrl = URL.createObjectURL(imageBlob);
            const img = new Image();

            img.onload = () => {
                // Image loaded successfully, now draw to canvas
                const canvas = document.createElement('canvas');
                canvas.width = img.naturalWidth; // Use natural dimensions
                canvas.height = img.naturalHeight;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0);

                // IMPORTANT: Revoke the object URL *after* drawing to canvas
                URL.revokeObjectURL(imageUrl);

                // Convert canvas content to a PNG Blob
                canvas.toBlob((pngBlob) => {
                    if (pngBlob) {
                        resolve(pngBlob); // Resolve the promise with the new PNG Blob
                    } else {
                        reject(new Error('Canvas to PNG Blob conversion failed.'));
                    }
                }, 'image/png'); // Specify PNG format
            };

            img.onerror = (err) => {
                // Handle image loading errors
                URL.revokeObjectURL(imageUrl); // Clean up even on error
                reject(new Error('Failed to load image blob for PNG conversion. Could be invalid image data.'));
            };

            // Start loading the image from the object URL
            img.src = imageUrl;
        });
    }

};


/**
 * =================================================================================================
 * ImportExportService Module
 * =================================================================================================
 * Manages all data conversion and file handling for importing and exporting stories.
 */
const ImportExportService = {
    // --- Public High-Level API ---

    /**
     * Main entry point for file imports. Determines file type and routes to the correct parser.
     * @param {File} file - The uploaded file object.
     * @param {boolean} [skipImages=false] - If true, image processing will be skipped to save storage space.
     * @returns {Promise<object>} A promise that resolves with a fully formed Ellipsis story object.
     */
    async parseUploadedFile(file, skipImages = false) {
        const lowerCaseName = file.name.toLowerCase();
        
        if (lowerCaseName.endsWith('.png')) {
            return this._parseV2Card(file, skipImages);
        } else if (lowerCaseName.endsWith('.zip') || lowerCaseName.endsWith('.byaf')) {
            return this._parseBYAF(file, skipImages);
        } else if (lowerCaseName.endsWith('.json')) {
            return this._parseEllipsisJSON(file);
        } else {
            throw new Error("Unsupported file type. Please use .png, .byaf, .zip, or .json.");
        }
    },

    /**
     * Exports a narrative to a native Ellipsis JSON file.
     * @param {object} story - The story object containing the narrative.
     * @returns {Blob} A Blob containing the JSON data.
     */
    exportStoryAsJSON(story) {
        const storyExport = JSON.parse(JSON.stringify(story));
        return new Blob([JSON.stringify(storyExport, null, 2)], { type: 'application/json' });
    },

    /**
     * Exports a narrative to the V2 PNG Card format.
     * @param {object} story - The story object.
     * @param {object} narrative - The narrative to export.
     * @param {string} primaryCharId - The ID of the character to feature on the card.
     * @returns {Promise<Blob>} A promise that resolves with a Blob of the final PNG file.
     */
async exportStoryAsV2(story, narrative, primaryCharId) {
        const primaryChar = story.characters.find(c => c.id === primaryCharId);
        if (!primaryChar) {
             throw new Error("V2 export requires a selected primary character.");
        }

        let originalImageBlob = null; // Store the potentially non-PNG blob

        // --- IMAGE FETCHING LOGIC (same as previous fix) ---
        try {
            originalImageBlob = await DBService.getImage(primaryChar.id);
        } catch (dbError) {
            console.warn(`Could not get image from IDB for ${primaryChar.id}:`, dbError);
        }
        if (!originalImageBlob && primaryChar.image_url && !primaryChar.image_url.startsWith('local_idb_')) {
            try {
                const response = await fetch(primaryChar.image_url);
                if (response.ok) {
                    originalImageBlob = await response.blob();
                } else {
                     console.warn(`Failed to fetch legacy image URL for ${primaryChar.id}: ${response.statusText}`);
                }
            } catch (fetchError) {
                console.warn(`Error fetching legacy image URL for ${primaryChar.id}:`, fetchError);
            }
        }
        // --- END IMAGE FETCHING LOGIC ---

        if (!originalImageBlob) {
            throw new Error("V2 export requires the primary character to have a valid image (either uploaded locally or via URL).");
        }

        // --- NEW: Convert the retrieved blob to PNG ---
        let pngBlob;
        try {
            // Only convert if it's not already PNG
            if (originalImageBlob.type === 'image/png') {
                pngBlob = originalImageBlob;
                console.log("Image is already PNG, skipping conversion.");
            } else {
                console.log(`Converting image from ${originalImageBlob.type} to PNG...`);
                pngBlob = await ImageProcessor.convertBlobToPNGBlob(originalImageBlob);
            }
        } catch (conversionError) {
            console.error("PNG Conversion failed:", conversionError);
            throw new Error("Failed to convert character image to PNG format for export.");
        }
        // --- END NEW CONVERSION STEP ---

        const v2Object = this._convertEllipsistoV2(story, narrative, primaryCharId);

        // Convert the *PNG* Blob to ArrayBuffer needed by _injectDataIntoPng
        const pngImageBuffer = await pngBlob.arrayBuffer();

        // Pass the PNG buffer to the injection function
        return this._injectDataIntoPng(pngImageBuffer, v2Object);
    },
    
    /**
     * Exports a narrative to the BYAF format.
     * @param {object} story - The story object.
     * @param {object} narrative - The narrative to export.
     * @param {string} primaryCharId - The ID of the primary character.
     * @returns {Promise<Blob>} A promise that resolves with a Blob of the final .byaf (zip) file.
     */
async exportStoryAsBYAF(story, narrative, primaryCharId) {
        const primaryChar = story.characters.find(c => c.id === primaryCharId);
        if (!primaryChar) throw new Error("BYAF export requires a selected primary character.");

        let imageBlob = null;
        let imageExtension = 'png'; // Default extension
        let imageFilename = null; // Filename including extension, derived later

        // --- IMAGE FETCHING LOGIC (Determine extension FIRST) ---
        try {
            const blob = await DBService.getImage(primaryChar.id);
            if (blob) {
                imageBlob = blob;
                const typeParts = blob.type.split('/');
                if (typeParts.length === 2 && ['png', 'jpeg', 'jpg', 'webp'].includes(typeParts[1])) {
                    imageExtension = typeParts[1] === 'jpeg' ? 'jpg' : typeParts[1];
                }
                console.log(`BYAF Export: Found local image (${imageBlob.type}), using extension: ${imageExtension}`);
            }
        } catch (dbError) {
            console.warn(`Could not get image from IDB for BYAF export ${primaryChar.id}:`, dbError);
        }

        if (!imageBlob && primaryChar.image_url && !primaryChar.image_url.startsWith('local_idb_')) {
            try {
                const response = await fetch(primaryChar.image_url);
                if (response.ok) {
                    const blob = await response.blob();
                    imageBlob = blob;
                    let determinedExt = 'png'; // Default inside this block
                     const contentType = response.headers.get('content-type');
                     if (contentType) {
                         const typeParts = contentType.split('/');
                         if (typeParts.length === 2 && ['png', 'jpeg', 'jpg', 'webp'].includes(typeParts[1])) {
                            determinedExt = typeParts[1] === 'jpeg' ? 'jpg' : typeParts[1];
                         }
                     } else {
                         const urlParts = primaryChar.image_url.split('.').pop()?.toLowerCase();
                         if (urlParts && ['png', 'jpg', 'jpeg', 'webp'].includes(urlParts)) {
                             determinedExt = urlParts === 'jpeg' ? 'jpg' : urlParts;
                         }
                     }
                     imageExtension = determinedExt; // Update the outer scope variable
                     console.log(`BYAF Export: Fetched legacy image (${contentType || 'unknown type'}), using extension: ${imageExtension}`);
                } else {
                     console.warn(`Failed to fetch legacy image URL for BYAF export ${primaryChar.id}: ${response.statusText}`);
                }
            } catch (fetchError) {
                console.warn(`Error fetching legacy image URL for BYAF export ${primaryChar.id}:`, fetchError);
            }
        }
        // --- END IMAGE FETCHING ---

        // --- GENERATE FILENAME (using character ID) ---
        if (imageBlob) {
             // Use character ID for the filename base, similar to example
            imageFilename = `${primaryChar.id}.${imageExtension}`;
        }

        // Call converter, passing the determined filename (or null if no image)
        const byafArchiveData = this._convertEllipsistoBYAF(story, narrative, primaryCharId, imageFilename);

        if (!byafArchiveData || !byafArchiveData.manifest || !byafArchiveData.character || !byafArchiveData.scenario) {
            throw new Error("Failed to generate BYAF data structure (converter returned invalid data).");
         }

        const zip = new JSZip();

        zip.file("manifest.json", JSON.stringify(byafArchiveData.manifest, null, 2));

        // --- CRITICAL: Use the character's ORIGINAL ID for the folder path ---
        const charFolder = zip.folder(`characters/${primaryChar.id}`);
        charFolder.file("character.json", JSON.stringify(byafArchiveData.character, null, 2));

        // Add the image blob if it exists, using the generated filename
        if (imageBlob && imageFilename) {
            charFolder.file(`images/${imageFilename}`, imageBlob);
             console.log(`BYAF Export: Added image blob as images/${imageFilename}`);
        } else {
            console.log("BYAF Export: No image blob found or added.");
        }

        zip.file(`scenarios/scenario1.json`, JSON.stringify(byafArchiveData.scenario, null, 2));

        return zip.generateAsync({ type: "blob" });
    },


    // --- Internal Parsing & Data Mapping Logic ---
    
    async _parseEllipsisJSON(file) {
        const jsonString = await file.text();
        const story = JSON.parse(jsonString);

        // Basic validation
        if (!story.id || !story.name || !story.characters) {
            throw new Error("Invalid Ellipsis JSON file. Missing required fields.");
        }
        // Re-randomize IDs to prevent conflicts in the library
        story.id = UTILITY.uuid();
        (story.characters || []).forEach(c => c.id = UTILITY.uuid());
        (story.scenarios || []).forEach(s => s.id = UTILITY.uuid());
        (story.narratives || []).forEach(n => {
            n.id = UTILITY.uuid();
            (n.state?.static_entries || []).forEach(e => e.id = UTILITY.uuid());
        });
        (story.dynamic_entries || []).forEach(e => e.id = UTILITY.uuid());
        
        return { story, imageBlob: null };
    },

    async _parseV2Card(file, skipImages) {
        const arrayBuffer = await file.arrayBuffer();
        const v2DataString = await this._extractV2Data(arrayBuffer);
        if (!v2DataString) throw new Error("No character data found in PNG file.");
        
        const v2RawData = JSON.parse(this._b64_to_utf8(v2DataString));
        const v2Data = v2RawData.data || v2RawData; // Handle both v1 and v2 spec

        let imageBlob = null;
		if (!skipImages) {
			imageBlob = await ImageProcessor.processImageAsBlob(file);
		}
		return { story: this._convertV2toEllipsis(v2Data), imageBlob };
    },

    async _parseBYAF(file, skipImages) {
        const zip = await JSZip.loadAsync(file);

        const characterFile = zip.file(/character\.json$/i)[0];
        const scenarioFile = zip.file(/scenario\d*\.json$/i)[0];
        const imageFile = zip.file(/\.png$/i)[0];

        if (!characterFile || !scenarioFile) {
            throw new Error("Archive is missing character.json or scenario.json.");
        }

        const byafData = {
            character: JSON.parse(await characterFile.async('string')),
            scenario: JSON.parse(await scenarioFile.async('string')),
        };

		let imageBlob = null;
		if (!skipImages && imageFile) {
			const imageFileBlob = await imageFile.async('blob');
			imageBlob = await ImageProcessor.processImageAsBlob(imageFileBlob);
		}
		return { story: this._convertBYAFtoEllipsis(byafData), imageBlob }; // Also correct the function call here
    },

    // --- Data Conversion Helpers (Import) ---

_convertBYAFtoEllipsis(byafData) {
        const { character, scenario } = byafData;
        const story = this._createEmptyEllipsisStory();
        story.name = character.displayName || character.name || "Imported Character";
        story.tags = character.tags || [];

        // 1. Construct Characters
        const userChar = { id: UTILITY.uuid(), name: "You", description: "The protagonist.", short_description: "The main character.", model_instructions: "Write a response for {character} in a creative and descriptive style.", is_user: true, is_active: true, image_url: '', tags:[], is_narrator: false };
        const aiChar = {
            id: UTILITY.uuid(),
            name: character.displayName || character.name,
            description: character.persona || "",
            short_description: (character.persona || "").split('.')[0] + '.',
            model_instructions: scenario.formattingInstructions || "Act as {character}. Be descriptive and engaging.",
            image_url: '',
            extra_portraits: [],
            tags: character.tags || [],
            is_user: false,
            is_active: true,
            is_narrator: false
        };
        story.characters = [userChar, aiChar];

        // --- NEW: Define Active IDs ---
        const activeIDs = [userChar.id, aiChar.id];

        // 2. Construct Lore
        if (character.loreItems) {
            story.dynamic_entries = character.loreItems.map(item => ({
                id: UTILITY.uuid(),
                title: item.key || "Imported Lore",
                triggers: item.key || "",
                content_fields: [item.value || ""],
                current_index: 0,
                triggered_at_turn: null
            }));
        }

        // 3. Parse Example Dialogue
        const exampleDialogue = [];
        if (scenario.exampleMessages && scenario.exampleMessages.length > 0) {
            const charNameIdMap = { '#{character}:': aiChar.id, '#{user}:': userChar.id };
            const regex = /(#\{(?:character|user)\}:)([\s\S]*?)(?=#\{|$)/g;

            scenario.exampleMessages.forEach(msg => {
                const exampleText = msg.text || "";
                for (const match of exampleText.matchAll(regex)) {
                    const speakerPrefix = match[1];
                    const messageContent = match[2].trim();
                    const speakerId = charNameIdMap[speakerPrefix];

                    if (speakerId && messageContent) {
                        exampleDialogue.push({
                            character_id: speakerId,
                            content: messageContent,
                            type: 'chat',
                            emotion: 'neutral',
                            timestamp: new Date().toISOString(),
                            isHidden: true
                        });
                    }
                }
            });
        }

        const staticEntries = [];
        if (scenario.narrative) {
            staticEntries.push({ id: UTILITY.uuid(), title: "Starting Scenario", content: scenario.narrative });
        }

        // 4. Create Scenario
        const firstMes = (scenario.firstMessages && scenario.firstMessages[0]?.text) || `The story of ${aiChar.name} begins.`;
        const newScenario = { 
            id: UTILITY.uuid(), 
            name: "Imported Start", 
            message: firstMes,
            // --- NEW: Active IDs ---
            active_character_ids: activeIDs,
            dynamic_entries: JSON.parse(JSON.stringify(story.dynamic_entries)),
            example_dialogue: JSON.parse(JSON.stringify(exampleDialogue)),
            static_entries: staticEntries,
            worldMap: { grid: UTILITY.createDefaultMapGrid(), currentLocation: { x: 4, y: 4 }, destination: { x: null, y: null }, path: [] },
            prompts: UTILITY.getDefaultSystemPrompts() // Simplification for BYAF which lacks internal prompts
        };
        story.scenarios.push(newScenario);

        // 5. Create Narrative
        const narrative = this._createEmptyEllipsisNarrative("Imported Chat");
        // --- NEW: Active IDs ---
        narrative.active_character_ids = activeIDs;
        narrative.state.static_entries = JSON.parse(JSON.stringify(staticEntries));
        
        if (exampleDialogue.length > 0) {
            narrative.state.chat_history.push(...JSON.parse(JSON.stringify(exampleDialogue)));
        }
		
		if (firstMes) {
			narrative.state.chat_history.push({
				character_id: aiChar.id,
				content: firstMes,
				type: 'chat',
				emotion: 'neutral',
				timestamp: new Date().toISOString(),
				isHidden: false 
			});
			narrative.state.messageCounter = 1;
		}

		story.narratives.push(narrative);
		return story;
	},
	
	_convertV2toEllipsis(v2Data) {
		const story = this._createEmptyEllipsisStory();
		story.name = v2Data.name || "Imported Character";
		story.tags = v2Data.tags || [];

		// 1. Construct Characters
		const userChar = { id: UTILITY.uuid(), name: "You", description: "The protagonist.", short_description: "The main character.", model_instructions: "Write a response for {user} in a creative and descriptive style.", is_user: true, is_active: true, image_url: '', tags:[], is_narrator: false };
		const aiChar = {
			id: UTILITY.uuid(),
			name: v2Data.name || "Imported Character",
			...UTILITY.getDefaultStorySettings(),
			description: (v2Data.description || "").replace(/{{char}}/g, v2Data.name || "Imported Character").replace(/{{user}}/g, "{user}"),
			short_description: (v2Data.description || "").split('.')[0] + '.',
			model_instructions: (v2Data.system_prompt || "Act as {character}. Be descriptive and engaging.").replace(/{{char}}/g, "{character}").replace(/{{user}}/g, "{user}"),
			image_url: '',
			extra_portraits: [],
			tags: v2Data.tags || [],
			is_user: false,
			is_active: true,
			is_narrator: false
		};
		story.characters = [userChar, aiChar];
		
		// --- NEW: Define who is active for this import ---
        const activeIDs = [userChar.id, aiChar.id];

		// 2. Construct Lore (Dynamic Entries)
		if (v2Data.character_book && v2Data.character_book.entries) {
			story.dynamic_entries = v2Data.character_book.entries.map(entry => ({
				id: UTILITY.uuid(),
				title: (entry.keys || []).join(', ') || "Imported Lore",
				triggers: (entry.keys || []).join(', '),
				content_fields: [entry.content || ""],
                current_index: 0,
				triggered_at_turn: null
			}));
		}
		
        // 3. Prepare Snapshot Data (Common to all scenarios)
        // We create a snapshot of the story state *as it exists right now*
		const promptSnapshot = {
            system_prompt: story.system_prompt,
            event_master_base_prompt: story.event_master_base_prompt,
            prompt_persona_gen: story.prompt_persona_gen,
            prompt_world_map_gen: story.prompt_world_map_gen,
            prompt_location_gen: story.prompt_location_gen,
            prompt_entry_gen: story.prompt_entry_gen,
            prompt_location_memory_gen: story.prompt_location_memory_gen,
            font: story.font,
            bubbleOpacity: story.bubbleOpacity,
            chatTextColor: story.chatTextColor
        };

		// 4. Process Example Dialogue
        const exampleDialogue = [];
        if (v2Data.mes_example) {
            const charNameIdMap = { '{{user}}': userChar.id, '{{char}}': aiChar.id };
            const regex = /({{user}}|{{char}}):([\s\S]*?)(?={{user}}:|{{char}}:|$)/g;
            let cleanedText = v2Data.mes_example.replace(/<START>/g).trim();
            
            for (const match of cleanedText.matchAll(regex)) {
                const speakerPrefix = match[1];
                const messageContent = match[2].trim().replace(/{{char}}/g, aiChar.name).replace(/{{user}}/g, "{user}");
                const speakerId = charNameIdMap[speakerPrefix];

                if (speakerId && messageContent) {
                    exampleDialogue.push({
                        character_id: speakerId,
                        content: messageContent,
                        type: 'chat',
                        isHidden: true,
                        timestamp: new Date().toISOString()
                    });
                }
            }
        }

		// 5. Create Scenarios (Snapshots)
        // Create a scenario for the main first_mes AND each alternate_greeting
		const allGreetings = [v2Data.first_mes || `The story of ${aiChar.name} begins.`];
		if (Array.isArray(v2Data.alternate_greetings)) {
			allGreetings.push(...v2Data.alternate_greetings);
		}
    
		story.scenarios = [];
		allGreetings.forEach((greeting, index) => {
			const scenarioName = index === 0 ? "Imported Start" : `Alternate Start ${index}`;
			const messageContent = (greeting || "").replace(/{{char}}/g, aiChar.name).replace(/{{user}}/g, "{user}");
			
			story.scenarios.push({
				id: UTILITY.uuid(),
				name: scenarioName,
				message: messageContent,
                // Include Full Snapshot
                active_character_ids: activeIDs,
                dynamic_entries: JSON.parse(JSON.stringify(story.dynamic_entries)),
                prompts: JSON.parse(JSON.stringify(promptSnapshot)),
                example_dialogue: JSON.parse(JSON.stringify(exampleDialogue)),
                static_entries: [],
                worldMap: { grid: UTILITY.createDefaultMapGrid(), currentLocation: { x: 4, y: 4 }, destination: { x: null, y: null }, path: [] }
			});
		});
		
        // 6. Create Initial Narrative
		const narrative = this._createEmptyEllipsisNarrative("Imported Chat");
		
		narrative.active_character_ids = activeIDs;
        
        // Add example dialogue to narrative history
        if (exampleDialogue.length > 0) {
            narrative.state.chat_history.push(...JSON.parse(JSON.stringify(exampleDialogue)));
        }

        // Add the first message from the PRIMARY scenario
        const firstScenario = story.scenarios[0];
        if (firstScenario && firstScenario.message) {
            narrative.state.chat_history.push({
                character_id: aiChar.id,
                content: firstScenario.message,
                type: 'chat',
                isHidden: false,
                timestamp: new Date().toISOString()
            });
            narrative.state.messageCounter = 1;
        }
			
        story.narratives.push(narrative);
        return story;
    },	

    // --- Data Conversion Helpers (Export) ---

	_convertEllipsistoV2(story, narrative, primaryCharId) {
        const primaryChar = story.characters.find(c => c.id === primaryCharId);
        const userChar = story.characters.find(c => c.is_user);

        // --- NEW: Filter other characters by Narrative Active State ---
        // If active_character_ids exists, use it. Otherwise fall back to all (legacy safety).
        const activeIDs = narrative.active_character_ids || story.characters.map(c => c.id);
        
        // Find other AI characters that are NOT the primary char AND are active in this narrative
        const otherAiChars = story.characters.filter(c => 
            !c.is_user && 
            c.id !== primaryCharId && 
            activeIDs.includes(c.id)
        );

        if (!primaryChar) throw new Error("Primary character not found during V2 conversion.");

        // --- Prepare Merged Description ---
        let fullDescription = primaryChar.description || "";
        if (otherAiChars.length > 0) {
            fullDescription += "\n\n--- Other Characters ---\n";
            otherAiChars.forEach(char => {
                fullDescription += `\nName: ${char.name || 'Unnamed Character'}\nDescription: ${char.description || '(No description)'}\n`;
            });
        }

        // --- Prepare Character Book Entries ---
        const bookEntries = [];
        let insertionCounter = 0; // Simple counter for insertion_order

        // Map dynamic entries
        (story.dynamic_entries || []).forEach(entry => {
            bookEntries.push({
                keys: (entry.triggers || entry.title || "").split(',').map(t => t.trim()).filter(Boolean),
                content: entry.content || "",
                enabled: true, // Mandatory field
                insertion_order: insertionCounter++, // Mandatory field
                extensions: {}, // Mandatory field
                // Add other optional fields with defaults if desired (e.g., case_sensitive: false)
                case_sensitive: false,
            });
        });

        // Map world map locations
        (narrative.state.worldMap?.grid || [])
            .filter(loc => loc.name) // Only include locations with names
            .forEach(loc => {
                bookEntries.push({
                    keys: [loc.name], // Use location name as the key
                    content: `Location Description: ${loc.description || '(No description)'}\n\nLocation Prompt: ${loc.prompt || '(No prompt)'}`,
                    enabled: true,
                    insertion_order: insertionCounter++,
                    extensions: {},
                    case_sensitive: false,
                });
             });

        // Map local static entries for the *current* location in the narrative state
         const currentLocCoords = narrative.state.worldMap?.currentLocation;
         if (currentLocCoords) {
            const currentLocData = narrative.state.worldMap.grid.find(l => l.coords.x === currentLocCoords.x && l.coords.y === currentLocCoords.y);
            if (currentLocData && currentLocData.local_static_entries) {
                currentLocData.local_static_entries.forEach(entry => {
                     bookEntries.push({
                        keys: [(entry.title || "Local Lore").toLowerCase()], // Use title as key
                        content: entry.content || "",
                        enabled: true,
                        insertion_order: insertionCounter++,
                        extensions: {},
                        case_sensitive: false,
                    });
                });
            }
         }


        // --- Prepare Example Messages ---
        // Replace placeholders correctly for V2 format ({character} -> {{char}}, {user} -> {{user}})
        const replacePlaceholdersV2 = (text) => {
            if (typeof text !== 'string') return '';
            let processed = text.replace(/{character}/gi, '{{char}}'); // Replace your format
            processed = processed.replace(/{user}/gi, '{{user}}');     // Replace your format
            // Ensure standard {{char}} and {{user}} are present if original was different
            processed = processed.replace(/\{\{char\}\}/gi, '{{char}}');
            processed = processed.replace(/\{\{user\}\}/gi, '{{user}}');
            return processed;
        }

        // Map hidden messages to mes_example
        const mesExample = (narrative.state.chat_history || [])
            .filter(m => m.isHidden && m.type === 'chat')
            .map(m => {
                const speaker = story.characters.find(c => c.id === m.character_id);
                if (speaker) {
                     // Use V2 placeholders
                    const prefix = speaker.is_user ? '{{user}}:' : '{{char}}:';
                    return `${prefix}\n${replacePlaceholdersV2(m.content)}`;
                }
                return replacePlaceholdersV2(m.content); // Fallback if speaker somehow missing
            })
            .join('\n'); // V2 spec doesn't specify separator, newline seems common

        // Find the first non-hidden message for first_mes
        const firstMessageEntry = (narrative.state.chat_history || []).find(m => !m.isHidden && m.type === 'chat');
        const firstMes = firstMessageEntry ? replacePlaceholdersV2(firstMessageEntry.content) : replacePlaceholdersV2(`The story of ${primaryChar.name} begins.`);


        // --- Construct the V2 Data Object ---
		// --- Prepare Scenario Field from Static Entries ---
        const scenarioText = (narrative.state.static_entries || [])
            .map(entry => `[${entry.title || 'Untitled Entry'}]\n${entry.content || '(No content)'}`)
            .join('\n\n---\n\n'); // Use a clear separator between entries
			
        const v2Data = {
            // V1 Fields (Required by convention within V2 data)
            name: primaryChar.name || "",
            description: replacePlaceholdersV2(fullDescription), // Ensure placeholders are V2 style
            personality: "", // Add mandatory empty V1 field
            scenario: replacePlaceholdersV2(scenarioText),
            first_mes: firstMes,
            mes_example: mesExample,

            // V2 Fields
            creator_notes: "", // Optional, default empty
            system_prompt: replacePlaceholdersV2(primaryChar.model_instructions || ""), // Ensure V2 placeholders
            post_history_instructions: "", // Optional, default empty
            alternate_greetings: [], // Mandatory empty array
            character_book: {
                name: "", // Optional book name
                description: "", // Optional book description
                scan_depth: 100, // Example value, adjust if needed
                token_budget: 2048, // Example value
                recursive_scanning: false, // Default
                extensions: {}, // Mandatory empty object
                entries: bookEntries // Use the prepared entries array
            },
            tags: primaryChar.tags || [], // Mandatory (can be empty array)
            creator: "", // Optional, default empty
            character_version: "", // Optional, default empty
            // --- CRITICAL: Add mandatory extensions object ---
            extensions: {}
        };

        // --- Construct the Final V2 Object ---
        const v2Object = {
            spec: 'chara_card_v2',      // Mandatory
            spec_version: '2.0',        // Mandatory
            data: v2Data
        };

        return v2Object; // This object will be passed to _injectDataIntoPng
    },
    
// MODIFIED: Added imageFilename parameter
    _convertEllipsistoBYAF(story, narrative, primaryCharId, imageFilename = null) { // Expect full filename or null
        const primaryChar = story.characters.find(c => c.id === primaryCharId);
        const userChar = story.characters.find(c => c.is_user); // Needed for example messages

        if (!primaryChar) {
             console.error("Primary character not found in _convertEllipsistoBYAF");
             return { manifest: {}, character: {}, scenario: {} }; // Return empty structure on error
        }
        const now = new Date().toISOString();

        // Map dynamic entries and world map locations
        const loreItems = [
            ...(story.dynamic_entries || []),
            ...(narrative.state.worldMap?.grid || [])
                .filter(loc => loc.name) // Ensure location has a name
                .map(loc => ({ // Map grid locations to lore item structure
                    id: UTILITY.uuid(), // Generate unique ID for the lore item itself
                    title: loc.name,
                    triggers: loc.name, // Use name as trigger key
                    content: `Description: ${loc.description || '(no description)'}\n\nPrompt: ${loc.prompt || '(no prompt)'}`
                }))
        ].map((entry, index) => ({
            id: entry.id || UTILITY.uuid(), // Use existing ID if available, else generate
            // --- ADDED: Simple random string for order ---
            order: Math.random().toString(36).substring(2, 12), // Placeholder order
            key: entry.triggers || entry.title || `Imported Lore ${index + 1}`,
            value: entry.content || "",
            createdAt: entry.created_date || now, // Use original creation date if possible
            updatedAt: entry.last_modified || now // Use original modified date if possible
        }));


        const character = {
            schemaVersion: 1,
            name: primaryChar.name || "",
            displayName: primaryChar.name || "", // Often used for a shorter/display name
             // --- MODIFIED: Use the passed filename ---
            images: imageFilename ? [{ path: `images/${imageFilename}`, label: "" }] : [],
            createdAt: primaryChar.created_date || now, // Try to preserve original dates
            updatedAt: primaryChar.last_modified || now,
            // --- CRITICAL: Use the character's ORIGINAL ID ---
            id: primaryChar.id,
            isNSFW: false, // Assuming false
            persona: primaryChar.description || "",
            loreItems: loreItems,
            tags: primaryChar.tags || []
        };

        const firstMessageEntry = (narrative.state.chat_history || []).find(m => !m.isHidden && m.type === 'chat');
        // Use the actual first message content if found, otherwise a default
        const firstMessageText = firstMessageEntry ? firstMessageEntry.content : `The story of ${primaryChar.name} begins.`;

        // Filter for hidden messages and map them correctly
        const exampleMessages = (narrative.state.chat_history || [])
            .filter(m => m.isHidden && m.type === 'chat')
            .map(m => {
                const speaker = story.characters.find(c => c.id === m.character_id);
                let byafFormattedText = m.content || ""; // Ensure content exists
                let msgCharId = null;

                // Add BYAF prefixes and set characterID appropriately
                if (speaker) {
                    if (speaker.is_user) {
                        byafFormattedText = `#{user}:\n${byafFormattedText}`;
                        // characterID should be null/absent for user messages in exampleMessages
                    } else if (speaker.id === primaryChar.id) { // Only map the primary character
                        byafFormattedText = `#{character}:\n${byafFormattedText}`;
                         // --- CRITICAL: Use the character's ORIGINAL ID ---
                        msgCharId = primaryChar.id;
                    } else {
                         // Optional: Handle other AI chars differently? For now, skip prefix/ID.
                         // Or maybe add their name? Let's just include the text.
                    }
                }

                return {
                    text: byafFormattedText,
                    characterID: msgCharId // Will be null for user or non-primary AI
                };
            })
            // Optional: Filter out messages that didn't belong to user or primary AI, if desired
            // .filter(m => m.text.startsWith('#{user}:') || m.text.startsWith('#{character}:'));

        // --- ADDED: Missing fields with defaults ---
        const scenario = {
            schemaVersion: 1,
            title: narrative.name || "Exported Scenario", // Use narrative name or placeholder
            canDeleteExampleMessages: true, // Default
            exampleMessages: exampleMessages, // Use the correctly mapped array
            model: "", // Default empty
            temperature: 1.0, // Default
            topP: 0.9, // Default
            minP: 0.1, // Default
             // --- CRITICAL: Use the character's ORIGINAL ID ---
            firstMessages: [{ text: firstMessageText, characterID: primaryChar.id }],
            formattingInstructions: primaryChar.model_instructions || "",
            grammar: "", // Default empty
            repeatPenalty: 1.05, // Default
            repeatLastN: 256, // Default
            topK: 30, // Default
            minPEnabled: false, // Default - Match example (was true)
             // Use static entry if exists, else empty string
            narrative: (narrative.state.static_entries || []).find(e => e.title === "Starting Scenario")?.content || "",
            promptTemplate: null, // Default
            messages: [] // Default empty
        };

        const manifest = {
            schemaVersion: 1,
            createdAt: now,
            // --- CRITICAL: Use the character's ORIGINAL ID in the path ---
            characters: [ `characters/${primaryChar.id}/character.json` ],
            scenarios: [ `scenarios/scenario1.json` ] // Assuming only one scenario export
        };

        return { manifest, character, scenario };
    },

    // --- Low-Level File and Helper Functions ---
    
    _createEmptyEllipsisStory() {
        return {
            id: UTILITY.uuid(),
            name: "New Imported Story",
            last_modified: new Date().toISOString(),
            created_date: new Date().toISOString(),
            ...UTILITY.getDefaultApiSettings(),
            ...UTILITY.getDefaultUiSettings(),
            ...UTILITY.getDefaultSystemPrompts(),
            characters: [],
            dynamic_entries: [],
            scenarios: [],
            narratives: []
        };
    },
    
    _createEmptyEllipsisNarrative(name) {
        return {
            id: UTILITY.uuid(), name: name,
            last_modified: new Date().toISOString(),
            state: {
                chat_history: [], messageCounter: 0, static_entries: [],
                worldMap: { grid: UTILITY.createDefaultMapGrid(), currentLocation: { x: 4, y: 4 }, destination: {x:null, y:null}, path:[] }
            }
        };
    },

    _b64_to_utf8(str) {
        return decodeURIComponent(escape(atob(str)));
    },

    _utf8_to_b64(str) {
        return btoa(unescape(encodeURIComponent(str)));
    },

    async _extractV2Data(arrayBuffer) {
        const dataView = new DataView(arrayBuffer);
        const PNG_SIGNATURE = [0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A];
        for (let i = 0; i < PNG_SIGNATURE.length; i++) { if (dataView.getUint8(i) !== PNG_SIGNATURE[i]) throw new Error("Invalid PNG signature."); }
        let offset = 8;
        while (offset < arrayBuffer.byteLength) {
            const length = dataView.getUint32(offset);
            const type = String.fromCharCode.apply(null, new Uint8Array(arrayBuffer, offset + 4, 4));
            if (['tEXt', 'zTXt'].includes(type)) {
                let keywordEnd = -1;
                for (let i = 0; i < length; i++) { if (dataView.getUint8(offset + 8 + i) === 0) { keywordEnd = i; break; } }
                if (keywordEnd !== -1) {
                    const keyword = new TextDecoder().decode(new Uint8Array(arrayBuffer, offset + 8, keywordEnd));
                    if (keyword === 'chara') {
                        if (type === 'tEXt') return new TextDecoder().decode(new Uint8Array(arrayBuffer, offset + 8 + keywordEnd + 1, length - keywordEnd - 1));
                        if (type === 'zTXt') return new TextDecoder().decode(pako.inflate(new Uint8Array(arrayBuffer, offset + 8 + keywordEnd + 2, length - keywordEnd - 2)));
                    }
                }
            }
            if (type === 'IEND') break;
            offset += 12 + length;
        }
        return null;
    },

async _injectDataIntoPng(imageBuffer, v2Object) {
        // Standard PNG CRC32 calculation table and function
        const _CRC_TABLE = Array.from({ length: 256 }, (_, n) => { let c = n; for (let k = 0; k < 8; k++) c = (c & 1) ? (0xedb88320 ^ (c >>> 1)) : (c >>> 1); return c; });
        const _crc32 = (bytes) => { let crc = -1; for (const byte of bytes) crc = (crc >>> 8) ^ _CRC_TABLE[(crc ^ byte) & 0xff]; return (crc ^ -1) >>> 0; };

// --- Prepare data for zTXt chunk (Compressed) ---
        // 1. Stringify the V2 character data object
        const jsonDataString = JSON.stringify(v2Object);
        // 2. Base64 encode the JSON string
        const base64Data = this._utf8_to_b64(jsonDataString);
        // 3. Get the raw bytes *of the Base64 string itself*
        const base64Bytes = new TextEncoder().encode(base64Data);
        // 4. Compress these bytes using pako (DEFLATE)
        const compressedData = pako.deflate(base64Bytes);
        // 5. Define the keyword
        const keyword = 'chara';

        // 6. Create the chunk data for zTXt: keyword + null separator + compression method (0) + compressed data
        const keywordBytes = new TextEncoder().encode(keyword);
        const chunkData = new Uint8Array(keywordBytes.length + 1 + 1 + compressedData.length);

        chunkData.set(keywordBytes);                      // Keyword: "chara"
        chunkData[keywordBytes.length] = 0;               // Null separator
        chunkData[keywordBytes.length + 1] = 0;           // Compression method (0 = DEFLATE)
        chunkData.set(compressedData, keywordBytes.length + 2); // Compressed data bytes

        // 7. Define the chunk type as zTXt
        const chunkType = new TextEncoder().encode('zTXt');
        // --- End Corrected Data Preparation ---

        // Prepare data for CRC calculation (Chunk Type + Chunk Data)
        const dataForCrc = new Uint8Array(chunkType.length + chunkData.length);
        dataForCrc.set(chunkType);
        dataForCrc.set(chunkData, chunkType.length);
        const crc = _crc32(dataForCrc); // Calculate CRC

        // --- Inject the chunk before IEND using proper chunk iteration ---
        const originalPng = new Uint8Array(imageBuffer);
        const dataView = new DataView(originalPng.buffer);
        let iendOffset = -1; // This will store the starting offset of the IEND chunk
        let offset = 8;      // Start after PNG signature

        while (offset < originalPng.length) {
            // Read chunk length (data length) - 4 bytes, Big Endian
            const length = dataView.getUint32(offset);
            // Read chunk type - 4 bytes
            const type = String.fromCharCode.apply(null, originalPng.slice(offset + 4, offset + 8));

            if (type === 'IEND') {
                iendOffset = offset; // Found the start of the IEND chunk
                break;
            }

            // Move to the next chunk: current offset + chunk header (8 bytes) + data length + CRC (4 bytes)
            offset += 12 + length;
        }


        if (iendOffset === -1) {
             console.error("Original PNG Data (first 50 bytes):", originalPng.slice(0, 50));
             throw new Error('Could not find IEND chunk using proper iteration. The image data might be corrupted or not a valid PNG.');
        }

        // Calculate new PNG size: Original up to IEND + New Chunk (12 bytes header/CRC + data length) + IEND chunk (12 bytes)
        const newChunkLength = chunkData.length;
        const newPngSize = iendOffset + (12 + newChunkLength) + 12;
        const newPng = new Uint8Array(newPngSize);
        const newPngView = new DataView(newPng.buffer);

        // 1. Copy original PNG data up to the point where IEND starts
        newPng.set(originalPng.slice(0, iendOffset));

        // 2. Write the new zTXt chunk
        let writeOffset = iendOffset;
        newPngView.setUint32(writeOffset, newChunkLength);      // Length of chunk data
        writeOffset += 4;
        newPng.set(chunkType, writeOffset);                     // Chunk Type ("zTXt")
        writeOffset += chunkType.length;
        newPng.set(chunkData, writeOffset);                     // Chunk Data (keyword \0 method \0 compressed_data)
        writeOffset += chunkData.length;
        newPngView.setUint32(writeOffset, crc);                 // CRC of Type+Data
        writeOffset += 4;

        // 3. Write the original IEND chunk (always 12 bytes: 0 length, "IEND" type, CRC)
        newPng.set(originalPng.slice(iendOffset, iendOffset + 12), writeOffset);

        return new Blob([newPng], { type: 'image/png' });
    }
};



    <!-- PASTE content of ui.js HERE -->
/**
 * =================================================================================================
 * UIManager Module (The View)
 * =================================================================================================
 * This module is exclusively responsible for all direct DOM manipulation. It reads data
 * from the StateManager to render the UI but does not modify the application's state itself.
 */
const UIManager = {
    // Holds temporary, non-persistent properties related to the app's runtime behavior.
    RUNTIME: {
        streamingInterval: null,
        titleTimeout: null,
        lastCinematicImageUrl: null,
        activeCinematicBg: 1,
		globalBackgroundImageCache: null,
    },
    
    /**
     * Returns the SVG icon string for AI generation buttons.
     * @returns {string} SVG HTML string.
     */
    getAIGenIcon() {
        return `<svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10 3.5a1.5 1.5 0 011.5 1.5V6a1.5 1.5 0 01-3 0V5A1.5 1.5 0 0110 3.5zM5.429 7.429a1.5 1.5 0 012.121 0l1.061 1.061a1.5 1.5 0 01-2.121 2.121L5.429 9.55a1.5 1.5 0 010-2.121zM14.571 7.429a1.5 1.5 0 010 2.121l-1.061 1.061a1.5 1.5 0 01-2.121-2.121l1.061-1.061a1.5 1.5 0 012.121 0zM10 16.5a1.5 1.5 0 01-1.5-1.5V14a1.5 1.5 0 013 0v1a1.5 1.5 0 01-1.5 1.5z"></path></svg>`;
    },

    /**
     * Renders all primary UI components. Called on initial load and after major state changes.
     */
    renderAll() { 
        const state = StateManager.getState();
        if (state && state.narrativeName) {
            document.getElementById('story-title-input').value = state.narrativeName;
            const mobileTitle = document.getElementById('mobile-story-title-overlay');
            if (mobileTitle) mobileTitle.value = state.narrativeName;
        }
        this.renderCharacters(); 
        this.renderStaticEntries(); 
        this.renderDynamicEntries(); 
        this.renderChat(); 
        this.updateAICharacterSelector(); 
    },

    /**
     * Renders the main story library interface, including search, sort, and filter controls.
     * @param {object} [filterState={}] - The current state of the filters (searchTerm, sortBy, filterTag).
     */
    renderLibraryInterface(filterState = {}) {
        const library = StateManager.getLibrary();
        const container = document.getElementById('library-content-container');
        const { searchTerm = '', sortBy = 'last_modified', filterTag = '' } = filterState;

        const isTallScreen = window.innerHeight > window.innerWidth;

        // --- Filter, Search, Sort Logic ---
        let stories = [...library.stories];
        if (searchTerm) {
            const lowerCaseSearch = searchTerm.toLowerCase();
            stories = stories.filter(s => s.search_index && s.search_index.includes(lowerCaseSearch));
        }
	if (filterTag) {
            const lowerFilter = filterTag.toLowerCase();
            stories = stories.filter(s => {
                // Create a set of all tags in this story, converted to lowercase
                const storyTags = new Set();
                
                // Add story tags
                (s.tags || []).forEach(t => storyTags.add(t.toLowerCase()));
                
                // Add character tags
                (s.characters || []).forEach(c => (c.tags || []).forEach(t => storyTags.add(t.toLowerCase())));
                
                return storyTags.has(lowerFilter);
            });
        }
        stories.sort((a, b) => {
            if (sortBy === 'name') return (a.name || '').localeCompare(b.name || '');
            if (sortBy === 'created_date') return new Date(b.created_date) - new Date(a.created_date);
            return new Date(b.last_modified) - new Date(a.last_modified);
        });

        // --- Controls HTML ---
        const tagOptions = library.tag_cache.map(tag => `<option value="${tag}" ${filterTag === tag ? 'selected':''}>${tag}</option>`).join('');
        const controlsHTML = `
            <div class="p-6 border-b border-gray-700 space-y-4">
                <input type="search" placeholder="Search stories..." value="${searchTerm}" oninput="UIManager.renderLibraryInterface({searchTerm: this.value, sortBy: document.getElementById('sort-by').value, filterTag: document.getElementById('filter-by-tag').value})" class="w-full bg-black/30 p-2 rounded-lg border-gray-600">
                <div class="flex space-x-4">
                    <select id="sort-by" onchange="UIManager.renderLibraryInterface({searchTerm: document.querySelector('#library-content-container input[type=search]').value, sortBy: this.value, filterTag: document.getElementById('filter-by-tag').value})" class="w-1/2 bg-black/30 p-2 rounded-lg border-gray-600">
                        <option value="last_modified" ${sortBy === 'last_modified' ? 'selected' : ''}>Modified</option>
                        <option value="name" ${sortBy === 'name' ? 'selected' : ''}>Name</option>
                        <option value="created_date" ${sortBy === 'created_date' ? 'selected' : ''}>Created</option>
                    </select>
                    <select id="filter-by-tag" onchange="UIManager.renderLibraryInterface({searchTerm: document.querySelector('#library-content-container input[type=search]').value, sortBy: document.getElementById('sort-by').value, filterTag: this.value})" class="w-1/2 bg-black/30 p-2 rounded-lg border-gray-600">
                        <option value="">All Tags</option>
                        ${tagOptions}
                    </select>
                </div>
            </div>`;

        // --- Story List HTML ---
        const storyListHTML = stories.map(story => {
            const displayName = story.name || 'Untitled Story';
            const isActiveStory = story.id === library.active_story_id;
            return `
            <div class="p-4 rounded-lg flex justify-between items-center cursor-pointer ${isActiveStory ? 'bg-indigo-600/30' : 'bg-gray-700/50 hover:bg-gray-600/50'}" onclick="UIManager.openStoryDetails('${story.id}')">
                <div>
                    <h3 class="font-semibold text-lg">${UTILITY.escapeHTML(displayName)}</h3>
                    <p class="text-sm text-gray-400">Modified: ${new Date(story.last_modified).toLocaleString()}</p>
                </div>
                ${isActiveStory ? '<span class="text-xs text-indigo-300 font-bold">ACTIVE</span>' : ''}
            </div>
        `}).join('<hr class="border-gray-700 my-2">');

        // --- Assemble Final Layout ---
        if (isTallScreen) {
             container.innerHTML = `<div class="flex flex-col flex-grow min-h-0">${controlsHTML}<div class="p-6 overflow-y-auto">${storyListHTML}</div></div>`;
        } else {
            container.innerHTML = `
                <div class="w-[450px] flex-shrink-0 border-r border-gray-700 flex flex-col">${controlsHTML}<div class="p-6 overflow-y-auto flex-grow">${storyListHTML}</div></div>
                <div id="story-details-content-desktop" class="flex-grow p-6 flex text-gray-500"><div class="w-full h-full flex items-center justify-center">Select a story to see details...</div></div>
            `;
        }
    },

/**
     * Renders the detailed view for a selected story.
     * [UPDATED] Header-based actions, scrollable carousel, expandable scenarios.
     */
    openStoryDetails(storyId) {
        const library = StateManager.getLibrary();
        const story = library.stories.find(s => s.id === storyId);
        if (!story) return;
		const isMobile = (window.innerHeight > window.innerWidth);
		const closeModalAction = isMobile 
			? "Controller.closeModal('story-details-modal')" 
			: "Controller.closeModal('story-library-modal')";

        // 1. Generate Scenarios HTML (Expandable, Markdown, No Message BG)
        const scenariosHTML = (story.scenarios || []).map(scenario => `
            <details open class="bg-gray-700/30 rounded-lg overflow-hidden group">
                <summary class="p-3 cursor-pointer hover:bg-gray-700/50 flex justify-between items-center font-semibold select-none">
                    <span>${UTILITY.escapeHTML(scenario.name)}</span>
                    <span class="text-xs text-gray-400 group-open:hidden"></span>
                    <span class="text-xs text-gray-400 hidden group-open:block"></span>
                </summary>
                <div class="p-3 bg-black/20 border-t border-gray-600 space-y-3">
                    <div>
                        <p class="text-xs text-gray-400 font-bold mb-1">First Message:</p>
                        <div class="text-sm text-gray-300 prose prose-invert prose-sm max-w-none">
                            ${marked.parse(scenario.message || '*(No message)*')}
                        </div>
                    </div>
                    <div class="flex gap-2 justify-end pt-2">
                        <button onclick="Controller.createNarrativeFromScenario('${story.id}', '${scenario.id}')" class="bg-indigo-600 hover:bg-indigo-500 text-white text-xs font-bold py-1 px-3 rounded" title="Load Scenario">Load</button>
                        <button onclick="Controller.duplicateScenario('${story.id}', '${scenario.id}')" class="bg-gray-600 hover:bg-gray-500 text-white text-xs font-bold py-1 px-3 rounded" title="Duplicate">Duplicate</button>
                        <button onclick="Controller.deleteScenario('${story.id}', '${scenario.id}')" class="bg-red-600 hover:bg-red-500 text-white text-xs font-bold py-1 px-3 rounded" title="Delete">Delete</button>
                    </div>
                </div>
            </details>
        `).join('');

        // 2. Generate Narratives HTML (Buttons re-ordered, new Load icon)
        const narrativesHTML = (story.narratives || []).sort((a, b) => new Date(b.last_modified) - new Date(a.last_modified)).map(narrative => `
            <div class="bg-gray-700/60 p-3 rounded-lg flex justify-between items-center gap-2">
                <div class="flex-grow min-w-0">
                    <p class="font-semibold truncate">${UTILITY.escapeHTML(narrative.name)}</p>
                    <p class="text-xs text-gray-400">Modified: ${new Date(narrative.last_modified).toLocaleString()}</p>
                </div>
                ${narrative.id === library.active_narrative_id && story.id === library.active_story_id ? '<span class="text-xs text-sky-300 font-bold flex-shrink-0">ACTIVE</span>' : ''}
                
                <div class="flex-shrink-0 flex items-center gap-2">
                    <button onclick="Controller.deleteNarrative('${story.id}', '${narrative.id}')" class="text-red-400 hover:text-red-300 p-1" title="Delete"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg></button>
                    <button onclick="Controller.elevateNarrativeToScenario('${story.id}', '${narrative.id}')" class="text-teal-400 hover:text-teal-300 p-1" title="Elevate to Scenario"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 11l3-3m0 0l3 3m-3-3v8m0-13a9 9 0 110 18 9 9 0 010-18z"></path></svg></button>
                    <button onclick="Controller.duplicateNarrative('${story.id}', '${narrative.id}')" class="text-gray-400 hover:text-gray-300 p-1" title="Duplicate"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path></svg></button>
                    <button onclick="Controller.loadNarrative('${story.id}', '${narrative.id}')" class="text-green-400 hover:text-green-300 p-1" title="Load Narrative"><svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20"><path d="M6.3 2.841A1.5 1.5 0 0 0 4 4.11V15.89a1.5 1.5 0 0 0 2.3 1.269l9.344-5.89a1.5 1.5 0 0 0 0-2.538L6.3 2.84Z"/></svg></button>
                </div>
            </div>
        `).join('');

        // 3. Construct Full HTML
        const detailsHTML = `
            <div class="absolute top-0 left-0 right-0 z-20 p-4 flex justify-between items-center bg-gradient-to-b from-black/60 to-transparent" style="padding-top: calc(1rem + env(safe-area-inset-top));">
				<input type="text" 
                   value="${UTILITY.escapeHTML(story.name)}" 
                   oninput="Controller.updateStoryField('${story.id}', 'name', this.value)" 
                   class="text-xl font-bold bg-transparent border border-transparent hover:border-gray-600 focus:border-indigo-500 rounded px-2 py-1 text-white w-2/3 transition-colors focus:outline-none focus:bg-black/30 story-details-title-input"
                   placeholder="Story Title">
            
            <div class="story-details-title-balancer"></div>

                <div class="flex items-center space-x-2">
                    <button onclick="Controller.duplicateStory('${story.id}')" class="bg-gray-700/50 hover:bg-gray-600/80 text-gray-300 hover:text-white p-2 rounded-lg transition-colors" title="Duplicate Story">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path></svg>
                    </button>
                    <button onclick="Controller.deleteStory('${story.id}')" class="bg-red-900/50 hover:bg-red-700/80 text-red-200 hover:text-white p-2 rounded-lg transition-colors" title="Delete Story">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
                    </button>
                    <div class="w-px h-6 bg-gray-600/50 mx-2"></div>
                    <button onclick="${closeModalAction}" class="bg-gray-700/50 hover:bg-gray-600/80 text-gray-300 hover:text-white p-2 rounded-lg transition-colors" title="Close">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                    </button>
                </div>
            </div>

            <div class="flex-grow overflow-y-auto min-h-0 details-scroll-container">
                
                <div class="relative w-full aspect-square bg-black/50 group">
                     <div id="details-carousel" class="w-full h-full object-cover"></div>
                     </div>

                <div class="p-6 space-y-8">
                    
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                        <div>
                            <label class="text-sm text-gray-400 font-bold mb-1 block">Creator's Note</label>
                            <div class="relative">
                                <textarea oninput="Controller.updateStoryField('${story.id}', 'creator_notes', this.value)" class="w-full bg-black/30 border-gray-600 p-3 rounded-lg resize-none h-24 text-sm focus:ring-1 focus:ring-indigo-500 transition-all">${UTILITY.escapeHTML(story.creator_notes || '')}</textarea>
                                <button onclick="Controller.generateStoryNotesAI(event, '${story.id}')" class="absolute top-2 right-2 text-gray-500 hover:text-indigo-400 transition-colors" title="Generate with AI">${this.getAIGenIcon()}</button>
                            </div>
                        </div>
						<div>
							<label class="text-sm text-gray-400 font-bold mb-1 block">Tags</label>
							<div class="relative">
								<input type="text" value="${UTILITY.escapeHTML((story.tags || []).join(', '))}" oninput="Controller.updateStoryTags('${story.id}', this.value)" class="w-full bg-black/30 border-gray-600 p-3 rounded-lg text-sm focus:ring-1 focus:ring-indigo-500 transition-all">
								<button onclick="Controller.generateStoryTagsAI(event, '${story.id}')" class="absolute top-1/2 right-2 -translate-y-1/2 text-gray-500 hover:text-indigo-400 transition-colors" title="Generate with AI">${this.getAIGenIcon()}</button>
							</div>
						</div>
                    </div>

                    <hr class="border-gray-700">

                    <div>
                        <h4 class="font-bold text-lg mb-4 text-indigo-300 flex items-center">
                            <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10"></path></svg>
                            Scenarios (Templates)
                        </h4>
                        <div class="space-y-3">${scenariosHTML || '<p class="text-sm text-gray-500 italic">No scenarios available.</p>'}</div>
                    </div>

                    <hr class="border-gray-700">

                    <div>
                        <h4 class="font-bold text-lg mb-4 text-sky-300 flex items-center">
                            <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 10h.01M12 10h.01M16 10h.01M9 16H5a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v8a2 2 0 01-2 2h-5l-5 5v-5z"></path></svg>
                            Narratives (Chats)
                        </h4>
                        <div class="space-y-2">${narrativesHTML || '<p class="text-sm text-gray-500 italic">No narratives started. Load a scenario to begin.</p>'}</div>
                    </div>
                </div>
            </div>
        `;

        // Render based on device
        if (window.innerHeight > window.innerWidth) {
            // MODIFIED: Target the modal's main content box to overwrite the footer
            document.querySelector('#story-details-modal > div:not(.modal-overlay)').innerHTML = detailsHTML;
            Controller.openModal('story-details-modal');
        } else {
            // MODIFIED: Wrap desktop content to fix padding issue
            const detailsWrapperHTML = `
                <div class="w-full h-full flex flex-col md:-m-6 bg-gray-900 relative">
                    ${detailsHTML}
                </div>
            `;
            document.getElementById('story-details-content-desktop').innerHTML = detailsWrapperHTML;
        }
        
        // Start carousel
        this.startCarousel(story.characters, 'details-carousel');
    },

    /**
     * Starts an image carousel for the story details view.
     * @param {Array} characters - The characters from the story.
     * @param {string} containerId - The ID of the element to host the carousel.
     */
    startCarousel(characters, containerId) {
        if (ModalManager.RUNTIME.carousel_interval) clearInterval(ModalManager.RUNTIME.carousel_interval);
        
        const container = document.getElementById(containerId);
        if (!container) return;

		const images = (characters || [])
		  .map(c => UIManager.getPortraitSrc(c))
		  .filter(Boolean);

        if (images.length === 0) {
            container.innerHTML = `<div class="w-full h-full flex items-center justify-center bg-gray-900 text-gray-500">No character images</div>`;
            return;
        }

        container.innerHTML = `
            <img id="${containerId}-img1" class="absolute inset-0 w-full h-full object-cover object-top transition-opacity duration-1000" style="opacity: 1;">
            <img id="${containerId}-img2" class="absolute inset-0 w-full h-full object-cover object-top transition-opacity duration-1000" style="opacity: 0;">
        `;
        
        let currentIndex = 0;
        let activeImg = 1;

        const img1 = document.getElementById(`${containerId}-img1`);
        const img2 = document.getElementById(`${containerId}-img2`);
        img1.src = images[currentIndex];
        
        ModalManager.RUNTIME.carousel_interval = setInterval(() => {
            currentIndex = (currentIndex + 1) % images.length;
            if (activeImg === 1) {
                img2.src = images[currentIndex];
                img1.style.opacity = 0;
                img2.style.opacity = 1;
                activeImg = 2;
            } else {
                img1.src = images[currentIndex];
                img1.style.opacity = 1;
                img2.style.opacity = 0;
                activeImg = 1;
            }
        }, 4000);
    },
    
	renderCharacters() { 
        const state = StateManager.getState();
        const container = document.getElementById('characters-container');
        if (!state.characters) {
            container.innerHTML = '';
            return;
        }
        container.innerHTML = state.characters.map(char => {
            const tagsHTML = (char.tags || []).map(tag => `<span class="bg-indigo-500/50 text-indigo-200 text-xs font-semibold mr-2 px-2.5 py-0.5 rounded">${UTILITY.escapeHTML(tag)}</span>`).join('');
            
            // --- NEW VISUAL LOGIC ---
            // If inactive: 50% opacity and grayscale
            const visualStyle = char.is_active 
                ? "" 
                : "opacity: 0.5; filter: grayscale(80%);";
            const activeBadge = char.is_active
                ? ""
                : '<div class="absolute top-2 right-2 bg-black/60 text-gray-300 text-xs px-2 py-1 rounded">Inactive</div>';
            // ------------------------

            return `
                <div onclick="Controller.openModal('character-detail-modal', '${char.id}')" 
                     class="char-roster-btn" 
                     style="background-image: url('${UIManager.RUNTIME.characterImageCache[char.id] || char.image_url || 'https://placehold.co/600x800/111827/4b5563?text=?'}'); ${visualStyle}">
                    ${activeBadge}
                    <div class="char-roster-content text-white">
                        <h3 class="font-bold text-lg truncate">${UTILITY.escapeHTML(char.name)}</h3>
                        <p class="text-sm text-gray-300 italic truncate">${UTILITY.escapeHTML(char.short_description)}</p>
                        <div class="mt-2 h-6 overflow-hidden">${tagsHTML}</div>
                    </div>
                </div>
            `;
        }).join('');
    },

    renderKnowledgeModalTabs() {
        const tabName = Controller.RUNTIME.activeKnowledgeTab;
        const staticTab = document.getElementById('knowledge-tab-static');
        const dynamicTab = document.getElementById('knowledge-tab-dynamic');
        const staticContent = document.getElementById('knowledge-static-content');
        const dynamicContent = document.getElementById('knowledge-dynamic-content');
        const addButton = document.getElementById('knowledge-add-button');

        if (tabName === 'static') {
            staticContent.classList.remove('hidden');
            dynamicContent.classList.add('hidden');
            staticTab.classList.add('border-indigo-500', 'text-white');
            staticTab.classList.remove('border-transparent', 'text-gray-400');
            dynamicTab.classList.add('border-transparent', 'text-gray-400');
            dynamicTab.classList.remove('border-indigo-500', 'text-white');
            addButton.onclick = () => Controller.addStaticEntry();
            this.renderStaticEntries();
        } else { // dynamic
            dynamicContent.classList.remove('hidden');
            staticContent.classList.add('hidden');
            dynamicTab.classList.add('border-indigo-500', 'text-white');
            dynamicTab.classList.remove('border-transparent', 'text-gray-400');
            staticTab.classList.add('border-transparent', 'text-gray-400');
            staticTab.classList.remove('border-indigo-500', 'text-white');
            addButton.onclick = () => Controller.addDynamicEntry();
            this.renderDynamicEntries();
        }
    },
    
    renderStaticEntries() { 
        const state = StateManager.getState(); 
        document.getElementById('static-entries-list').innerHTML = (state.static_entries || []).map(entry => `<div onclick="Controller.selectStaticEntry('${entry.id}')" class="p-3 rounded-lg cursor-pointer ${state.selectedStaticEntryId === entry.id ? 'bg-indigo-600' : 'hover:bg-indigo-600/50'}"><h4 class="font-semibold truncate">${UTILITY.escapeHTML(entry.title)}</h4></div>`).join(''); 
        this.renderStaticEntryDetails(); 
    },
    
    renderStaticEntryDetails() { 
        const state = StateManager.getState(); 
        const container = document.getElementById('static-entry-details-content'); 
        const entry = (state.static_entries || []).find(e => e.id === state.selectedStaticEntryId); 
        if (entry) { 
            container.innerHTML = `
            <div class="flex flex-col h-full">
				<input type="text" value="${UTILITY.escapeHTML(entry.title)}" oninput="Controller.updateStaticEntryField('${entry.id}', 'title', this.value)" onblur="UIManager.renderStaticEntries()" class="text-xl font-bold bg-black/30 p-2 w-full mb-4 flex-shrink-0">
                <div class="relative flex-grow">
                    <textarea oninput="Controller.updateStaticEntryField('${entry.id}', 'content', this.value)" class="w-full h-full bg-black/30 p-2 resize-none rounded-md">${UTILITY.escapeHTML(entry.content)}</textarea>
                    <button onclick="Controller.generateStaticEntryContentAI(event, '${entry.id}')" class="absolute top-2 right-2 text-sky-400 hover:text-sky-300 p-1 bg-sky-600/80 rounded" title="Generate with AI">${this.getAIGenIcon()}</button>
                </div>
                <div class="flex justify-end mt-4 flex-shrink-0">
                    <button onclick="Controller.deleteStaticEntry('${entry.id}')" class="text-sm bg-red-600/80 hover:bg-red-700/80 font-semibold py-2 px-3 rounded-lg">Delete</button>
                </div>
            </div>`; 
        } else { 
            container.innerHTML = `<div class="text-gray-400 flex items-center justify-center h-full">Select a static entry.</div>`; 
        } 
    },
    
    renderDynamicEntries() { 
        const state = StateManager.getState(); 
        document.getElementById('dynamic-entries-list').innerHTML = (state.dynamic_entries || []).map(entry => `<div onclick="Controller.selectDynamicEntry('${entry.id}')" class="p-3 rounded-lg cursor-pointer ${state.selectedDynamicEntryId === entry.id ? 'bg-indigo-600' : 'hover:bg-indigo-600/50'} flex justify-between items-center"><h4 class="font-semibold truncate">${UTILITY.escapeHTML(entry.title)}</h4> ${entry.triggered_at_turn !== null ? '<span class="text-xs text-sky-300">ACTIVE</span>' : ''}</div>`).join(''); 
        this.renderDynamicEntryDetails(); 
    },
    
renderDynamicEntryDetails() { 
        const state = StateManager.getState();
        const container = document.getElementById('dynamic-entry-details-content'); 
        const entry = (state.dynamic_entries || []).find(e => e.id === state.selectedDynamicEntryId); 
        
        if (entry) {
            // 1. Map over the content_fields array to generate a textarea for each
            const contentFieldsHTML = (entry.content_fields || [""]).map((content, index) => {
                // The last field gets a "sticky" note
                const isLastField = index === entry.content_fields.length - 1;
                const stickyNote = isLastField 
                    ? `<span class="text-xs text-gray-400 italic ml-4">This entry will be used for all future triggers.</span>`
                    : '';

                return `
                    <div class="bg-black/20 p-3 rounded-lg">
                        <label class="font-bold mb-2 flex justify-between items-center">
                            <span>Step ${index + 1}</span>
                            ${stickyNote}
                        </label>
                        <div class="relative">
                            <textarea 
                                oninput="Controller.updateDynamicContentField('${entry.id}', ${index}, this.value)" 
                                class="w-full h-24 bg-gray-900/80 border-gray-600 p-2 resize-y rounded-md"
                            >${UTILITY.escapeHTML(content)}</textarea>
                            <button 
                                onclick="Controller.generateDynamicEntryContentAI(event, '${entry.id}', ${index})" 
                                class="absolute top-2 right-2 text-sky-400 hover:text-sky-300 p-1 bg-sky-600/80 rounded" 
                                title="Generate with AI"
                            >${this.getAIGenIcon()}</button>
                        </div>
                    </div>
                `;
            }).join('<hr class="border-gray-700/50 my-2">'); // Separator

            // 2. Build the final HTML
            container.innerHTML = `<div class="flex flex-col h-full">
                <label class="font-bold">Title</label>
				<input type="text" value="${UTILITY.escapeHTML(entry.title)}" oninput="Controller.updateDynamicEntryField('${entry.id}', 'title', this.value)" onblur="UIManager.renderDynamicEntries()" class="text-xl font-bold bg-black/30 p-2 w-full mb-4">
                
                <label class="font-bold mb-2">Triggers (Keywords, AND, XOR, % Chance)</label>
                <input type="text" value="${UTILITY.escapeHTML(entry.triggers)}" oninput="Controller.updateDynamicEntryField('${entry.id}', 'triggers', this.value)" placeholder="e.g. house, cat AND dog, 25%" class="bg-black/30 p-2 w-full mb-4">
                
                <div class="relative flex-grow flex flex-col">
                    <label class="font-bold mb-2">Content Sequence</label>
                    <div class="space-y-2">
                        ${contentFieldsHTML}
                    </div>
                    <button 
                        onclick="Controller.addDynamicContentField('${entry.id}')" 
                        class="mt-3 bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg text-sm w-full"
                    >
                        + Add Content Field
                    </button>
                </div>

                <div class="flex justify-end mt-4">
                    <button onclick="Controller.deleteDynamicEntry('${entry.id}')" class="text-sm bg-red-600/80 hover:bg-red-700/80 font-semibold py-2 px-3 rounded-lg">Delete Entry</button>
                </div>
            </div>`; 
        } else { 
            container.innerHTML = `<div class="text-gray-400 flex items-center justify-center h-full">Select a dynamic entry.</div>`; 
        } 
    },
    
    _createMessageHTML(msg, index) {
        const state = StateManager.getState();
        if (msg.type === 'lore_reveal' || msg.isHidden) return '';
        
        if (msg.type === 'system_event') {
            return `<div class="w-full text-center my-2"><p class="text-sm italic text-gray-400">${UTILITY.escapeHTML(msg.content)}</p></div>`;
        }

        const character = state.characters.find(c => c.id === msg.character_id);
        if (!character) return '';

        const userChar = state.characters.find(c => c.is_user);
        const characterName = character ? character.name : '';
        const userName = userChar ? userChar.name : 'You';
        const replacer = (text) => {
            if (typeof text !== 'string') return '';
            return text.replace(/{character}/g, characterName).replace(/{user}/g, userName);
        };

        const processedContent = replacer(msg.content);
        const contentId = `message-content-${index}`;
		const styledContent = processedContent.replace(/(["][^"]*["])/g, `<span class="dialogue-quote">$1</span>`);
		let contentHTML = marked.parse(styledContent || '');
        
        let bubbleStyle = '';
        let characterNameColor = '';

		const imgSrc = UIManager.getPortraitSrc(character, msg.emotion);
		if (state.characterImageMode === 'bubble' && imgSrc) {
		  contentHTML = `<img src="${imgSrc}" class="bubble-char-image">` + contentHTML;
		}



        if (character.is_user) {
            bubbleStyle = `background-color: rgba(75, 85, 99, ${state.bubbleOpacity});`;
        } else {
            const charColor = character.color || { base: '#334155', bold: '#94a3b8' };
            const topColor = UTILITY.hexToRgba(charColor.base, state.bubbleOpacity);
            const bottomColor = UTILITY.hexToRgba(UTILITY.darkenHex(charColor.base, 10), state.bubbleOpacity);
            bubbleStyle = `background-image: linear-gradient(to bottom, ${topColor}, ${bottomColor});`;
            characterNameColor = `style="color: ${charColor.bold};"`;
        }
        
        const timestamp = msg.timestamp ? new Date(msg.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) : '';

        return `
            <div class="chat-bubble-container ${msg.isNew ? 'new-message' : ''}" data-message-index="${index}">
                <div class="bubble-header">
                     <p class="font-bold text-sm" ${characterNameColor}>${UTILITY.escapeHTML(character.name)}</p>
                     <span class="timestamp text-xs text-gray-500">${timestamp}</span>
                     <div class="action-btn-group flex ml-2 space-x-4">
                        <button onclick="Controller.copyMessage(${index})" class="text-gray-400 hover:text-white" title="Copy"><svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path></svg></button>
                        <button onclick="Controller.openModal('edit-response-modal', ${index})" class="text-gray-400 hover:text-white" title="Edit"><svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z"></path></svg></button>
                        <button onclick="Controller.deleteMessage(${index})" class="text-gray-400 hover:text-white" title="Delete"><svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg></button>
                    </div>
                </div>
                <div class="bubble-body rounded-lg px-3 py-2" style="${bubbleStyle}">
                    <div id="${contentId}" class="whitespace-pre-wrap" style="color: ${state.chatTextColor}; font-family: ${state.font};">
                        ${contentHTML}
                    </div>
                </div>
            </div>`;
    },

    renderChat() {
        const state = StateManager.getState();
        if (!state || !state.chat_history) {
             document.getElementById('chat-window').innerHTML = `<div class="h-full w-full flex items-center justify-center text-gray-500 text-lg">No Narrative Loaded</div>`;
             return;
        }
        if (this.RUNTIME.streamingInterval) return; 
        
        document.body.dataset.mode = state.characterImageMode;
        this.updateSidePortrait();

		if (state.characterImageMode === 'cinematic_overlay') {
		  let latestAiImageUrl = null;

		  for (let i = state.chat_history.length - 1; i >= 0; i--) {
			const msg = state.chat_history[i];
			if (msg.type !== 'chat' || msg.isHidden) continue;
			const speaker = state.characters.find(c => c.id === msg.character_id);
			if (speaker && !speaker.is_user) {
			  const candidate = UIManager.getPortraitSrc(speaker, msg.emotion);
			  if (candidate) { latestAiImageUrl = candidate; break; }
			}
		  }

		  if (latestAiImageUrl && latestAiImageUrl !== this.RUNTIME.lastCinematicImageUrl) {
			this.RUNTIME.lastCinematicImageUrl = latestAiImageUrl;
			const bg1 = document.getElementById('cinematic-bg-1');
			const bg2 = document.getElementById('cinematic-bg-2');

			if (this.RUNTIME.activeCinematicBg === 1) {
			  bg2.style.backgroundImage = `url('${latestAiImageUrl}')`;
			  bg1.style.opacity = 0;
			  bg2.style.opacity = 1;
			  this.RUNTIME.activeCinematicBg = 2;
			} else {
			  bg1.style.backgroundImage = `url('${latestAiImageUrl}')`;
			  bg1.style.opacity = 1;
			  bg2.style.opacity = 0;
			  this.RUNTIME.activeCinematicBg = 1;
			}
		  } else if (!latestAiImageUrl && this.RUNTIME.lastCinematicImageUrl) {
			// Keep last one visible, as before
			const activeBg = document.getElementById(`cinematic-bg-${this.RUNTIME.activeCinematicBg}`);
			if (activeBg) activeBg.style.backgroundImage = `url('${this.RUNTIME.lastCinematicImageUrl}')`;
		  }
		} else {
		  // existing clear logic unchanged
		  const bg1 = document.getElementById('cinematic-bg-1');
		  const bg2 = document.getElementById('cinematic-bg-2');
		  if (bg1) { bg1.style.backgroundImage = 'none'; bg1.style.opacity = '0'; }
		  if (bg2) { bg2.style.backgroundImage = 'none'; bg2.style.opacity = '0'; }
		  this.RUNTIME.lastCinematicImageUrl = null;
		  this.RUNTIME.activeCinematicBg = 1;
		}

        document.getElementById('chat-window').innerHTML = (state.chat_history || []).map((msg, index) => this._createMessageHTML(msg, index)).join('');
        (state.chat_history || []).forEach(m => m.isNew = false);
		
		const chatWindow = document.getElementById('chat-window');
        chatWindow.innerHTML = (state.chat_history || []).map((msg, index) => this._createMessageHTML(msg, index)).join('');
        (state.chat_history || []).forEach(m => m.isNew = false);

        // --- ROBUST AUTO-SCROLL FIX ---
        // 1. Use setTimeout to yield to the render thread
        setTimeout(() => {
            // 2. Use requestAnimationFrame to ensure layout is calculated
            window.requestAnimationFrame(() => {
                if (chatWindow) {
                    chatWindow.scrollTop = chatWindow.scrollHeight;
                }
            });
        }, 50); // 50ms delay allows images/styles to settle
		
    },
    
    renderExampleDialogueModal() {
        const state = StateManager.getState();
        const container = document.getElementById('example-dialogue-container');
        if (!container) return;

        const userChar = state.characters.find(c => c.is_user);
        const aiChars = state.characters.filter(c => !c.is_user);
        const exampleMessages = state.chat_history.map((msg, index) => ({ ...msg, originalIndex: index })).filter(msg => msg.isHidden === true);

        if (exampleMessages.length === 0) {
            container.innerHTML = `<div class="text-gray-400 text-center">No example dialogue found. Add a turn to start.</div>`;
            return;
        }

        container.innerHTML = exampleMessages.map((msg, idx) => {
            const speakerOptions = [userChar, ...aiChars].map(char => `<option value="${char.id}" ${msg.character_id === char.id ? 'selected' : ''}>${UTILITY.escapeHTML(char.name)}</option>`).join('');
            return `
                <div class="bg-black/20 p-4 rounded-lg flex items-center space-x-4">
                    <div class="flex flex-col space-y-2">
                        <button onclick="Controller.moveExampleDialogueTurn(${msg.originalIndex}, 'up')" ${idx === 0 ? 'disabled' : ''} class="bg-gray-600 hover:bg-gray-500 disabled:bg-gray-700 disabled:opacity-50 text-white font-bold p-2 rounded-lg" title="Move Up"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 15l7-7 7 7"></path></svg></button>
                        <button onclick="Controller.moveExampleDialogueTurn(${msg.originalIndex}, 'down')" ${idx === exampleMessages.length - 1 ? 'disabled' : ''} class="bg-gray-600 hover:bg-gray-500 disabled:bg-gray-700 disabled:opacity-50 text-white font-bold p-2 rounded-lg" title="Move Down"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg></button>
                    </div>
                    <div class="flex-grow flex flex-col space-y-2">
                        <select onchange="Controller.updateExampleDialogueTurn(${msg.originalIndex}, 'character_id', this.value)" class="w-full bg-gray-700 border-gray-600 rounded p-2 text-sm">${speakerOptions}</select>
                        <textarea oninput="Controller.updateExampleDialogueTurn(${msg.originalIndex}, 'content', this.value)" class="w-full bg-gray-900/80 border-gray-600 p-2 resize-none rounded-md">${UTILITY.escapeHTML(msg.content)}</textarea>
                    </div>
                    <button onclick="Controller.deleteExampleDialogueTurn(${msg.originalIndex})" class="flex-shrink-0 bg-red-600/80 hover:bg-red-700/80 text-white font-bold p-2 rounded-lg" title="Delete Turn"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg></button>
                </div>
            `;
        }).join('');

        const textareas = container.querySelectorAll('textarea');
        textareas.forEach(textarea => {
            const autoResize = () => { textarea.style.height = 'auto'; textarea.style.height = `${textarea.scrollHeight}px`; };
            textarea.addEventListener('input', autoResize);
            setTimeout(autoResize, 0);
        });
    },

	updateSidePortrait() {
	  const portraitContainer = document.getElementById('character-portrait-container');
	  if (document.body.classList.contains('layout-vertical')) {
		if (portraitContainer) portraitContainer.innerHTML = '';
		return;
	  }

	  const state = StateManager.getState();
	  if (!portraitContainer || !state || !state.characters || !state.chat_history) {
		if (portraitContainer) portraitContainer.innerHTML = '';
		return;
	  }

	  // Last non-user chat message
	  const lastChatMessages = (state.chat_history || [])
		.filter(m => m.type === 'chat' && !m.isHidden && !state.characters.find(c => c.id === m.character_id)?.is_user);
	  const lastSpeakerMsg = lastChatMessages.length ? lastChatMessages[lastChatMessages.length - 1] : null;
	  const lastSpeaker = lastSpeakerMsg ? state.characters.find(c => c.id === lastSpeakerMsg.character_id) : null;

	  if (!lastSpeaker) {
		portraitContainer.innerHTML = '';
		return;
	  }

	  const mood = lastSpeakerMsg?.emotion || 'neutral';
	  const portraitUrl = UIManager.getPortraitSrc(lastSpeaker, mood);

	  // If we truly have nothing usable (unlikely), clear the container
	  if (!portraitUrl) {
		portraitContainer.innerHTML = '';
		return;
	  }

	  portraitContainer.innerHTML = `<img src="${portraitUrl}" class="max-w-full max-h-full object-contain rounded-lg">`;
	},

startStreamingResponse(charId, fullText, emotion) {
        if (this.RUNTIME.streamingInterval) clearInterval(this.RUNTIME.streamingInterval);
        const state = StateManager.getState();

        const messageIndex = state.chat_history.length;
        state.chat_history.push({ 
            character_id: charId, content: '', type: 'chat', emotion: emotion, 
            timestamp: new Date().toISOString(), isNew: true 
        });

        this.renderChat();
        
        const messageContentEl = document.getElementById(`message-content-${messageIndex}`);
        if (!messageContentEl) {
            console.error("Could not find message element to stream to.");
            return;
        }
        const bubbleEl = messageContentEl.closest('.chat-bubble-container');
        const words = fullText.split(/(\s+)/);
        let wordIndex = 0;

        this.RUNTIME.streamingInterval = setInterval(() => {
            if (wordIndex < words.length) {
                const word = words[wordIndex];
                state.chat_history[messageIndex].content += word;
                
                const userChar = state.characters.find(c => c.is_user);
                const character = state.characters.find(c => c.id === charId);
                const replacer = (text) => text.replace(/{character}/g, character.name).replace(/{user}/g, userChar.name);
                let processedContent = replacer(state.chat_history[messageIndex].content);
                
                // --- FIX ---
                // Replaced the 'boldedContent' logic with the 'styledContent' logic
                // to match the _createMessageHTML function.
                const styledContent = processedContent.replace(/(["][^"]*["])/g, `<span class="dialogue-quote">$1</span>`);
                let fullHTML = marked.parse(styledContent || '');
                // --- END FIX ---
                
				const imgSrc = UIManager.getPortraitSrc(character, state.chat_history[messageIndex].emotion);
				
				if (state.characterImageMode === 'bubble' && imgSrc) {
				  fullHTML = `<img src="${imgSrc}" class="bubble-char-image">` + fullHTML;
				}

                messageContentEl.innerHTML = fullHTML;
                
                const chatWindow = document.getElementById('chat-window');
                const isScrolledToBottom = chatWindow.scrollHeight - chatWindow.clientHeight <= chatWindow.scrollTop + 50;
                if(isScrolledToBottom) {
                     bubbleEl.scrollIntoView({ behavior: 'smooth', block: 'end' });
                }
                wordIndex++;
			} else {
                clearInterval(this.RUNTIME.streamingInterval);
                this.RUNTIME.streamingInterval = null;
                state.chat_history[messageIndex].isNew = false;
                StateManager.saveState();

                // --- NEW: Check for dynamic triggers based on the AI's response ---
                Controller.checkDynamicEntryTriggers(); 
                // ------------------------------------------------------------------

                setTimeout(() => bubbleEl.scrollIntoView({ behavior: 'smooth', block: 'start' }), 100);
            }
        }, 2); // Speed of streaming in inverse.
    },
    
showTypingIndicator(charId, text="is thinking...") { 
        this.hideTypingIndicator(); 
        const chatWindow=document.getElementById('chat-window'); 
        const name = (StateManager.getState().characters || []).find(c => c.id === charId)?.name || 'System'; 
        const indicator = document.createElement('div'); 
        indicator.id = 'typing-indicator'; 

        // --- MODIFICATION ---
        // Use the same container as chat bubbles for correct alignment and width
        indicator.className = 'chat-bubble-container'; 
        indicator.innerHTML = `
            <div class="mb-4 flex flex-col items-start">
                <p class="font-bold text-sm mb-1">${UTILITY.escapeHTML(name)}</p>
                <div class="p-3 bg-gray-700/80 rounded-lg typing-bubble-pulse">
                    <p class="italic">${text}</p>
                </div>
            </div>`;
        // --- END MODIFICATION ---
            
        chatWindow.appendChild(indicator); 
        chatWindow.scrollTop = chatWindow.scrollHeight; 
    },
    
    hideTypingIndicator() { 
        const el = document.getElementById('typing-indicator'); 
        if (el) el.remove(); 
    },
    
applyStyling() { 
        const state = StateManager.getState();
        const backgroundElement = document.getElementById('global-background');
        
		let backgroundUrl = ''; // Default to no background

        // 1. Check for a location-specific image first (highest priority)
        if (state.worldMap && state.worldMap.grid.length > 0) {
            const currentLoc = state.worldMap.grid.find(loc => loc.coords.x === state.worldMap.currentLocation.x && loc.coords.y === state.worldMap.currentLocation.y);
            if (currentLoc) {
                // NEW: Check local cache first
                const locationKey = `location::${currentLoc.coords.x},${currentLoc.coords.y}`;
                UIManager.RUNTIME.worldImageCache = UIManager.RUNTIME.worldImageCache || {};
                
                if (UIManager.RUNTIME.worldImageCache[locationKey]) {
                    backgroundUrl = UIManager.RUNTIME.worldImageCache[locationKey];
                } 
                // FALLBACK: Check legacy URL (if not a local key)
                else if (currentLoc.imageUrl && !currentLoc.imageUrl.startsWith('local_idb_location')) {
                    backgroundUrl = currentLoc.imageUrl;
                }
            }
        }
        
        // 2. If no location image, check for a user-uploaded local background
        if (!backgroundUrl && UIManager.RUNTIME.globalBackgroundImageCache) {
             backgroundUrl = UIManager.RUNTIME.globalBackgroundImageCache;
        }
        // 3. If no local background, fall back to a legacy URL (if it's not our keyword)
        else if (!backgroundUrl && state.backgroundImageURL && state.backgroundImageURL !== 'local_idb_background') {
            backgroundUrl = state.backgroundImageURL;
        }

        backgroundElement.style.backgroundImage = backgroundUrl ? `url('${backgroundUrl}')` : 'none';
        
        document.getElementById('app-container').style.backdropFilter = `blur(${state.backgroundBlur || 0}px)`;
        document.documentElement.style.setProperty('--chat-font-size', `${state.textSize || 16}px`);
        document.documentElement.style.setProperty('--bubble-image-size', `${state.bubbleImageSize || 100}px`);

        const hexToRgb = (hex) => {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        };

        const rgb = hexToRgb(state.chatTextColor);
        if (rgb) {
            document.documentElement.style.setProperty('--border-hue-color', `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.4)`);
        }

        document.documentElement.style.setProperty('--chat-text-color', state.chatTextColor);
        document.documentElement.style.setProperty('--chat-font-family', state.font);
		
        const storyTitleInput = document.getElementById('story-title-input');
        const mobileStoryTitleOverlay = document.getElementById('mobile-story-title-overlay');
        if (storyTitleInput) storyTitleInput.style.color = state.chatTextColor;
        if (mobileStoryTitleOverlay) mobileStoryTitleOverlay.style.color = state.chatTextColor;
		
        this.renderChat();
    },

    renderWorldMapModal() {
        const state = StateManager.getState();
        const { activeWorldMapTab, selectedMapTile, pendingMove } = Controller.RUNTIME;
        const { worldMap } = state;
        const container = document.getElementById('world-map-modal-content');

        let contentHTML = '';
        const isMobile = window.innerHeight > window.innerWidth;

        if (activeWorldMapTab === 'move') {
            const { currentLocation } = worldMap;
            let moveGridHTML = '';
            for (let y = currentLocation.y - 1; y <= currentLocation.y + 1; y++) {
                for (let x = currentLocation.x - 1; x <= currentLocation.x + 1; x++) {
                    const isCenter = x === currentLocation.x && y === currentLocation.y;
                    const location = worldMap.grid.find(loc => loc.coords.x === x && loc.coords.y === y);
					let imageSrc = '';
                    if (location) {
                        const locationKey = `location::${x},${y}`;
                        UIManager.RUNTIME.worldImageCache = UIManager.RUNTIME.worldImageCache || {};
                        
                        if (UIManager.RUNTIME.worldImageCache[locationKey]) {
                            // Use cached local image if available
                            imageSrc = UIManager.RUNTIME.worldImageCache[locationKey];
                        } else if (location.imageUrl && !location.imageUrl.startsWith('local_idb_location')) {
                            // Fallback to legacy URL if it exists and isn't a local key
                            imageSrc = location.imageUrl;
                        }
                    }
                    const bgImage = imageSrc ? `background-image: url('${imageSrc}');` : '';                    let classList = ['aspect-square', 'rounded-lg', 'flex', 'items-end', 'p-2', 'text-white', 'relative', 'overflow-hidden', 'bg-cover', 'bg-center', 'transition-all'];
                    
                    if (isCenter) {
                        classList.push('bg-indigo-800/80', 'ring-2', 'ring-indigo-300');
                    } else if (location) {
                        classList.push('bg-gray-700/80', 'cursor-pointer', 'hover:ring-2', 'hover:ring-sky-400');
                    } else {
                        classList.push('bg-black/50');
                    }

                    if (pendingMove && pendingMove.x === x && pendingMove.y === y && !isCenter) {
                        classList.push('ring-4', 'ring-yellow-400');
                    }

                    if (location) {
                        moveGridHTML += `<div 
                            class="${classList.join(' ')}"
                            style="${bgImage}"
                            ${!isCenter ? `onclick="Controller.selectPendingMove(${x}, ${y})"` : ''}>
                            <div class="absolute inset-0 bg-gradient-to-t from-black/80 to-transparent"></div>
                            <span class="relative z-10 text-sm font-bold">${UTILITY.escapeHTML(location.name)}</span>
                        </div>`;
                    } else {
                        moveGridHTML += `<div class="${classList.join(' ')}"></div>`;
                    }
                }
            }

            let detailsHTML = '';
            const pendingLocation = pendingMove ? worldMap.grid.find(l => l.coords.x === pendingMove.x && l.coords.y === pendingMove.y) : null;
            if (pendingLocation) {
                 detailsHTML = `
                    <h3 class="text-2xl font-bold">${UTILITY.escapeHTML(pendingLocation.name)}</h3>
                    <p class="text-gray-400 mt-2 flex-grow">${UTILITY.escapeHTML(pendingLocation.description)}</p>
                    <button onclick="Controller.confirmMove()" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg mt-4">Confirm Move</button>
                `;
            } else {
                 const currentLocationData = worldMap.grid.find(l => l.coords.x === currentLocation.x && l.coords.y === currentLocation.y);
                 detailsHTML = `
                    <h3 class="text-2xl font-bold">Movement</h3>
                    <p class="text-gray-400 mt-2">You are currently at <strong>${UTILITY.escapeHTML(currentLocationData.name)}</strong>.</p>
                    <p class="text-gray-400 mt-2">Select an adjacent tile to see its details and confirm your move.</p>
                `;
            }

             contentHTML = `<div class="p-6 flex-grow grid grid-cols-1 md:grid-cols-2 gap-6 items-center">
                <div class="grid grid-cols-3 gap-2">${moveGridHTML}</div>
                <div class="flex flex-col h-full">${detailsHTML}</div>
            </div>`;

        } else { // 'worldmap' tab
            const { currentLocation, destination, path } = worldMap;
            let mapGridHTML = '';
            for (let y = 0; y < 8; y++) {
                for (let x = 0; x < 8; x++) {
                    const location = worldMap.grid.find(loc => loc.coords.x === x && loc.coords.y === y);
                    let classList = ['aspect-square', 'rounded', 'bg-gray-800/80', 'hover:bg-gray-700/80', 'cursor-pointer', 'text-xs', 'p-1', 'overflow-hidden', 'leading-tight'];
                    
                    if (currentLocation.x === x && currentLocation.y === y) classList.push('ring-2', 'ring-green-400');
                    if (destination && destination.x === x && destination.y === y) classList.push('ring-2', 'ring-red-500');
                    if (path && path.some(p => p.x === x && p.y === y)) classList.push('bg-sky-700/50');
                    if (selectedMapTile && selectedMapTile.coords.x === x && selectedMapTile.coords.y === y) classList.push('ring-2', 'ring-yellow-300');

                    mapGridHTML += `<div class="${classList.join(' ')}" onclick="Controller.selectMapTile(${x}, ${y})">${location ? UTILITY.escapeHTML(location.name) : ''}</div>`;
                }
            }

            let detailsHTML = `<div class="h-full flex items-center justify-center text-gray-500">Select a tile to view details.</div>`;
            if (selectedMapTile) {
                detailsHTML = `
                    <div class="h-full flex flex-col space-y-3">
                        <div><label class="text-sm text-gray-400">Name</label><input type="text" value="${UTILITY.escapeHTML(selectedMapTile.name)}" oninput="Controller.updateLocationDetail('name', this.value)" class="w-full bg-black/30 border-gray-600 p-2 rounded"></div>

                        <div>
                            <label class="text-sm text-gray-400 mt-2 block">Upload Local Image</label>
                            <span class="text-xs text-gray-500 mb-2 block">Current: ${selectedMapTile.imageUrl.startsWith('local_idb_location') ? '[Local Image]' : (selectedMapTile.imageUrl ? '[Legacy URL]' : 'None')}</span>
                            <input type="file" accept="image/*" onchange="Controller.handleWorldMapLocationImageUpload(event, ${selectedMapTile.coords.x}, ${selectedMapTile.coords.y})" class="mt-1 block w-full text-sm text-gray-400 file:mr-4 file:py-1 file:px-3 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-gray-700 file:text-gray-200 hover:file:bg-gray-600 cursor-pointer">
                        </div>
                        <div><label class="text-sm text-gray-400">Brief Description</label><textarea oninput="Controller.updateLocationDetail('description', this.value)" class="w-full bg-black/30 border-gray-600 p-2 rounded h-20 resize-none">${UTILITY.escapeHTML(selectedMapTile.description)}</textarea></div>
                        <div class="flex-grow flex flex-col">
                            <label class="text-sm text-gray-400">Full Prompt</label>
                            <div class="relative flex-grow">
                                <textarea oninput="Controller.updateLocationDetail('prompt', this.value)" class="w-full h-full bg-black/30 border-gray-600 p-2 rounded resize-none">${UTILITY.escapeHTML(selectedMapTile.prompt)}</textarea>
                                <button onclick="Controller.generateLocationPromptAI(event)" class="absolute top-2 right-2 text-sky-400 hover:text-sky-300 p-1 bg-sky-600/80 rounded" title="Generate with AI">${this.getAIGenIcon()}</button>
                            </div>
                        </div>
                        <div class="flex gap-2">
                           <button onclick="Controller.setDestination()" class="w-full bg-sky-600 hover:bg-sky-700 text-white font-bold py-2 px-4 rounded-lg">Set Destination</button>
                           <button onclick="if(confirm('This will immediately move you to this location. Proceed?')) { Controller.moveToLocation(${selectedMapTile.coords.x}, ${selectedMapTile.coords.y}); Controller.closeModal('world-map-modal'); }" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg">Jump To</button>
                        </div>
                    </div>`;
            }

            const gridLayoutClass = isMobile ? 'grid-cols-1' : 'grid-cols-3';
            const detailsWrapperClass = isMobile ? 'h-64 overflow-y-auto' : 'flex flex-col';

            contentHTML = `<div class="p-6 flex-grow grid ${gridLayoutClass} gap-6 h-full min-h-0">
                <div class="col-span-2 grid grid-cols-8 gap-1">${mapGridHTML}</div>
                <div class="col-span-1 bg-black/30 rounded-lg p-4 ${detailsWrapperClass}">${detailsHTML}</div>
            </div>`;
        }

        container.innerHTML = `
            <div class="p-6 pb-0 flex justify-between items-center border-b border-gray-700">
                <div class="flex">
                    <button id="world-map-tab-move" onclick="Controller.switchWorldMapTab('move')" class="py-3 px-4 font-semibold text-lg ${activeWorldMapTab === 'move' ? 'border-b-2 border-indigo-500 text-white' : 'border-b-2 border-transparent text-gray-400 hover:text-white'}">Move</button>
                    <button id="world-map-tab-worldmap" onclick="Controller.switchWorldMapTab('worldmap')" class="py-3 px-4 font-semibold text-lg ${activeWorldMapTab === 'worldmap' ? 'border-b-2 border-indigo-500 text-white' : 'border-b-2 border-transparent text-gray-400 hover:text-white'}">World Map</button>
                </div>
                <button id="generate-world-button" onclick="Controller.generateWorldMap(event)" class="bg-sky-600 hover:bg-sky-700 text-white font-bold py-2 px-3 rounded-lg ml-4 flex-shrink-0">${this.getAIGenIcon()}</button>
            </div>
            ${contentHTML}
            <div class="p-4 bg-black/20 border-t border-gray-700 flex justify-end">
                <button onclick="Controller.closeModal('world-map-modal')" class="bg-gray-600 hover:bg-gray-700 font-bold py-2 px-4 rounded-lg">Done</button>
            </div>`;

        if (activeWorldMapTab === 'worldmap' && selectedMapTile) {
            const detailsContainer = container.querySelector('.col-span-1');
            detailsContainer.innerHTML += `
                <hr class="border-gray-600 my-4">
                <div class="flex-grow flex flex-col min-h-0">
                    <div class="flex justify-between items-center mb-2">
                        <h4 class="font-bold text-lg">Local Static Memory</h4>
                        <button onclick="Controller.addLocalStaticEntry()" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-1 px-2 rounded-lg text-sm">Add</button>
                    </div>
                    <div class="grid grid-cols-3 gap-4 flex-grow min-h-0">
                        <div id="local-static-entries-list" class="col-span-1 bg-black/40 rounded-lg p-2 overflow-y-auto"></div>
                        <div id="local-static-entry-details" class="col-span-2 flex flex-col"></div>
                    </div>
                </div>`;
            this.renderLocalStaticEntriesList();
            this.renderLocalStaticEntryDetails();
        }
    },

    renderLocalStaticEntriesList() {
        const { selectedMapTile, selectedLocalStaticEntryId } = Controller.RUNTIME;
        const container = document.getElementById('local-static-entries-list');
        if (!container || !selectedMapTile) return;

        const entries = selectedMapTile.local_static_entries || [];
        container.innerHTML = entries.map(entry => `
            <div onclick="Controller.selectLocalStaticEntry('${entry.id}')" 
                 class="p-2 rounded-md cursor-pointer ${selectedLocalStaticEntryId === entry.id ? 'bg-indigo-600' : 'hover:bg-indigo-600/50'}">
                <h5 class="font-semibold truncate text-sm">${UTILITY.escapeHTML(entry.title)}</h5>
            </div>
        `).join('');
    },

    renderLocalStaticEntryDetails() {
        const { selectedMapTile, selectedLocalStaticEntryId } = Controller.RUNTIME;
        const container = document.getElementById('local-static-entry-details');
        if (!container || !selectedMapTile) return;

        const entry = (selectedMapTile.local_static_entries || []).find(e => e.id === selectedLocalStaticEntryId);

        if (entry) {
            container.innerHTML = `
                <input type="text" value="${UTILITY.escapeHTML(entry.title)}" oninput="Controller.updateLocalStaticEntryField('${entry.id}', 'title', this.value)" class="font-bold bg-black/30 p-2 w-full mb-2 text-sm rounded-md">
                <textarea oninput="Controller.updateLocalStaticEntryField('${entry.id}', 'content', this.value)" class="w-full flex-grow bg-black/30 p-2 resize-none text-sm rounded-md">${UTILITY.escapeHTML(entry.content)}</textarea>
                <div class="flex justify-end mt-2">
                    <button onclick="Controller.deleteLocalStaticEntry('${entry.id}')" class="text-xs bg-red-600/80 hover:bg-red-700/80 font-semibold py-1 px-2 rounded-lg">Delete</button>
                </div>`;
        } else {
            container.innerHTML = `<div class="text-gray-500 flex items-center justify-center h-full text-sm">Select an entry.</div>`;
        }
    },

getPortraitSrc(character, mood) {
	  const cache = UIManager.RUNTIME.characterImageCache || {};

	  const emoKey = mood ? `${character.id}::emotion::${mood}` : null;
	  if (emoKey && cache[emoKey]) return cache[emoKey];

	  // Base portrait (IDB-backed cache)
	  if (cache[character.id]) return cache[character.id];

	  // Legacy URL (pre-IDB) - Make sure it's not our local keyword
	  if (character.image_url && !character.image_url.startsWith('local_idb_')) {
          return character.image_url;
      }

	  // Return null instead of placeholder
	  return null;
	},

	openCharacterDetailModal(charId) {
        const state = StateManager.getState();
        const char = state.characters.find(c => c.id === charId);
        if (!char) return;
        const container = document.getElementById('character-detail-modal-content');
        
        // Determine current role for UI state
        let currentRole = 'none';
        if (char.is_user) currentRole = 'user';
        else if (char.is_narrator) currentRole = 'narrator';

        const extraPortraitsHTML = (char.extra_portraits || []).map((portrait, index) => {
             // ... (Keep existing extraPortraitsHTML logic exactly as is) ...
             const emo = portrait.emotion || 'happy';
             const fileInputId = `emo-file-${char.id}-${index}`;
             const urlInputId  = `emo-url-${char.id}-${index}`;
             const labelId     = `emo-label-${char.id}-${index}`;
             const cached = (UIManager.RUNTIME.characterImageCache || {})[`${char.id}::emotion::${emo}`];
             const hint   = cached ? '[local image]' : (portrait.url ? '[url]' : '[none]');
             return `
                <div class="flex flex-col space-y-2 mt-2 p-2 rounded border border-gray-700/50">
                    <div class="flex items-center space-x-2">
                        <select onchange="Controller.updateExtraPortrait('${char.id}', ${index}, 'emotion', this.value)" class="w-1/3 bg-black/30 border-gray-600 rounded p-1 text-sm">
                            <option value="happy" ${emo === 'happy' ? 'selected' : ''}>Happy</option>
                            <option value="sad" ${emo === 'sad' ? 'selected' : ''}>Sad</option>
                            <option value="angry" ${emo === 'angry' ? 'selected' : ''}>Angry</option>
                            <option value="surprised" ${emo === 'surprised' ? 'selected' : ''}>Surprised</option>
                            <option value="neutral" ${emo === 'neutral' ? 'selected' : ''}>Neutral</option>
                        </select>
                        <input id="${urlInputId}" type="text" value="${UTILITY.escapeHTML(portrait.url || '')}" oninput="Controller.updateExtraPortrait('${char.id}', ${index}, 'url', this.value)" class="w-2/3 bg-black/30 border-gray-600 p-1 text-sm" placeholder="Image URL">
                        <button onclick="Controller.removeExtraPortrait('${char.id}', ${index})" class="text-red-400 hover:text-red-300">X</button>
                    </div>
                    <div class="flex items-center justify-between">
                        <label class="text-sm text-gray-400" for="${fileInputId}">Upload local image for <span class="font-semibold">${emo}</span>:</label>
                        <span id="${labelId}" class="text-xs text-gray-400">${hint}</span>
                    </div>
                    <input id="${fileInputId}" type="file" accept="image/*" onchange="Controller.handleLocalEmotionImageUpload(event, '${char.id}', ${index})" class="block w-full text-sm text-gray-400 file:mr-4 file:py-1 file:px-3 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-gray-700 file:text-gray-200 hover:file:bg-gray-600 cursor-pointer">
                </div>`;
        }).join('');

        const tagsValue = (char.tags || []).join(', ');
        const color = char.color || { base: '#334155', bold: '#94a3b8' };

        const modalHTML = `
            <div class="p-6 border-b border-gray-700 flex flex-col md:flex-row justify-between items-start md:items-center gap-4">
                <div>
                    <h2 class="text-2xl font-semibold" data-char-id="${char.id}">${UTILITY.escapeHTML(char.name)}</h2>
                    <div class="flex items-center space-x-2 mt-1">
                        <span class="text-sm text-gray-400">Active in this chat</span>
                        <label class="relative inline-flex items-center cursor-pointer">
                            <input type="checkbox" class="sr-only peer" ${char.is_active ? 'checked' : ''} onchange="Controller.toggleCharacterActive(event, '${char.id}')">
                            <div class="w-9 h-5 bg-gray-700 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-4 after:w-4 after:transition-all peer-checked:bg-indigo-600"></div>
                        </label>
                    </div>
                </div>
                
                <div class="flex bg-black/40 rounded-lg p-1">
                    <button onclick="Controller.setCharacterRole('${char.id}', 'user')" class="px-3 py-1 rounded-md text-sm font-bold transition-colors ${currentRole === 'user' ? 'bg-indigo-600 text-white shadow' : 'text-gray-400 hover:text-gray-200'}">User</button>
                    <button onclick="Controller.setCharacterRole('${char.id}', 'none')" class="px-3 py-1 rounded-md text-sm font-bold transition-colors ${currentRole === 'none' ? 'bg-gray-600 text-white shadow' : 'text-gray-400 hover:text-gray-200'}">NPC</button>
                    <button onclick="Controller.setCharacterRole('${char.id}', 'narrator')" class="px-3 py-1 rounded-md text-sm font-bold transition-colors ${currentRole === 'narrator' ? 'bg-teal-600 text-white shadow' : 'text-gray-400 hover:text-gray-200'}">Narrator</button>
                </div>
            </div>

            <div class="p-6 overflow-y-auto space-y-4">
                <details open>
                    <summary class="font-semibold text-lg cursor-pointer hover:text-indigo-300">Primary Info</summary>
                    <div class="p-4 space-y-4 bg-black/20 rounded-b-lg">
                        <input type="text" value="${UTILITY.escapeHTML(char.name)}" oninput="Controller.updateCharacterField('${char.id}', 'name', this.value)" class="w-full bg-black/30 border-gray-600 p-2 rounded text-lg" placeholder="Character Name">
                        <div><label class="text-sm text-gray-400">Short Description (for roster card)</label><input type="text" value="${UTILITY.escapeHTML(char.short_description)}" oninput="Controller.updateCharacterField('${char.id}', 'short_description', this.value)" class="w-full bg-black/30 border-gray-600 p-2 rounded"></div>
                        <div>
                            <label class="text-sm text-gray-400">Default Image</label>
                            <input type="text" value="${UTILITY.escapeHTML(char.image_url)}" oninput="Controller.updateCharacterField('${char.id}', 'image_url', this.value)" class="w-full bg-black/30 border-gray-600 p-2 rounded mb-2" placeholder="Paste URL...">
                            <input type="file" accept="image/*" onchange="Controller.handleLocalImageUpload(event, '${char.id}')" class="block w-full text-sm text-gray-400 file:mr-4 file:py-1 file:px-3 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-gray-700 file:text-gray-200 hover:file:bg-gray-600 cursor-pointer">
                        </div>
                        <div class="grid grid-cols-2 gap-4">
                            <div><label class="text-sm text-gray-400">Bubble Base Color</label><input type="color" value="${color.base}" oninput="Controller.updateCharacterColor('${char.id}', 'base', this.value)" class="w-full h-10 p-1 bg-black/30 border-gray-600 rounded"></div>
                            <div><label class="text-sm text-gray-400">Name Color</label><input type="color" value="${color.bold}" oninput="Controller.updateCharacterColor('${char.id}', 'bold', this.value)" class="w-full h-10 p-1 bg-black/30 border-gray-600 rounded"></div>
                        </div>
                        <div><label class="text-sm text-gray-400">Tags (comma-separated)</label><input type="text" value="${tagsValue}" oninput="Controller.updateCharacterTags('${char.id}', this.value)" class="w-full bg-black/30 border-gray-600 p-2 rounded"><button onclick="Controller.generateTagsForCharacter(event, '${char.id}')" class="text-xs text-sky-400 hover:text-sky-300 mt-1 p-1 bg-sky-600/80 rounded">${this.getAIGenIcon()}</button></div>
                    </div>
                </details>
                <details>
                    <summary class="font-semibold text-lg cursor-pointer hover:text-indigo-300">Persona</summary>
                    <div class="p-4 space-y-4 bg-black/20 rounded-b-lg">
                         <textarea id="persona-description-${char.id}" oninput="Controller.updateCharacterField('${char.id}', 'description', this.value); UIManager.updateTokenCount('${char.id}', this.value)" class="w-full h-48 bg-black/30 border-gray-600 p-2 resize-y rounded">${UTILITY.escapeHTML(char.description)}</textarea>
                         <div class="flex justify-between items-center"><span class="text-right text-sm text-gray-400" id="token-counter-${char.id}">~${Math.round((char.description || '').length / 4)} tokens</span><button onclick="Controller.enhancePersonaWithAI(event, '${char.id}')" class="text-sm bg-sky-600/80 hover:bg-sky-500/80 font-semibold py-2 px-3 rounded-lg">${this.getAIGenIcon()}</button></div>
                    </div>
                </details>
                <details>
                    <summary class="font-semibold text-lg cursor-pointer hover:text-indigo-300">Model Instructions</summary>
                    <div class="p-4 space-y-4 bg-black/20 rounded-b-lg">
                         <textarea oninput="Controller.updateCharacterField('${char.id}', 'model_instructions', this.value)" class="w-full h-48 bg-black/30 border-gray-600 p-2 resize-y rounded">${UTILITY.escapeHTML(char.model_instructions)}</textarea>
                         <div class="text-right"><button onclick="Controller.generateModelInstructions(event, '${char.id}')" class="text-sm bg-sky-600/80 hover:bg-sky-700/80 font-semibold py-2 px-3 rounded-lg">${this.getAIGenIcon()}</button></div>
                    </div>
                </details>
                <details>
                    <summary class="font-semibold text-lg cursor-pointer hover:text-indigo-300">Emotional Portraits</summary>
                    <div class="p-4 space-y-2 bg-black/20 rounded-b-lg">
                        <div id="extra-portraits-${char.id}">${extraPortraitsHTML}</div>
                        <button onclick="Controller.addExtraPortrait('${char.id}')" class="text-sm text-sky-400 hover:text-sky-300 mt-2">+ Add Emotional Portrait</button>
                    </div>
                </details>
            </div>
            <div class="p-4 bg-black/20 border-t border-gray-700 flex justify-between">
                <button onclick="if(confirm('Are you sure you want to delete this character?')) Controller.deleteCharacter('${char.id}')" class="bg-red-600/80 hover:bg-red-700/80 font-bold py-2 px-4 rounded-lg">Delete</button>
                <button onclick="Controller.closeModal('character-detail-modal')" class="bg-gray-600 hover:bg-gray-700 font-bold py-2 px-4 rounded-lg">Done</button>
            </div>
        `;
        container.innerHTML = modalHTML;

        container.querySelectorAll('textarea').forEach(textarea => {
            const autoResize = () => { textarea.style.height = 'auto'; textarea.style.height = `${textarea.scrollHeight}px`; };
            textarea.addEventListener('input', autoResize);
            setTimeout(autoResize, 0);
        });
    },

    updateTokenCount(charId, text) { 
        const counter = document.getElementById(`token-counter-${charId}`); 
        if (counter) counter.textContent = `~${Math.round((text || '').length / 4)} tokens`; 
    },

    updateAICharacterSelector() {
        const state = StateManager.getState();
        const selector = document.getElementById('ai-character-selector');
        if (!state || !state.characters) {
            selector.innerHTML = '';
            return;
        }

        const activeAiChars = state.characters.filter(c => !c.is_user && c.is_active);
        
        if (activeAiChars.length <= 1) {
            selector.style.display = 'none';
        } else {
            selector.style.display = 'block';
        }

        const currentValue = selector.value;
        let optionsHTML = `<option value="any">Any</option>`;
        optionsHTML += activeAiChars.map(c => `<option value="${c.id}">${UTILITY.escapeHTML(c.name)}</option>`).join('');
        selector.innerHTML = optionsHTML;
        
        if (currentValue && selector.querySelector(`option[value="${currentValue}"]`)) {
            selector.value = currentValue;
        }
    },

    // --- NEW & MODIFIED UI Functions for Import/Export ---

    /**
     * Renders the centralized Import/Export Hub modal.
     */
/**
     * Renders the centralized Import/Export Hub modal.
     * [REVISED] This now points the main library I/O buttons to
     * the new ZIP-based Controller functions.
     */
    renderIOHubModal() {
        // Get the container for the modal content
        const modalContent = document.getElementById('io-hub-modal-content');
        
        // Get all stories from the StateManager's in-memory list for the dropdown
        const library = StateManager.getLibrary();
        const storyOptions = library.stories
            .map(s => `<option value="${s.id}">${UTILITY.escapeHTML(s.name)}</option>`)
            .join('');

        // Define the inner HTML for the modal
        const hubHTML = `
            <div class="p-6 border-b border-gray-700">
                <h2 class="text-2xl font-semibold">Import / Export Hub</h2>
            </div>
            <div class="p-6 overflow-y-auto">
                <div class="grid md:grid-cols-2 gap-8">
                    
                    <!-- === IMPORT COLUMN === -->
                    <div class="space-y-6">
                        <h3 class="text-xl font-bold border-b pb-2 border-gray-600">Import</h3>
                        
                        <!-- Single Story Import (Unchanged) -->
                        <div>
                            <p class="text-sm text-gray-300 mb-2">Import a single Story from a V2 PNG, BYAF, or Ellipsis JSON file.</p>
                            <label for="single-file-upload" class="cursor-pointer">
                                <div class="border-2 border-dashed border-gray-500 rounded-lg p-6 text-center bg-black/20 hover:bg-black/40">
                                    <p class="font-semibold text-indigo-300">Click to upload a file</p>
                                    <p class="text-xs text-gray-400 mt-1">.png, .byaf, .zip, .json</p>
                                </div>
                            </label>
                            <input id="single-file-upload" type="file" class="hidden" accept=".png,.byaf,.zip,.json" onchange="Controller.handleFileUpload(event)">
                        </div>

                        <!-- Bulk Import (Unchanged) -->
                        <div>
                            <p class="text-sm text-gray-300 mb-2">Import an entire folder of V2 PNG or BYAF files at once.</p>
                            <button onclick="Controller.handleBulkImport()" class="w-full mt-2 bg-teal-600/80 hover:bg-teal-700/80 text-white font-bold py-2 px-4 rounded-lg">Select Folder to Import</button>
                        </div>

                        <!-- [REVISED] Full Library Import -->
                        <div>
                            <p class="text-sm text-gray-300 mb-2">Replace your current library with an Ellipsis Library ZIP file. <span class="font-bold text-red-400">Warning: This is a destructive action.</span></p>
                            <label class="w-full mt-2 bg-red-800/80 hover:bg-red-900/80 text-white font-bold py-2 px-4 rounded-lg inline-block text-center cursor-pointer">
                                <span>Import Library (ZIP)</span>
                                <!-- We accept .zip and point to the new Controller.importLibrary function -->
                                <input type="file" class="hidden" accept=".zip" onchange="Controller.importLibrary(event)">
                            </label>
                        </div>
                    </div>

                    <!-- === EXPORT COLUMN === -->
                    <div class="space-y-4">
                        <h3 class="text-xl font-bold border-b pb-2 border-gray-600">Export</h3>
                        
                        <!-- Single Story/Narrative Export (Unchanged) -->
                        <div>
                            <label for="story-export-selector" class="block text-sm font-medium text-gray-300">1. Select Story to Export</label>
                            <select id="story-export-selector" class="w-full mt-1 bg-black/30 p-2 rounded-lg border-gray-600" onchange="UIManager.populateNarrativeSelector()">
                                <option value="">-- Select a Story --</option>
                                ${storyOptions}
                            </select>
                        </div>
                        <div>
                            <label for="narrative-export-selector" class="block text-sm font-medium text-gray-300">2. Select Narrative</label>
                            <select id="narrative-export-selector" class="w-full mt-1 bg-black/30 p-2 rounded-lg border-gray-600" onchange="UIManager.populateCharacterSelector()"></select>
                        </div>
                        <div id="character-export-selector-container" class="hidden">
                            <label for="character-export-selector" class="block text-sm font-medium text-gray-300">3. Select Primary Character (for V2/BYAF)</label>
                            <select id="character-export-selector" class="w-full mt-1 bg-black/30 p-2 rounded-lg border-gray-600"></select>
                        </div>
                        <div>
                            <p class="block text-sm font-medium text-gray-300 mt-2">4. Choose Export Format</p>
                            <div class="grid grid-cols-3 gap-2 mt-2">
                                <button onclick="Controller.exportStoryAs('json')" class="bg-indigo-600/80 hover:bg-indigo-700/80 text-white font-bold py-2 px-3 rounded-lg">JSON</button>
                                <button onclick="Controller.exportStoryAs('png')" class="bg-sky-600/80 hover:bg-sky-700/80 text-white font-bold py-2 px-3 rounded-lg">V2 PNG</button>
                                <button onclick="Controller.exportStoryAs('byaf')" class="bg-emerald-600/80 hover:bg-emerald-700/80 text-white font-bold py-2 px-3 rounded-lg">BYAF</button>
                            </div>
                        </div>
                         
                         <!-- [REVISED] Full Library Export -->
                         <hr class="border-gray-600 !mt-8">
                        <div>
                            <p class="text-sm text-gray-300 mb-2">Save a backup of your entire library, including all images.</p>
                            <!-- This button now points to the new Controller.exportLibrary function -->
                            <button onclick="Controller.exportLibrary()" class="w-full mt-2 bg-gray-600/80 hover:bg-gray-700/80 text-white font-bold py-2 px-4 rounded-lg">Export Library (ZIP)</button>
                        </div>
                    </div>
                </div>
            </div>
            <div class="p-4 bg-black/20 border-t border-gray-700 flex justify-end">
                <button onclick="Controller.closeModal('io-hub-modal')" class="bg-gray-600 hover:bg-gray-700 font-bold py-2 px-4 rounded-lg">Close</button>
            </div>
        `;
        
        // Set the modal content and populate the first dropdown
        modalContent.innerHTML = hubHTML;
        this.populateNarrativeSelector();
    },

    /** Populates the narrative selector dropdown based on the selected story. */
    populateNarrativeSelector() {
        const storyId = document.getElementById('story-export-selector').value;
        const narrativeSelector = document.getElementById('narrative-export-selector');
        narrativeSelector.innerHTML = '';
        if (storyId) {
            const story = StateManager.getLibrary().stories.find(s => s.id === storyId);
            if (story && story.narratives) {
                narrativeSelector.innerHTML = story.narratives.map(n => `<option value="${n.id}">${UTILITY.escapeHTML(n.name)}</option>`).join('');
            }
        }
        this.populateCharacterSelector();
    },

    /** Populates the character selector dropdown for V2/BYAF exports. */
    populateCharacterSelector() {
        const storyId = document.getElementById('story-export-selector').value;
        const charContainer = document.getElementById('character-export-selector-container');
        const charSelector = document.getElementById('character-export-selector');
        charSelector.innerHTML = '';
        if (storyId) {
            const story = StateManager.getLibrary().stories.find(s => s.id === storyId);
            const aiChars = story.characters.filter(c => !c.is_user);
            if (aiChars.length > 0) {
                charSelector.innerHTML = aiChars.map(c => `<option value="${c.id}">${UTILITY.escapeHTML(c.name)}</option>`).join('');
                charContainer.classList.remove('hidden');
            } else {
                charContainer.classList.add('hidden');
            }
        } else {
            charContainer.classList.add('hidden');
        }
    },

    /**
     * Displays a confirmation modal that returns a Promise, allowing for async/await usage.
     * @param {string} message - The message to display.
     * @returns {Promise<boolean>} - A promise that resolves to true if confirmed, false if canceled.
     */
    showConfirmationPromise(message) {
        return new Promise((resolve) => {
            const modal = document.getElementById('confirmation-modal');
            const messageEl = document.getElementById('confirmation-modal-message');
            const confirmBtn = document.getElementById('confirmation-modal-confirm-button');
            const cancelBtn = modal.querySelector('button:not(#confirmation-modal-confirm-button)');
            
            messageEl.textContent = message;
            
            const confirmClickHandler = () => {
                cleanup();
                resolve(true);
            };
            const cancelClickHandler = () => {
                cleanup();
                resolve(false);
            };

            const cleanup = () => {
                confirmBtn.removeEventListener('click', confirmClickHandler);
                cancelBtn.removeEventListener('click', cancelClickHandler);
                modal.querySelector('.modal-overlay').removeEventListener('click', cancelClickHandler);
                Controller.closeModal('confirmation-modal');
            };
            
            confirmBtn.addEventListener('click', confirmClickHandler, { once: true });
            cancelBtn.addEventListener('click', cancelClickHandler, { once: true });
            modal.querySelector('.modal-overlay').addEventListener('click', cancelClickHandler, { once: true });

            Controller.openModal('confirmation-modal');
        });
    },

    /** Displays a full-screen loading spinner with a message. */
    showLoadingSpinner(message = 'Loading...') {
        let spinner = document.getElementById('loading-spinner');
        if (!spinner) {
            spinner = document.createElement('div');
            spinner.id = 'loading-spinner';
            spinner.className = 'fixed inset-0 z-[80] bg-black/60 backdrop-blur-sm flex flex-col items-center justify-center';
            spinner.innerHTML = `
                <div class="w-16 h-16 border-4 border-t-indigo-500 border-gray-600 rounded-full animate-spin"></div>
                <p id="spinner-message" class="mt-4 text-white font-semibold"></p>
            `;
            document.body.appendChild(spinner);
        }
        document.getElementById('spinner-message').textContent = message;
        spinner.style.display = 'flex';
    },

    /** Hides the loading spinner. */
    hideLoadingSpinner() {
        const spinner = document.getElementById('loading-spinner');
        if (spinner) {
            spinner.style.display = 'none';
        }
    },

    /**
     * Displays a report modal after a bulk import is complete.
     * @param {string[]} importedStoryNames - A list of names of successfully imported stories.
     * @param {Array<{name: string, reason: string}>} failedFiles - A list of files that failed to import.
     */
    showBulkImportReport(importedStoryNames, failedFiles) {
        const container = document.getElementById('report-modal-content');
        let reportHTML = `
            <div class="p-6 border-b border-gray-700"><h2 class="text-2xl font-semibold">Bulk Import Report</h2></div>
            <div class="p-6 overflow-y-auto space-y-4">
                <div>
                    <h3 class="font-bold text-lg text-green-400">Success (${importedStoryNames.length})</h3>
                    <ul class="list-disc list-inside text-sm mt-2 max-h-40 overflow-y-auto bg-black/20 p-2 rounded-md">
                        ${importedStoryNames.map(name => `<li>${UTILITY.escapeHTML(name)}</li>`).join('') || '<li>No stories were imported successfully.</li>'}
                    </ul>
                </div>
        `;

        if (failedFiles.length > 0) {
            const logContent = failedFiles.map(f => `File: ${f.name}\nReason: ${f.reason}\n---`).join('\n');
            const logBlob = new Blob([logContent], { type: 'text/plain' });
            const logUrl = URL.createObjectURL(logBlob);

            reportHTML += `
                <div>
                    <h3 class="font-bold text-lg text-red-400">Failures (${failedFiles.length})</h3>
                    <p class="text-sm mt-2">Some files could not be imported. <a href="${logUrl}" download="import_error_log.txt" class="text-indigo-400 hover:underline">Download Error Log</a> for details.</p>
                </div>
            `;
        }
        
        reportHTML += `</div>
            <div class="p-4 bg-black/20 border-t border-gray-700 flex justify-end">
                <button onclick="Controller.closeModal('report-modal')" class="bg-gray-600 hover:bg-gray-700 font-bold py-2 px-4 rounded-lg">Done</button>
            </div>
        `;
        
        container.innerHTML = reportHTML;
        Controller.openModal('report-modal');
    },

    /**
     * Displays a generic confirmation modal. (Kept for simple, non-async confirmations).
     * @param {string} message - The message to display in the modal body.
     * @param {function} onConfirmCallback - The function to execute when the confirm button is clicked.
     */
    showConfirmationModal(message, onConfirmCallback) {
        const modal = document.getElementById('confirmation-modal');
        const messageEl = document.getElementById('confirmation-modal-message');
        const confirmBtn = document.getElementById('confirmation-modal-confirm-button');
        
        if (modal && messageEl && confirmBtn) {
            messageEl.textContent = message;
            
            const newConfirmBtn = confirmBtn.cloneNode(true);
            confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);

            newConfirmBtn.onclick = () => {
                onConfirmCallback();
                Controller.closeModal('confirmation-modal');
            };
            Controller.openModal('confirmation-modal');
        } else {
            console.error("Confirmation modal elements not found.");
        }
    },

    /**
     * Changes the primary action button to "Stop Generation" mode.
     */
    setButtonToStopMode() {
        const button = document.getElementById('primary-action-btn');
        if (!button) return;
        button.onclick = () => Controller.stopGeneration();
        button.title = "Stop Generation";
        button.classList.remove('bg-indigo-600/50', 'hover:bg-indigo-600/80');
        button.classList.add('bg-red-700/60', 'hover:bg-red-700/80');
        button.innerHTML = `<svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M4 4a2 2 0 012-2h8a2 2 0 012 2v8a2 2 0 01-2 2H6a2 2 0 01-2-2V4zm2 0h8v8H6V4z" clip-rule="evenodd" /></svg>`;
		
        // [FIX] Use setTimeout to defer attaching the new event handler.
        // This prevents a race condition where the initial click also triggers the stop function.
        setTimeout(() => {
            button.onclick = () => Controller.stopGeneration();
        }, 0);
    },

    /**
     * Reverts the primary action button to its default "Send / Write for Me" mode.
     */
    setButtonToSendMode() {
        const button = document.getElementById('primary-action-btn');
        if (!button) return;
        button.onclick = () => Controller.handlePrimaryAction();
        button.title = "Send / Write for Me";
        button.classList.remove('bg-red-700/60', 'hover:bg-red-700/80');
        button.classList.add('bg-indigo-600/50', 'hover:bg-indigo-600/80');
        button.innerHTML = `<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14 5l7 7m0 0l-7 7m7-7H3"></path></svg>`;
    },
};


    <!-- PASTE content of app.js HERE -->
/**
 * =================================================================================================
 * Controller Module (The Handler)
 * =================================================================================================
 * This module handles all user-initiated events. It acts as the "brain," receiving
 * user input, telling the StateManager how to change the data, calling the APIService
 * for AI responses, and then telling the UIManager to re-render the view.
 */
const Controller = {
    // A single place for constants the controller uses.
    CONSTANTS: {
        CHARACTER_COLORS: [
            { base: '#334155', bold: '#94a3b8' }, // Slate (Blue-Grey)
            { base: '#1e3a8a', bold: '#60a5fa' }, // Blue
            { base: '#581c87', bold: '#f472b6' }, // Fuchsia
            { base: '#78350f', bold: '#fbbf24' }, // Amber
            { base: '#365314', bold: '#a3e635' }, // Lime
            { base: '#5b21b6', bold: '#a78bfa' }, // Violet
            { base: '#881337', bold: '#fb7185' }, // Rose
            { base: '#155e75', bold: '#22d3ee' }  // Cyan
        ]
    },

    // Holds temporary, non-persistent properties related to the controller's runtime behavior.
    RUNTIME: {
        activeKnowledgeTab: 'static',
        activeSettingsTab: 'appearance',
        activeWorldMapTab: 'move',
        selectedMapTile: null,
        pendingMove: null,
        turnOfArrival: 0,
        selectedLocalStaticEntryId: null,
        activeRequestAbortController: null, // For aborting AI generation requests
    },

    // --- Story & Narrative Management ---

    /**
     * Creates a new, blank story in the library.
     */
	async createNewStory() {
        UIManager.showLoadingSpinner('Creating new story...');
        try {
            // 1. Call the service to create and save the story in the DB
            // This function already exists in StoryService and works correctly
            const newStory = await StoryService.createNewStory();

            // 2. Add the new story (which is a stub) to the in-memory library
            const library = StateManager.getLibrary();
            library.stories.push(newStory);

            // 3. Clear active session (this was correct)
            library.active_story_id = null;
            library.active_narrative_id = null;
            StateManager.saveLibrary(); // Saves the (cleared) active IDs

            // 4. Refresh the UI and open the details for the new story
            UIManager.renderLibraryInterface();
            UIManager.openStoryDetails(newStory.id);
            
        } catch (e) {
            console.error("Failed to create new story:", e);
            alert("Error: Could not create a new story in the database.");
        } finally {
            UIManager.hideLoadingSpinner();
        }
    },

    /**
     * Creates a new narrative (chat session) from a selected scenario template.
     * @param {string} storyId - The ID of the parent story.
     * @param {string} scenarioId - The ID of the scenario to use as a template.
     */
	async createNarrativeFromScenario(storyId, scenarioId) {
        UIManager.showLoadingSpinner('Creating new narrative...');
        try {
            // 1. Call the StoryService to do all the database work
            const newNarrative = await StoryService.createNarrativeFromScenario(storyId, scenarioId);

            // 2. Update the in-memory library stub
            const library = StateManager.getLibrary();
            const storyInLibrary = library.stories.find(s => s.id === storyId);
            if (storyInLibrary) {
                // Add the new stub to the in-memory list
                storyInLibrary.narratives.push({
                    id: newNarrative.id,
                    name: newNarrative.name,
                    last_modified: newNarrative.last_modified
                });
                storyInLibrary.last_modified = new Date().toISOString(); // Reflect the change
            }
            
            // 3. Load the new narrative
            // This function just sets localStorage and reloads the page
            this.loadNarrative(storyId, newNarrative.id);

        } catch (error) {
            UIManager.hideLoadingSpinner();
            console.error("Failed to create narrative from scenario:", error);
            alert(`Error: ${error.message}`);
        }
    },

    /**
     * Loads a specific narrative, making it the active session, and reloads the application.
     * @param {string} storyId - The ID of the story containing the narrative.
     * @param {string} narrativeId - The ID of the narrative to load.
     */
    loadNarrative(storyId, narrativeId) {
        const library = StateManager.getLibrary();
        library.active_story_id = storyId;
        library.active_narrative_id = narrativeId;
        StateManager.saveLibrary();
        window.location.reload();
    },

    /**
     * Duplicates an existing narrative.
     * @param {string} storyId - The ID of the parent story.
     * @param {string} narrativeId - The ID of the narrative to duplicate.
     */
	async deleteNarrative(storyId, narrativeId) {
        const proceed = await UIManager.showConfirmationPromise('Are you sure you want to permanently delete this narrative and all its chat history?');
        if (!proceed) return;

        UIManager.showLoadingSpinner('Deleting narrative...');
        try {
            // 1. Call the service to delete from DB and update parent story
            const updatedStory = await StoryService.deleteNarrative(storyId, narrativeId);

            // 2. Update the in-memory library
            const library = StateManager.getLibrary();
            const storyInLibrary = library.stories.find(s => s.id === storyId);
            if (storyInLibrary) {
                // Replace the stub list with the new one from the service
                storyInLibrary.narratives = updatedStory.narratives;
                storyInLibrary.last_modified = updatedStory.last_modified;
            }

            // 3. Clear active ID if it was deleted
            if (library.active_narrative_id === narrativeId) {
                library.active_narrative_id = null;
                library.active_story_id = null;
                StateManager.saveLibrary(); // Saves the cleared IDs
                window.location.reload(); // Reload to "no story"
            } else {
                StateManager.saveLibrary();
                UIManager.openStoryDetails(storyId); // Refresh details view
            }
        } catch (e) {
            console.error("Failed to delete narrative:", e);
            alert(`Error: ${e.message}`);
        } finally {
            UIManager.hideLoadingSpinner();
        }
    },

    async duplicateNarrative(storyId, narrativeId) {
        UIManager.showLoadingSpinner('Duplicating narrative...');
        try {
            // 1. Get the story and narrative to duplicate
            const story = await DBService.getStory(storyId);
            const narrative = await DBService.getNarrative(narrativeId);
            if (!story || !narrative) throw new Error("Story or Narrative not found in database.");

            // 2. Create the new narrative
            const newNarrative = JSON.parse(JSON.stringify(narrative));
            newNarrative.id = UTILITY.uuid();
            newNarrative.name = `${narrative.name} (Copy)`;
            newNarrative.last_modified = new Date().toISOString();
            
            // 3. Save the new narrative
            await DBService.saveNarrative(newNarrative);

            // 4. Update the parent story's stub list
            story.narratives.push({ id: newNarrative.id, name: newNarrative.name, last_modified: newNarrative.last_modified });
            story.last_modified = new Date().toISOString();
            await DBService.saveStory(story);

            // 5. Update the in-memory library stub
            const library = StateManager.getLibrary();
            const storyInLibrary = library.stories.find(s => s.id === storyId);
            if (storyInLibrary) {
                storyInLibrary.narratives = story.narratives; // Use the updated stub list
                storyInLibrary.last_modified = story.last_modified;
            }
            
            UIManager.openStoryDetails(storyId); // Refresh details
        } catch (e) {
            console.error("Failed to duplicate narrative:", e);
            alert(`Error: ${e.message}`);
        } finally {
            UIManager.hideLoadingSpinner();
        }
    },

	async deleteScenario(storyId, scenarioId) {
        const story = await DBService.getStory(storyId); // Get full story
        if (!story) return;

        if (story.scenarios.length <= 1) {
            alert("You cannot delete the last scenario.");
            return;
        }

        const proceed = await UIManager.showConfirmationPromise('Are you sure you want to delete this scenario?');
        if (!proceed) return;

        try {
            story.scenarios = story.scenarios.filter(sc => sc.id !== scenarioId);
            story.last_modified = new Date().toISOString();
            await DBService.saveStory(story); // Save updated story

            // Update in-memory stub
            const library = StateManager.getLibrary();
            const storyInLibrary = library.stories.find(s => s.id === storyId);
            if (storyInLibrary) {
                storyInLibrary.scenarios = story.scenarios;
                storyInLibrary.last_modified = story.last_modified;
            }
            
            UIManager.openStoryDetails(storyId); // Refresh UI
        } catch (e) {
            console.error("Failed to delete scenario:", e);
            alert(`Error: ${e.message}`);
        }
    },

    async duplicateScenario(storyId, scenarioId) {
        UIManager.showLoadingSpinner('Duplicating scenario...');
        try {
            const story = await DBService.getStory(storyId); // Get full story
            const scenario = story.scenarios.find(sc => sc.id === scenarioId);
            if (!story || !scenario) throw new Error("Story or Scenario not found.");
            
            const newScenario = JSON.parse(JSON.stringify(scenario));
            newScenario.id = UTILITY.uuid();
            newScenario.name = `${scenario.name} (Copy)`;
            story.scenarios.push(newScenario);
            story.last_modified = new Date().toISOString();
            
            await DBService.saveStory(story); // Save updated story

            // Update in-memory stub
            const library = StateManager.getLibrary();
            const storyInLibrary = library.stories.find(s => s.id === storyId);
            if (storyInLibrary) {
                storyInLibrary.scenarios = story.scenarios;
                storyInLibrary.last_modified = story.last_modified;
            }
            
            UIManager.openStoryDetails(storyId); // Refresh UI
        } catch (e) {
            console.error("Failed to duplicate scenario:", e);
            alert(`Error: ${e.message}`);
        } finally {
            UIManager.hideLoadingSpinner();
        }
    },

	async deleteStory(storyId) {
        const proceed = await UIManager.showConfirmationPromise('Are you sure you want to permanently delete this entire story, including all its narratives and scenarios?');
        if (!proceed) return;

        UIManager.showLoadingSpinner('Deleting story...');
        try {
            // 1. Call the service to delete everything from DB
            await StoryService.deleteStory(storyId);

            // 2. Update the in-memory library
            const library = StateManager.getLibrary();
            library.stories = library.stories.filter(s => s.id !== storyId);
            StateManager.updateTagCache();

            // 3. Handle active session
            if (library.active_story_id === storyId) {
                library.active_story_id = null;
                library.active_narrative_id = null;
                StateManager.saveLibrary(); // Save cleared IDs
                window.location.reload();
            } else {
                StateManager.saveLibrary();
                UIManager.renderLibraryInterface(); // Refresh library list
            }
        } catch (e) {
            console.error("Failed to delete story:", e);
            alert(`Error: ${e.message}`);
        } finally {
            UIManager.hideLoadingSpinner();
        }
    },

    async renameStoryPrompt(storyId) {
        const library = StateManager.getLibrary();
        const story = library.stories.find(s => s.id === storyId);
        if (story) {
            const currentName = story.name || '';
            const newName = prompt("Enter new name for the story:", currentName);
            if (newName && newName.trim() !== '' && newName.trim() !== currentName) {
                UIManager.showLoadingSpinner('Renaming...');
                try {
                    // 1. Call service to update DB
                    const updatedStory = await StoryService.updateStoryField(storyId, 'name', newName.trim());

                    // 2. Update in-memory stub
                    story.name = updatedStory.name;
                    story.last_modified = updatedStory.last_modified;
                    this.updateSearchIndex(story); // Update search index
                    
                    // 3. Refresh UI
                    UIManager.renderLibraryInterface(); // Refresh list
                    UIManager.openStoryDetails(storyId); // Refresh details

                    // 4. Update active state if it's the current story
                    if (library.active_story_id === storyId) {
                         const activeState = StateManager.getState();
                         if (activeState) activeState.name = updatedStory.name;
                         // Update UI title bars
                         document.getElementById('story-title-input').value = updatedStory.name;
                         document.getElementById('mobile-story-title-overlay').value = updatedStory.name;
                    }

                } catch (e) {
                    console.error("Failed to rename story:", e);
                    alert(`Error: ${e.message}`);
                } finally {
                    UIManager.hideLoadingSpinner();
                }
            }
        }
    },

    async duplicateStory(storyId) {
        UIManager.showLoadingSpinner('Duplicating story...');
        try {
            // 1. Get all data for the original story
            const originalStory = await DBService.getStory(storyId);
            if (!originalStory) throw new Error("Original story not found in database.");

            const originalNarrativeStubs = originalStory.narratives || [];
            const originalNarratives = await Promise.all(
                originalNarrativeStubs.map(stub => DBService.getNarrative(stub.id))
            );
            
            // 2. Create new story object with new IDs
            const newStory = JSON.parse(JSON.stringify(originalStory));
            newStory.id = UTILITY.uuid();
            newStory.name = `${originalStory.name || 'Untitled Story'} (Copy)`;
            newStory.last_modified = new Date().toISOString();
            newStory.created_date = new Date().toISOString();
            
            // 3. Create new narratives with new IDs
            const newNarratives = [];
            const newNarrativeStubs = [];
            
            for (const narrative of originalNarratives) {
                if (!narrative) continue; // Skip if a narrative was missing
                const newNarrative = JSON.parse(JSON.stringify(narrative));
                newNarrative.id = UTILITY.uuid();
                // Optionally rename narratives, e.g., newNarrative.name = `${narrative.name} (Copy)`;
                newNarratives.push(newNarrative);
                newNarrativeStubs.push({ id: newNarrative.id, name: newNarrative.name, last_modified: newNarrative.last_modified });
            }
            
            // 4. Update new story with new narrative stubs
            newStory.narratives = newNarrativeStubs;
            
            // 5. Create new IDs for scenarios, characters, entries
            (newStory.scenarios || []).forEach(s => s.id = UTILITY.uuid());
            (newStory.characters || []).forEach(c => c.id = UTILITY.uuid());
            (newStory.dynamic_entries || []).forEach(e => e.id = UTILITY.uuid());
            
            // 6. Save all new data to DB
            await DBService.saveStory(newStory);
            await Promise.all(newNarratives.map(n => DBService.saveNarrative(n)));

            // 7. Update in-memory library
            this.updateSearchIndex(newStory);
            const library = StateManager.getLibrary();
            library.stories.push(newStory);
            StateManager.updateTagCache();
            
            UIManager.renderLibraryInterface(); // Refresh list

        } catch (e) {
            console.error("Failed to duplicate story:", e);
            alert(`Error: ${e.message}`);
        } finally {
            UIManager.hideLoadingSpinner();
        }
    },

    /**
     * Updates the searchable text index for a story.
     * @param {object} story - The story object to index.
     */
    updateSearchIndex(story) {
        if (!story) return;
        let index = [story.name];
        if (story.tags) index.push(...story.tags);
		if (story.creator_notes) index.push(story.creator_notes);
        if (story.characters) {
            story.characters.forEach(char => {
                index.push(char.name);
                index.push(char.description);
                if (char.tags) index.push(...char.tags);
            });
        }
        story.search_index = index.join(' ').toLowerCase();
    },
	
	/**
     * Exports the entire story library (stories, narratives, images) as a single ZIP file.
     * [REVISED] This now calls the StoryService to build a zip from IndexedDB.
     */
    async exportLibrary() {
        UIManager.showLoadingSpinner('Exporting entire library...');
        try {
            // 1. Call the StoryService to get the ZIP blob
            const zipBlob = await StoryService.exportLibraryAsZip();
            
            // 2. Create and download the blob
            const url = URL.createObjectURL(zipBlob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `ellipsis_library_backup_${new Date().toISOString().split('T')[0]}.zip`;
            document.body.appendChild(a); // Added for Firefox compatibility
            a.click();
            document.body.removeChild(a); // Clean up
            URL.revokeObjectURL(url);

        } catch (e) {
            console.error("Library export failed:", e);
            alert(`Library export failed: ${e.message}`);
        } finally {
            UIManager.hideLoadingSpinner();
        }
    },

    /**
     * Imports and replaces the entire library from an Ellipsis Library ZIP file.
     * [REVISED] This now calls the StoryService to import from a ZIP to IndexedDB.
     * @param {Event} event - The file input change event.
     */
    async importLibrary(event) {
        const file = event.target.files[0];
        if (!file) return;

        // Reset the file input so the same file can be loaded again
        event.target.value = '';

        try {
            // 1. Get confirmation from the user
            const proceed = await UIManager.showConfirmationPromise('WARNING: This will permanently replace your entire story library with the contents of the ZIP file. This action cannot be undone. Are you sure?');
            
            if (proceed) {
                UIManager.showLoadingSpinner('Importing library... Do not close this tab.');
                
                // 2. Call the StoryService to handle the import
                await StoryService.importLibraryFromZip(file);
                
                // 3. Success!
                UIManager.hideLoadingSpinner();
                alert("Library imported successfully! The application will now reload.");
                
                // 4. Use a short delay to allow UI to update before reload
                setTimeout(() => window.location.reload(), 500);
            }
        } catch (err) { 
            UIManager.hideLoadingSpinner();
            console.error("Error importing library:", err);
            alert(`Error importing library: ${err.message}`); 
        }
    },	

    // --- Modal & UI State Management ---

    /**
     * Handles the opening of all modals, performing necessary setup for each.
     * @param {string} modalId - The ID of the modal to open.
     * @param {*} [contextId=null] - An optional context ID (e.g., character ID, message index).
     */
    openModal(modalId, contextId = null) { 
        const library = StateManager.getLibrary();
        const state = StateManager.getState();
        
        if ((modalId === 'knowledge-modal' || modalId === 'characters-modal' || modalId === 'settings-modal' || modalId === 'example-dialogue-modal' || modalId === 'character-detail-modal' || modalId === 'world-map-modal' || modalId === 'io-hub-modal') && (!library.active_story_id && modalId !== 'io-hub-modal')) {
             alert("Please load a narrative first.");
             return;
        }

        switch(modalId) {
            case 'story-library-modal':
                UIManager.renderLibraryInterface();
                break;
            case 'io-hub-modal':
                UIManager.renderIOHubModal();
                break;
            case 'knowledge-modal':
                this.switchKnowledgeTab('static');
                break;
            case 'world-map-modal':
                this.RUNTIME.selectedMapTile = null;
                this.RUNTIME.pendingMove = null;
                this.RUNTIME.selectedLocalStaticEntryId = null;
                this.switchWorldMapTab('move');
                break;
            case 'settings-modal':
                this.prepareSettingsModal();
                this.switchSettingsTab(this.RUNTIME.activeSettingsTab || 'appearance');
                break;
            case 'example-dialogue-modal':
                UIManager.renderExampleDialogueModal();
                break;
            case 'character-detail-modal':
                UIManager.openCharacterDetailModal(contextId);
                break;
            case 'edit-response-modal':
                this.openEditModal(contextId);
                break;
        }
        ModalManager.open(modalId);
    },
    
    /** Closes a modal. */
	closeModal(modalId) { 
        ModalManager.close(modalId);
        if (modalId === 'character-detail-modal') {
            UIManager.renderCharacters();
        }

        // --- NEW CLEANUP LOGIC ---
        // When the knowledge modal is closed, we clean up any
        // empty content fields from our dynamic entries.
        if (modalId === 'knowledge-modal') {
            const state = StateManager.getState();
            if (state.dynamic_entries) {
                state.dynamic_entries.forEach(entry => {
                    if (entry.content_fields) {
                        // 1. Filter out any fields that are just empty space
                        entry.content_fields = entry.content_fields.filter(field => field.trim() !== "");
                        
                        // 2. (Edge Case) If filtering removed all fields, add one back
                        //    An entry must always have at least one field.
                        if (entry.content_fields.length === 0) {
                            entry.content_fields.push("");
                        }

                        // 3. (Edge Case) Clamp the index
                        //    If we removed fields, the index might be out of bounds.
                        //    We reset it to the last valid index.
                        if (entry.current_index >= entry.content_fields.length) {
                            entry.current_index = entry.content_fields.length - 1;
                        }
                    }
                });
                // Save the cleaned-up state
                StateManager.saveState();
            }
        }
    },

    /** Toggles the mobile navigation menu. */
    toggleMobileMenu() {
        document.getElementById('mobile-menu').classList.toggle('hidden');
    },

    /** Switches between static and dynamic tabs in the Knowledge modal. */
    switchKnowledgeTab(tabName) {
        this.RUNTIME.activeKnowledgeTab = tabName;
        UIManager.renderKnowledgeModalTabs();
    },

    /** Switches between move and world map tabs in the World Map modal. */
    switchWorldMapTab(tabName) {
        this.RUNTIME.activeWorldMapTab = tabName;
        UIManager.renderWorldMapModal();
    },

    /**
     * Switches between tabs in the Settings modal and binds necessary event listeners.
     * @param {string} tabName - The name of the tab to activate ('appearance', 'prompt', 'model').
     */
    switchSettingsTab(tabName) {
        this.RUNTIME.activeSettingsTab = tabName;
        const tabs = ['appearance', 'prompt', 'model'];
        const container = document.getElementById('settings-content-container');
        const template = document.getElementById(`settings-${tabName}-content`);
        container.innerHTML = template.innerHTML;

        tabs.forEach(tab => {
            const tabButton = document.getElementById(`settings-tab-${tab}`);
            if (tab === tabName) {
                tabButton.classList.add('border-indigo-500', 'text-white');
                tabButton.classList.remove('border-transparent', 'text-gray-400');
            } else {
                tabButton.classList.remove('border-indigo-500', 'text-white');
                tabButton.classList.add('border-transparent', 'text-gray-400');
            }
        });
        this.bindSettingsListeners();
    },

    /** Opens the settings modal directly to a specific tab. */
    openSettingsToTab(tabName) {
        this.openModal('settings-modal');
        this.switchSettingsTab(tabName);
    },

    /** Prepares the settings modal content on first open. */
    prepareSettingsModal() {
        const container = document.getElementById('settings-content-container');
        if (container.innerHTML.trim() !== '...') return; // Already populated
        
        const templates = document.getElementById('settings-templates');
        let maxHeight = 0;
        ['appearance', 'prompt', 'model'].forEach(tabName => {
            const content = templates.querySelector(`#settings-${tabName}-content`);
            if(content) {
                 document.body.appendChild(content); // Temporarily append to measure
                 maxHeight = Math.max(maxHeight, content.scrollHeight);
                 templates.appendChild(content); // Move it back
            }
        });
        container.style.minHeight = `${maxHeight}px`;
    },
	
	/** Handles the upload of a local image for the global background. */
    async handleBackgroundImageUpload(event) {
        const file = event.target.files?.[0];
        if (!file) return;

        if (file.size > 5 * 1024 * 1024) { // 5MB Limit
            alert("Error: Image file size should not exceed 5MB.");
            event.target.value = '';
            return;
        }

        UIManager.showLoadingSpinner?.('Processing background image...');
        let savedSuccessfully = false; // Flag to track DB save success

        try {
            const blob = await ImageProcessor.processImageAsBlob(file);
            const key = 'global_background_image';

            // --- MODIFICATION: Check saveImage result ---
            savedSuccessfully = await DBService.saveImage(key, blob);

            if (!savedSuccessfully) {
                 // Throw an error if saving failed to stop execution and show alert
                 throw new Error("Failed to save the image to the browser database (IndexedDB). This might happen in private browsing mode or if storage quota is exceeded.");
            }
            // --- END MODIFICATION ---

            console.log("Image saved to IndexedDB successfully."); // Log success

            // Live-cache update
            const oldUrl = UIManager.RUNTIME.globalBackgroundImageCache;
            if (oldUrl) URL.revokeObjectURL(oldUrl);
            UIManager.RUNTIME.globalBackgroundImageCache = URL.createObjectURL(blob);

            // Set state to use the new local image and save
            const state = StateManager.getState();
            state.backgroundImageURL = 'local_idb_background'; // Special keyword
            console.log("Saving state with backgroundImageURL =", state.backgroundImageURL);
            StateManager.saveState();

            UIManager.applyStyling(); // Re-apply to show the new background

            // Update the hint text
            const bgHint = document.getElementById('background-image-hint');
            if (bgHint) bgHint.textContent = 'Current: [Local Image]';

        } catch (err) {
            console.error("Error processing or saving background image:", err);
            alert(`Upload failed: ${err.message}`); // Show the specific error

            // --- ROLLBACK LOGIC (No change needed here, handled by throwing error) ---
            // If save failed, the state/cache updates above won't run.
            // We should ensure the hint reflects failure.
             const bgHint = document.getElementById('background-image-hint');
             const currentState = StateManager.getState()?.backgroundImageURL;
             if (bgHint) {
                 if(currentState === 'local_idb_background'){
                     // This case shouldn't happen if error is thrown correctly, but as a safeguard:
                     bgHint.textContent = 'Current: [Save Failed]';
                 } else if (currentState) {
                      bgHint.textContent = 'Current: [Legacy URL]';
                 } else {
                     bgHint.textContent = 'Current: None';
                 }
             }

        } finally {
            UIManager.hideLoadingSpinner?.();
            // Clear the file input ONLY if the save was successful
            if (savedSuccessfully) {
                event.target.value = '';
            }
        }
    },

    /** Clears the locally stored background image. */
	async clearBackgroundImage() {
        UIManager.showLoadingSpinner?.('Clearing background...');
        try {
            await DBService.deleteImage('global_background_image');

            const oldUrl = UIManager.RUNTIME.globalBackgroundImageCache;
            if (oldUrl) URL.revokeObjectURL(oldUrl);
            UIManager.RUNTIME.globalBackgroundImageCache = null;

            const state = StateManager.getState();
            state.backgroundImageURL = ''; // Clear the state
            StateManager.saveState();

            UIManager.applyStyling(); // Re-apply to show the default background

            // [NEW] Update the hint text
            const bgHint = document.getElementById('background-image-hint');
            if (bgHint) bgHint.textContent = 'Current: None';

        } catch (err) {
            console.error("Error clearing background image:", err);
            alert("There was an error clearing the background.");
        } finally {
            UIManager.hideLoadingSpinner?.();
        }
    },

    /** Binds all event listeners for the interactive elements within the settings modal. */
    bindSettingsListeners() {
        const state = StateManager.getState();
		const globalSettings = StateManager.data.globalSettings; // <-- GET GLOBAL SETTINGS
		
		// <-- DEFINE MODEL KEYS -->
        const modelSettingKeys = [
            'geminiApiKey', 'openRouterKey', 'openRouterModel',
            'koboldcpp_url', 'koboldcpp_template', 'koboldcpp_min_p', 'koboldcpp_dry',
            'lmstudio_url'
        ];
		
        const setListener = (id, key, callback) => { 
            const input = document.getElementById(id); 
            if (!input) return;
			
			// <-- READ FROM GLOBAL OR STATE -->
            const isGlobal = modelSettingKeys.includes(key);
            input.value = isGlobal 
                ? (globalSettings[key] !== undefined ? globalSettings[key] : '')
                : (state[key] !== undefined ? state[key] : '');
				
            const debouncedCallback = debounce(function(e) { 
                state[key] = e.target.value; 

				// <-- SAVE TO GLOBAL OR STATE -->
                if (isGlobal) {
                    globalSettings[key] = e.target.value;
                    StateManager.saveGlobalSettings();
                } else {
                    StateManager.saveState();
                }

                if(callback) callback();
            }.bind(this), 500);
            input.addEventListener('input', debouncedCallback);
        };
		
        const setupSlider = (sliderId, valueId, stateKey, callback = null) => {
            const slider = document.getElementById(sliderId);
            const valueDisplay = document.getElementById(valueId);
            if (!slider || !valueDisplay) return;
			
			// <-- READ FROM GLOBAL OR STATE -->
            const isGlobal = modelSettingKeys.includes(stateKey);
            const currentValue = isGlobal ? globalSettings[stateKey] : state[stateKey];
            slider.value = currentValue;
            valueDisplay.textContent = slider.value;
            
            slider.addEventListener('input', (e) => {
                const newValue = parseFloat(e.target.value);
                state[stateKey] = newValue; // Always update live state
                valueDisplay.textContent = e.target.value;
                
                // <-- UPDATE GLOBAL IF NEEDED -->
                if (isGlobal) {
                    globalSettings[stateKey] = newValue;
                }
                if(callback) callback();
            });
            
            // <-- SAVE TO GLOBAL OR STATE -->
            slider.addEventListener('change', () => {
                if (isGlobal) {
                    StateManager.saveGlobalSettings();
                } else {
                    StateManager.saveState();
                }
            });
        };
        
        // Model Tab
		
        if(document.getElementById('gemini-api-key-input')) setListener('gemini-api-key-input', 'geminiApiKey');
        if(document.getElementById('openrouter-api-key-input')) setListener('openrouter-api-key-input', 'openRouterKey');
        // Update OpenRouter model display (model is selected via modal, not text input)
        const openRouterModelDisplay = document.getElementById('openrouter-model-display');
        if (openRouterModelDisplay) {
            openRouterModelDisplay.textContent = globalSettings.openRouterModel || 'No model selected';
        } 
        if(document.getElementById('koboldcpp-min-p-slider')) setupSlider('koboldcpp-min-p-slider', 'koboldcpp-min-p-value', 'koboldcpp_min_p');
        if(document.getElementById('koboldcpp-dry-slider')) setupSlider('koboldcpp-dry-slider', 'koboldcpp-dry-value', 'koboldcpp_dry');
		if(document.getElementById('koboldcpp-url-input')) setListener('koboldcpp-url-input', 'koboldcpp_url');
		if(document.getElementById('lmstudio-url-input')) setListener('lmstudio-url-input', 'lmstudio_url');
		
		const bgHint = document.getElementById('background-image-hint');
        if (bgHint) {
            if (state.backgroundImageURL === 'local_idb_background') {
                bgHint.textContent = 'Current: [Local Image]';
            } else if (state.backgroundImageURL) {
                bgHint.textContent = 'Current: [Legacy URL]';
            } else {
                bgHint.textContent = 'Current: None';
            }
        }

        // Appearance Tab
		document.getElementById('background-image-upload')?.addEventListener('change', (e) => Controller.handleBackgroundImageUpload(e));
		document.getElementById('background-image-clear')?.addEventListener('click', () => Controller.clearBackgroundImage());
        if(document.getElementById('chat-text-color')) setListener('chat-text-color', 'chatTextColor', () => UIManager.applyStyling());
        if(document.getElementById('blur-slider')) setupSlider('blur-slider', 'blur-value', 'backgroundBlur', () => UIManager.applyStyling());
        if(document.getElementById('text-size-slider')) setupSlider('text-size-slider', 'text-size-value', 'textSize', () => UIManager.applyStyling());
        if(document.getElementById('bubble-image-size-slider')) setupSlider('bubble-image-size-slider', 'bubble-image-size-value', 'bubbleImageSize', () => UIManager.applyStyling());

        // Prompt Tab
        if(document.getElementById('system-prompt-input')) setListener('system-prompt-input', 'system_prompt');
        if(document.getElementById('event-master-prompt-input')) setListener('event-master-prompt-input', 'event_master_base_prompt');
        if(document.getElementById('prompt-persona-gen-input')) setListener('prompt-persona-gen-input', 'prompt_persona_gen');
        if(document.getElementById('prompt-world-map-gen-input')) setListener('prompt-world-map-gen-input', 'prompt_world_map_gen');
        if(document.getElementById('prompt-location-gen-input')) setListener('prompt-location-gen-input', 'prompt_location_gen');
        if(document.getElementById('prompt-entry-gen-input')) setListener('prompt-entry-gen-input', 'prompt_entry_gen');
        if(document.getElementById('prompt-location-memory-gen-input')) setListener('prompt-location-memory-gen-input', 'prompt_location_memory_gen');

        
        const fontSelector = document.getElementById('font-selector'); 
        if(fontSelector) {
            fontSelector.value = state.font; 
            fontSelector.addEventListener('change', (e) => this.changeFont(e.target.value));
        }

        const templateSelector = document.getElementById('koboldcpp-template-selector');
        if(templateSelector) {
            templateSelector.value = state.koboldcpp_template;
            templateSelector.addEventListener('change', (e) => {
                state.koboldcpp_template = e.target.value;
                StateManager.saveState();
            });
        }
        
        const opacitySlider = document.getElementById('bubble-opacity-slider');
        if(opacitySlider) {
            const opacityValue = document.getElementById('bubble-opacity-value');
            opacitySlider.value = state.bubbleOpacity;
            opacityValue.textContent = `${Math.round(state.bubbleOpacity * 100)}%`;
            opacitySlider.addEventListener('input', (e) => {
                state.bubbleOpacity = parseFloat(e.target.value);
                opacityValue.textContent = `${Math.round(state.bubbleOpacity * 100)}%`;
                UIManager.renderChat();
            });
            opacitySlider.addEventListener('change', () => StateManager.saveState());
        }
        
        document.querySelectorAll('input[name="imageDisplayMode"]').forEach(radio => {
            radio.checked = state.characterImageMode === radio.value;
            radio.addEventListener('change', (e) => this.setCharacterImageMode(e.target.value));
        });
        document.querySelectorAll('input[name="apiProvider"]').forEach(radio => {
            radio.checked = state.apiProvider === radio.value;
            radio.addEventListener('change', (e) => this.setApiProvider(e.target.value));
        });

        const geminiSettings = document.getElementById('gemini-settings');
        const openrouterSettings = document.getElementById('openrouter-settings');
        const koboldcppSettings = document.getElementById('koboldcpp-settings');
        const lmstudioSettings = document.getElementById('lmstudio-settings');
        if (geminiSettings) geminiSettings.style.display = state.apiProvider === 'gemini' ? 'block' : 'none';
        if (openrouterSettings) openrouterSettings.style.display = state.apiProvider === 'openrouter' ? 'block' : 'none';
        if (koboldcppSettings) koboldcppSettings.style.display = state.apiProvider === 'koboldcpp' ? 'block' : 'none';
        if (lmstudioSettings) lmstudioSettings.style.display = state.apiProvider === 'lmstudio' ? 'block' : 'none';
    },
    
    /** Changes the chat font. */
    changeFont(font) { 
        StateManager.getState().font = font; 
        UIManager.applyStyling(); 
        StateManager.saveState(); 
    },
    
    /** Sets the character image display mode. */
    setCharacterImageMode(mode) {
        StateManager.getState().characterImageMode = mode;
        StateManager.saveState();
        UIManager.renderChat();
    },

    /** Sets the active AI provider. */
	setApiProvider(provider) {
			StateManager.getState().apiProvider = provider; // Updates live state
			StateManager.data.globalSettings.apiProvider = provider; // Updates global state
			this.bindSettingsListeners();
			StateManager.saveGlobalSettings(); // <-- SAVE GLOBALLY
	},

    /** Opens the OpenRouter model selector modal and fetches available models. */
    async openOpenRouterModelSelector() {
        const state = StateManager.getState();
        const listContainer = document.getElementById('openrouter-model-list');
        const searchInput = document.getElementById('openrouter-model-search');
        const selectedDisplay = document.getElementById('openrouter-selected-model-display');

        // Show current selection
        if (selectedDisplay) {
            selectedDisplay.textContent = state.openRouterModel || 'None';
        }

        // Reset search input
        if (searchInput) {
            searchInput.value = '';
        }

        // Show loading state
        if (listContainer) {
            listContainer.innerHTML = '<div class="flex items-center justify-center h-full text-gray-400"><span>Loading models...</span></div>';
        }

        this.openModal('openrouter-model-modal');

        try {
            const models = await APIService.fetchOpenRouterModels();
            this._openRouterModels = models;
            this._renderOpenRouterModels(models, state.openRouterModel);

            // Setup search handler
            if (searchInput) {
                searchInput.oninput = debounce((e) => {
                    const query = e.target.value.toLowerCase().trim();
                    const filtered = query ? models.filter(m =>
                        m.id.toLowerCase().includes(query) ||
                        (m.name && m.name.toLowerCase().includes(query))
                    ) : models;
                    this._renderOpenRouterModels(filtered, state.openRouterModel);
                }, 200);
            }
        } catch (error) {
            console.error('Failed to fetch OpenRouter models:', error);
            if (listContainer) {
                listContainer.innerHTML = `<div class="flex flex-col items-center justify-center h-full text-red-400 p-4"><span class="text-center">Failed to load models. ${error.message}</span><button onclick="Controller.openOpenRouterModelSelector()" class="mt-4 bg-indigo-600 hover:bg-indigo-700 px-4 py-2 rounded-lg text-white">Retry</button></div>`;
            }
        }
    },

    /** Renders the OpenRouter model list. */
    _renderOpenRouterModels(models, currentModel) {
        const listContainer = document.getElementById('openrouter-model-list');
        if (!listContainer) return;

        if (!models || models.length === 0) {
            listContainer.innerHTML = '<div class="flex items-center justify-center h-full text-gray-400"><span>No models found</span></div>';
            return;
        }

        // Sort models: selected first, then by name
        const sortedModels = [...models].sort((a, b) => {
            if (a.id === currentModel) return -1;
            if (b.id === currentModel) return 1;
            return (a.name || a.id).localeCompare(b.name || b.id);
        });

        const formatPrice = (price) => {
            if (!price || price === 0) return 'Free';
            const perMillion = parseFloat(price) * 1000000;
            if (perMillion < 0.01) return '<$0.01/M';
            return `$${perMillion.toFixed(2)}/M`;
        };

        listContainer.innerHTML = sortedModels.map(model => {
            const isSelected = model.id === currentModel;
            const promptPrice = formatPrice(model.pricing?.prompt);
            const completionPrice = formatPrice(model.pricing?.completion);
            const contextLength = model.context_length ? `${Math.round(model.context_length / 1024)}K ctx` : '';

            return `
                <div class="p-3 rounded-lg cursor-pointer transition-colors mb-1 ${isSelected ? 'bg-indigo-600/50 border border-indigo-500' : 'bg-gray-700/50 hover:bg-gray-600/50 border border-transparent'}" onclick="Controller.selectOpenRouterModel('${model.id}')">
                    <div class="flex justify-between items-start">
                        <div class="flex-1 min-w-0">
                            <div class="font-medium text-white truncate">${model.name || model.id}</div>
                            <div class="text-xs text-gray-400 truncate">${model.id}</div>
                        </div>
                        ${isSelected ? '<span class="ml-2 text-indigo-300 text-sm"> Selected</span>' : ''}
                    </div>
                    <div class="flex gap-3 mt-2 text-xs text-gray-400">
                        <span title="Input price per million tokens">In: ${promptPrice}</span>
                        <span title="Output price per million tokens">Out: ${completionPrice}</span>
                        ${contextLength ? `<span title="Context window">${contextLength}</span>` : ''}
                    </div>
                </div>
            `;
        }).join('');
    },

    /** Selects an OpenRouter model and updates the state. */
    selectOpenRouterModel(modelId) {
        const state = StateManager.getState();
        state.openRouterModel = modelId;
        StateManager.data.globalSettings.openRouterModel = modelId;
        StateManager.saveGlobalSettings();

        // Update the display in the modal
        const selectedDisplay = document.getElementById('openrouter-selected-model-display');
        if (selectedDisplay) {
            selectedDisplay.textContent = modelId;
        }

        // Update the display in settings
        const modelDisplay = document.getElementById('openrouter-model-display');
        if (modelDisplay) {
            modelDisplay.textContent = modelId || 'No model selected';
        }

        // Re-render the list to show new selection
        if (this._openRouterModels) {
            this._renderOpenRouterModels(this._openRouterModels, modelId);
        }

        // Close modal after selection
        this.closeModal('openrouter-model-modal');
    },

    // --- Chat & AI Interaction ---
    
    /** Handles the primary user action button, which can be Send, Write for Me, or Stop Generation. */
    handlePrimaryAction() { 
        if (!StateManager.getLibrary().active_story_id) { 
            UIManager.showConfirmationModal("Please load or create a story from the Story Library first.", () => this.openModal('story-library-modal')); 
            return; 
        } 
        document.getElementById('chat-input').value.trim() === '' ? this.writeForMe() : this.sendMessage(); 
    },

    /** Handles the regenerate button click, re-triggering an AI response. */
    async handleRegen() {
        const state = StateManager.getState();
        if(!StateManager.getLibrary().active_narrative_id) { alert("Load a narrative from the Story Library first."); return; }
        if (this.RUNTIME.activeRequestAbortController || UIManager.RUNTIME.streamingInterval) return;
        
        let selectedCharId = document.getElementById('ai-character-selector').value;
        if (selectedCharId === 'any') {
            selectedCharId = this.determineNextSpeaker(false); // isMove = false
        }

        const lastMsg = state.chat_history.filter(m => m.type === 'chat').pop();
        const lastChar = lastMsg ? state.characters.find(c => c.id === lastMsg.character_id) : null;

        if (lastChar && !lastChar.is_user && lastMsg.character_id === selectedCharId) {
            this.undoLastTurn();
            await this.triggerAIResponse(selectedCharId);
        } else {
            await this.triggerAIResponse(selectedCharId);
        }
    },

    /** Sends a user message from the chat input. */
    async sendMessage() {
        // 1. Check if AI is already running
        if (this.RUNTIME.activeRequestAbortController || UIManager.RUNTIME.streamingInterval) return;
        
        // 2. Get state and user input
        const state = StateManager.getState();
        const input = document.getElementById('chat-input');
        const userChar = state.characters.find(c => c.is_user);
		
		if (!userChar) {
            alert("No character is set as the 'User'. Please set a character to 'User' in the Characters modal to send messages.");
            return;
        }
		
        const messageContent = input.value.trim();
        if (!messageContent) return;
        
        // 3. Add user message to history
        this.addMessageToHistory(userChar.id, messageContent);
        input.value = ''; // Clear input
        
        // 4. Check for dynamic triggers
        this.checkDynamicEntryTriggers();
        
        // 5. Trigger the AI's response
        await this.triggerAIResponse(null, messageContent);
        
        // 6. Check for the Event Master
        this.checkEventMaster();

        // 7. --- THIS IS THE NEW, CORRECTLY PLACED TRIGGER ---
        // Check if the counter is a multiple of 10.
        // We get the state again in case it was modified.
        const currentState = StateManager.getState(); 
        if (currentState.messageCounter > 0 && currentState.messageCounter % 10 === 0) {
            console.log(`User turn ${currentState.messageCounter}: Triggering automatic static memory update.`);
            // We call a new, silent function to avoid popups.
            this.triggerSilentStaticUpdate(); 
        }
        // NO stray }, here
    },

    /** Triggers the AI to write a response for the user's character. */
    async writeForMe() {
        if (this.RUNTIME.activeRequestAbortController || UIManager.RUNTIME.streamingInterval) return;
        const state = StateManager.getState();
        const userChar = state.characters.find(c => c.is_user); if (!userChar) return;
        const input = document.getElementById('chat-input');
        
        UIManager.setButtonToStopMode();
        this.RUNTIME.activeRequestAbortController = new AbortController();

        try {
            const prompt = PromptBuilder.buildPrompt(userChar.id, true);
            input.value = await APIService.callAI(prompt, false, this.RUNTIME.activeRequestAbortController.signal);
        } catch (error) {
            if (error.name === 'AbortError') {
                console.log("Write For Me generation stopped by user.");
            } else {
                console.error("Write for Me failed:", error);
            }
        } finally {
            UIManager.setButtonToSendMode();
            this.RUNTIME.activeRequestAbortController = null;
        }
    },

	/** Undoes the last message in the chat history, handling hidden lore entries. */
    undoLastTurn() { 
        if (this.RUNTIME.activeRequestAbortController || UIManager.RUNTIME.streamingInterval) return;
        const state = StateManager.getState();
        if (state.chat_history.length === 0) return; 

        // Keep removing items from the end until we find and remove a 'chat' type message
        // This ensures we remove the AI response AND any hidden system/lore events that triggered after it
        let removedChatMessage = false;
        while (state.chat_history.length > 0 && !removedChatMessage) {
            const msg = state.chat_history.pop();
            if (msg.type === 'chat') {
                state.messageCounter--;
                removedChatMessage = true;
            }
        }

        this.saveAndRender(); 
    },

    /**
     * Adds a message to the active narrative's chat history.
     * @param {string} id - The ID of the character sending the message.
     * @param {string} content - The message content.
     * @param {string} [type='chat'] - The type of message ('chat', 'system_event', etc.).
     * @param {string} [emotion='neutral'] - The detected emotion for the message.
     */
    addMessageToHistory(id, content, type = 'chat', emotion = 'neutral') {
        const state = StateManager.getState();
        if (UIManager.RUNTIME.streamingInterval) {
            clearInterval(UIManager.RUNTIME.streamingInterval);
            UIManager.RUNTIME.streamingInterval = null;
            StateManager.saveState();
        }
        state.chat_history.push({ 
            character_id: id, content, type, emotion,
            timestamp: new Date().toISOString(), isNew: true 
        });
        if (type === 'chat') state.messageCounter++;
        UIManager.renderChat();
        StateManager.saveState();
        
        const chatWindow = document.getElementById('chat-window');
        const lastBubble = chatWindow.lastElementChild;
        if(lastBubble) {
            lastBubble.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
    },

    /**
     * Adds a system event message (e.g., "You have moved to...") to the chat history.
     * @param {string} content - The content of the system message.
     */
    addSystemMessageToHistory(content) {
        const state = StateManager.getState();
        state.chat_history.push({
            type: 'system_event', content, timestamp: new Date().toISOString(), isNew: true
        });
        UIManager.renderChat();
        StateManager.saveState();
    },

    /** Displays the speaker scores modal for debugging. */
    showSpeakerScores(scoresData) {
        UIManager.renderSpeakerScoresModal(scoresData);
    },

    /**
     * Determines which AI character should speak next based on a weighted scoring algorithm.
     * @param {boolean} [isAfterMove=false] - A flag indicating if the determination is happening after a map move.
     * @returns {string|null} The ID of the character chosen to speak next.
     */
    determineNextSpeaker(isAfterMove = false) {
        const state = StateManager.getState();
        let pool = state.characters.filter(c => !c.is_user && c.is_active);
    
        if (pool.length === 0) {
            return null;
        }
        if (pool.length === 1) {
            return pool[0].id;
        }
    
        if (isAfterMove) {
            const narrators = pool.filter(c => c.is_narrator);
            if (narrators.length > 0) {
                return narrators[Math.floor(Math.random() * narrators.length)].id;
            }
        }
    
        const chatHistory = (state.chat_history || []).filter(m => m.type === 'chat' && !m.isHidden);
        const nonUserHistory = chatHistory.filter(m => state.characters.some(c => c.id === m.character_id && !c.is_user));
    
        if (!isAfterMove && nonUserHistory.length > 0) {
            const lastAiSpeaker = state.characters.find(c => c.id === nonUserHistory[nonUserHistory.length - 1].character_id);
            if (lastAiSpeaker && lastAiSpeaker.is_narrator) {
                const potentialPool = pool.filter(c => c.id !== lastAiSpeaker.id);
                if (potentialPool.length > 0) {
                    pool = potentialPool;
                }
            }
        }
    
        if (pool.length === 1) {
            return pool[0].id;
        }
    

		const scores = {};
		pool.forEach(c => {
			scores[c.id] = c.is_narrator ? 0 : 1;
		}); 
		
		const narratorsInPool = pool.filter(c => c.is_narrator);
        if (narratorsInPool.length > 0) {
            for (let i = chatHistory.length - 1; i >= 0; i--) {
                const message = chatHistory[i];
                const speaker = state.characters.find(c => c.id === message.character_id);
                if (speaker && speaker.is_narrator) {
                    break;
                }
                narratorsInPool.forEach(narrator => {
                    scores[narrator.id] += 0.2;
                });
            }
        }
    
         if (nonUserHistory.length >= 1) {
            const lastSpeakerId = nonUserHistory[nonUserHistory.length - 1].character_id;
            const lastSpeaker = state.characters.find(c => c.id === lastSpeakerId);
            if (scores[lastSpeakerId] !== undefined && lastSpeaker && !lastSpeaker.is_narrator) {
                 scores[lastSpeakerId] += 1;
            }
        }
        if (nonUserHistory.length >= 2) {
            const secondLastSpeakerId = nonUserHistory[nonUserHistory.length - 2].character_id;
            const secondLastSpeaker = state.characters.find(c => c.id === secondLastSpeakerId);
            if (scores[secondLastSpeakerId] !== undefined && secondLastSpeaker && !secondLastSpeaker.is_narrator) {
                scores[secondLastSpeakerId] += 0.5;
            }
        }
    
        const last2Messages = chatHistory.slice(-2);
        const last4Messages = chatHistory.slice(-4);
    
        pool.forEach(char => {
            const charName = char.name.toLowerCase();
            if (last2Messages.some(msg => msg.content.toLowerCase().includes(charName))) {
                scores[char.id] += 0.5;
            }
            if (last4Messages.some(msg => msg.content.toLowerCase().includes(charName))) {
                scores[char.id] += 0.5;
            }
        });
    
        const characters = pool;
        const weights = characters.map(c => scores[c.id]);
        
        const winner = UTILITY.weightedChoice(characters, weights, this);
        return winner ? winner.id : pool[0]?.id || null;
    },

    /**
     * Constructs the prompt, calls the APIService, and handles the AI's response or any errors.
     * @param {string|null} charId - The ID of the character to respond, or null to auto-determine.
     * @param {string} [userMessage=''] - The content of the user's last message for analysis.
     * @param {boolean} [isAfterMove=false] - Flag if this is a response after a map move.
     */
    async triggerAIResponse(charId = null, userMessage = '', isAfterMove = false) {
        const state = StateManager.getState();
        const activeAiChars = state.characters.filter(c => !c.is_user && c.is_active);
        if (activeAiChars.length === 0) {
            this.addMessageToHistory(systemSpeaker.id, "No active character. Ensure at least one character is active in the chat.");
            return;
        }
		
        const isModelConfigured = () => {
            switch (state.apiProvider) {
                case 'gemini': return !!state.geminiApiKey;
                case 'openrouter': return !!state.openRouterKey && !!state.openRouterModel;
                case 'koboldcpp': return !!state.koboldcpp_url;
                case 'lmstudio': return !!state.lmstudio_url;
                default: return false;
            }
        };
        if (!isModelConfigured()) {
            this.addMessageToHistory(activeAiChars[0].id, "The AI model is not configured. Please check your settings.");
            return;
        }
        const selectedCharId = charId || document.getElementById('ai-character-selector').value;
        let aiCharId = selectedCharId === 'any' ? this.determineNextSpeaker(isAfterMove) : selectedCharId;
        if (!aiCharId) {
            console.log("AI response skipped: No eligible speaker determined.");
            return;
        }
        
        UIManager.showTypingIndicator(aiCharId);
        UIManager.setButtonToStopMode();
        this.RUNTIME.activeRequestAbortController = new AbortController();

        try {
            const prompt = PromptBuilder.buildPrompt(aiCharId);
            const responseText = await APIService.callAI(prompt, false, this.RUNTIME.activeRequestAbortController.signal);
            let analysis = { emotion: 'neutral', locationName: null };
            if (userMessage) {
                try { analysis = await this.analyzeTurn(userMessage); } 
                catch (e) { console.error("Turn analysis failed:", e); }
            }
            UIManager.hideTypingIndicator();
            UIManager.startStreamingResponse(aiCharId, responseText, analysis.emotion);
            if (analysis.locationName) {
                const targetLocation = state.worldMap.grid.find(loc => loc.name.toLowerCase() === analysis.locationName.toLowerCase());
                const currentLocationData = state.worldMap.grid.find(loc => loc.coords.x === state.worldMap.currentLocation.x && loc.coords.y === state.worldMap.currentLocation.y);
                if (targetLocation && targetLocation.name !== currentLocationData?.name) {
                    setTimeout(() => { this.moveToLocation(targetLocation.coords.x, targetLocation.coords.y); }, 1500);
                }
            }
        } catch (error) {
            if (error.name === 'AbortError') {
                console.log("Generation stopped by user.");
            } else {
                this.addMessageToHistory(aiCharId, `[Error: ${error.message}]`); 
            }
            UIManager.hideTypingIndicator();
        } finally {
            UIManager.setButtonToSendMode();
            this.RUNTIME.activeRequestAbortController = null;
        }
    },
    
    // --- Agent & Trigger Logic ---

    /**
     * Invokes an AI agent to analyze the recent conversation and suggest updates to the static knowledge base.
     */
    async checkWorldInfoAgent() { 
        const state = StateManager.getState();
        if (!StateManager.getLibrary().active_narrative_id) { alert("Please load a narrative first."); return; }
        UIManager.showTypingIndicator('static-entry-agent', 'Updating static knowledge...'); 
        try { 
            let p = `As Static Knowledge Master, read chat/info, update the info. Output valid JSON: { "add": [{"title": "...", "content": "..."}], "modify": [{"title": "...", "new_content": "..."}] } or {}. INFO:${JSON.stringify(state.static_entries)}CHAT:`; 
            (state.chat_history || []).filter(m=>m.type==='chat').slice(-8).forEach(msg => { const c = state.characters.find(i=>i.id===msg.character_id); if(c) p += `${c.name}: ${msg.content}\n`;});
            const updates = JSON.parse(await APIService.callAI(p, true)); 
            if (updates.add) updates.add.forEach(item => state.static_entries.push({id: UTILITY.uuid(), ...item})); 
            if (updates.modify) updates.modify.forEach(item => { const entry = state.static_entries.find(e => e.title.toLowerCase() === item.title.toLowerCase()); if (entry) entry.content = item.new_content; }); 
            this.saveAndRenderStaticEntries(); 
        } catch (e) { 
            console.error("Static Entry Agent failed:", e); 
            alert("The AI failed to update static entries. It may have returned an invalid format.");
        } finally { 
            UIManager.hideTypingIndicator(); 
        } 
    },
    
    /**
     * Every few turns, invokes an AI agent to generate a secret, surprising event instruction for other AI characters.
     */
    async checkEventMaster() { 
        const state = StateManager.getState();
        if (state.messageCounter > 0 && state.messageCounter % 6 === 0) try { 
            let p = state.event_master_base_prompt + '\n\n--- RECENT CHAT HISTORY ---\n'; 
            (state.chat_history || []).filter(m=>m.type==='chat').slice(-12).forEach(msg => { const c = state.characters.find(i=>i.id===msg.character_id); if(c) p += `${c.name}: ${msg.content}\n`;});
            state.event_master_prompt = await APIService.callAI(p); 
            StateManager.saveState(); 
            console.log("Event Master:", state.event_master_prompt); 
        } catch (e) { 
            console.error("Event Master failed:", e); 
        } 
    },
    
	/**
     * Helper: Converts a user keyword into a RegExp with word boundaries.
     * Handles * as a wildcard.
     */
    _compileTriggerRegex(keyword) {
        // 1. Escape special regex characters (like ?, +, ., etc) to prevent errors
        // We temporarily preserve the * if it exists
        let clean = keyword.replace(/[.+^${}()|[\]\\]/g, '\\$&'); 

        // 2. Check for wildcards
        const hasStartWild = clean.startsWith('*');
        const hasEndWild = clean.endsWith('*');

        // 3. Remove the asterisks for the pattern
        clean = clean.replace(/^\*|\*$/g, '');

        // 4. Build boundaries
        // If NO start wildcard, enforce a word boundary at the start (\b)
        if (!hasStartWild) clean = '\\b' + clean;
        
        // If NO end wildcard, enforce a word boundary at the end (\b)
        if (!hasEndWild) clean = clean + '\\b';

        // 5. Return regex (i = case insensitive)
        return new RegExp(clean, 'i');
    },
	
	/**
     * Checks the last message against all dynamic entry triggers and activates any that match.
     * [UPDATED] Now supports exact matching and * wildcards.
     */
    checkDynamicEntryTriggers() {
        const state = StateManager.getState();
        // Get the last message that wasn't a lore reveal
        const lastMessage = (state.chat_history || []).filter(m => m.type !== 'lore_reveal').pop();
        if (!lastMessage) return;

        const content = lastMessage.content; // We use raw content, regex handles case insensitivity
        let stateChanged = false;

        (state.dynamic_entries || []).forEach(entry => {
            // 1. Check for triggers
            const { groups, chance } = this.parseTriggers(entry.triggers);
            
            const keywordMatch = groups.some(group => {
                // Map keywords to Regex patterns
                const patterns = group.keywords.map(kw => this._compileTriggerRegex(kw));

                switch (group.type) {
                    case 'OR': 
                        return patterns.some(regex => regex.test(content));
                    case 'AND': 
                        return patterns.every(regex => regex.test(content));
                    case 'XOR': 
                        const [f, s] = [patterns[0].test(content), patterns[1].test(content)]; 
                        return (f && !s) || (!f && s);
                    default: 
                        return false;
                }
            });

            // 2. If triggered:
            if (keywordMatch || (Math.random() * 100 < chance)) {
                
                // 3. De-duplicate: Look-behind 20 messages
                const searchWindowStart = Math.max(0, state.chat_history.length - 20);
                let foundIndex = -1;

                for (let i = state.chat_history.length - 1; i >= searchWindowStart; i--) {
                    const msg = state.chat_history[i];
                    if (msg.type === 'lore_reveal' && msg.dynamic_entry_id === entry.id) {
                        foundIndex = i;
                        break;
                    }
                }

                if (foundIndex !== -1) {
                    state.chat_history.splice(foundIndex, 1);
                    stateChanged = true;
                }

                // 4. Sequential Logic
                const contentIndex = entry.current_index || 0;
                const contentToReveal = entry.content_fields[contentIndex];

                let nextIndex = contentIndex + 1;
                if (nextIndex >= entry.content_fields.length) {
                    nextIndex = entry.content_fields.length - 1;
                }
                entry.current_index = nextIndex;
                
                // 5. Add the new entry inline
                state.chat_history.push({ 
                    type: 'lore_reveal', 
                    title: entry.title, 
                    content: contentToReveal,
                    dynamic_entry_id: entry.id,
                    timestamp: new Date().toISOString(),
                    isHidden: true
                });
                console.log(`Dynamic Entry triggered: ${entry.title}`);
                stateChanged = true;

                if (entry.triggered_at_turn !== null) {
                    entry.triggered_at_turn = null;
                }
            }
        });

        if (stateChanged) {
            StateManager.saveState();
            UIManager.renderDynamicEntries(); 
        }
    },

    /**
     * Parses the trigger string from a dynamic entry into a structured format.
     * @param {string} triggersStr - The raw trigger string (e.g., "house, cat AND dog, 25%").
     * @returns {{groups: Array, chance: number}} - A structured object of triggers.
     */
    parseTriggers(triggersStr) {
        if (!triggersStr) return { groups: [], chance: 0 };
        const parts = triggersStr.split(',').map(s => s.trim());
        const chancePart = parts.find(p => p.match(/^\d+\s*\%$/));
        const chance = chancePart ? parseInt(chancePart.replace('%', '')) : 0;
        const keywordParts = parts.filter(p => p && !p.match(/^\d+\s*\%$/));
        const groups = keywordParts.map(part => {
            if (part.includes(' XOR ')) { const keywords = part.split(' XOR ').map(k => k.trim().toLowerCase()).filter(Boolean); if (keywords.length === 2) return { type: 'XOR', keywords }; }
            if (part.includes(' AND ')) { const keywords = part.split(' AND ').map(k => k.trim().toLowerCase()).filter(Boolean); if (keywords.length > 0) return { type: 'AND', keywords }; }
            return { type: 'OR', keywords: [part.toLowerCase()] };
        });
        return { groups, chance };
    },

    // --- CRUD and Edit Functions ---

    /** Opens the modal to edit a specific chat message. */
    openEditModal(index) {
        const state = StateManager.getState();
        const message = state.chat_history[index];
        const input = document.getElementById('edit-modal-input');
        input.value = message.content;
        const autoResize = () => { input.style.height = 'auto'; input.style.height = `${input.scrollHeight}px`; };
        if (input.autoResizeListener) input.removeEventListener('input', input.autoResizeListener);
        input.autoResizeListener = autoResize;
        input.addEventListener('input', autoResize);
        document.getElementById('edit-modal-save-button').onclick = () => this.saveEditedResponse(index);
        setTimeout(autoResize, 0);
        ModalManager.open('edit-response-modal');
    },

    /** Saves the edited content of a chat message. */
    saveEditedResponse(index) {
        const state = StateManager.getState();
        const newContent = document.getElementById('edit-modal-input').value;
        state.chat_history[index].content = newContent;
        this.saveAndRender();
        this.closeModal('edit-response-modal');
    },

    /** Uses AI to enhance a character's persona description. */
    async enhancePersonaWithAI(event, charId) {
        const state = StateManager.getState();
        const char = state.characters.find(c => c.id === charId);
        if (!char) return;

        UIManager.showConfirmationModal('This will overwrite the current persona with an AI-generated one. Are you sure?', async () => {
            const newDescription = await this._generateContentForField(event, state.prompt_persona_gen, {
                concept: char.description
            });
            
            if (newDescription !== null) {
                this.updateCharacterField(charId, 'description', newDescription);
                const personaTextarea = document.getElementById(`persona-description-${charId}`);
                if (personaTextarea) {
                    personaTextarea.value = newDescription;
                    const autoResize = () => { personaTextarea.style.height = 'auto'; personaTextarea.style.height = `${personaTextarea.scrollHeight}px`; };
                    autoResize();
                }
            }
        });
    },

    /** Uses AI to generate model instructions based on a character's persona. */
    async generateModelInstructions(event, charId) {
        UIManager.showConfirmationModal("This will overwrite the current model instructions. Are you sure?", async () => {
            const state = StateManager.getState();
            const char = state.characters.find(c => c.id === charId);
            if (!char) return;

            const staticKnowledge = (state.static_entries || []).map(e => `### ${e.title}\n${e.content}`).join('\n\n');
            const prompt = `Based on the following character persona and world information, generate a concise set of model instructions for an AI roleplaying as this character. The instructions should guide the AI on how to speak, its personality, and key traits to embody.\n\n### Character Persona:\n${char.description}\n\n### World Static Knowledge:\n${staticKnowledge}\n\n### INSTRUCTIONS:`;
            
            const newInstructions = await this._generateContentForField(event, prompt, {});
            
            if (newInstructions !== null) {
                this.updateCharacterField(charId, 'model_instructions', newInstructions);
                UIManager.openCharacterDetailModal(charId);
            }
        });
    },

    /** Helper function to manage button state and call the AI service for content generation. */
    async _generateContentForField(event, promptTemplate, context, isJson = false) {
        const button = event.target.closest('button');
        if (!button) return null;

        const originalContent = button.innerHTML;
        button.disabled = true;
        button.innerHTML = '...';
        
        try {
            let prompt = promptTemplate;
            for (const key in context) {
                prompt = prompt.replace(new RegExp(`{${key}}`, 'g'), context[key]);
            }
            return await APIService.callAI(prompt, isJson);
        } catch (error) {
            console.error("AI Generation failed:", error);
            alert(`AI generation failed: ${error.message}`);
            return null;
        } finally {
            button.disabled = false;
            button.innerHTML = originalContent;
        }
    },

    /** Uses AI to generate a detailed prompt for a world map location. */
    async generateLocationPromptAI(event) {
        const state = StateManager.getState();
        const location = this.RUNTIME.selectedMapTile;
        if (!location) return;

        const newContent = await this._generateContentForField(event, state.prompt_location_gen, {
            name: location.name,
            description: location.description
        });
        
        if (newContent !== null) {
            this.updateLocationDetail('prompt', newContent);
            UIManager.renderWorldMapModal();
        }
    },

    /** Uses AI to generate content for a static knowledge entry. */
    async generateStaticEntryContentAI(event, entryId) {
        const state = StateManager.getState();
        const entry = state.static_entries.find(e => e.id === entryId);
        if (!entry) return;

        const newContent = await this._generateContentForField(event, state.prompt_entry_gen, {
            title: entry.title,
            triggers: '' // No triggers for static entries
        });

        if (newContent !== null) {
            this.updateStaticEntryField(entryId, 'content', newContent);
            UIManager.renderStaticEntryDetails();
        }
    },

    /** Uses AI to analyze user input for emotion and location keywords. */
    async analyzeTurn(text) {
        const state = StateManager.getState();
        const locationNames = (state.worldMap?.grid || []).map(loc => loc.name);
        const locationList = locationNames.length > 0 ? `Valid locations are: [${locationNames.join(', ')}].` : 'No location data is available.';
        
        try {
            const prompt = `Analyze the text for sentiment and implied location. Respond with a valid JSON object like {"emotion": "...", "locationName": "..."}.
            - 'emotion' must be one of: neutral, happy, sad, angry, surprised.
            - 'locationName' must be one of the provided valid locations, or null if no specific location is mentioned or implied.
            ${locationList}
            TEXT: "${text}"`;
            
            const response = await APIService.callAI(prompt, true);
            const analysis = JSON.parse(response);

            const validEmotions = ['neutral', 'happy', 'sad', 'angry', 'surprised'];
            return {
                emotion: validEmotions.includes(analysis.emotion) ? analysis.emotion : 'neutral',
                locationName: locationNames.includes(analysis.locationName) ? analysis.locationName : null
            };
        } catch (error) {
            console.error("Sentiment/Location analysis failed:", error);
            return { emotion: 'neutral', locationName: null };
        }
    },
    
    /** Adds a new character to the roster. */
    addCharacter() { 
        const state = StateManager.getState();
        const aiCharCount = state.characters.filter(c => !c.is_user).length;
        const newColor = this.CONSTANTS.CHARACTER_COLORS[aiCharCount % this.CONSTANTS.CHARACTER_COLORS.length];
        const newChar = { 
            id: UTILITY.uuid(), name: "New Character", description: "", short_description: "A brief one-line summary.",
            model_instructions: "Act as {character}. Be descriptive and engaging.", image_url: "", extra_portraits: [], 
            tags: [], is_user: false, is_active: true, color: newColor, is_narrator: false
        };
        state.characters.push(newChar); 
        StateManager.saveState(); 
        UIManager.renderCharacters();
        this.openModal('character-detail-modal', newChar.id);
    },

    /** Deletes a character from the roster. */
	deleteCharacter(id) {
		UIManager.showConfirmationModal('Are you sure you want to delete this character?', () => {
			const state = StateManager.getState();
			state.characters = state.characters.filter(c => c.id !== id);
			this.closeModal('character-detail-modal');
			this.saveAndRender();
			
			DBService.deleteImage(id);

			// Also remove any emotion portraits for this character
			try {
				// Scan the cache keys directly since the character is already removed from the state
				Object.keys(UIManager.RUNTIME.characterImageCache || {}).forEach(k => {
					if (k.startsWith(`${id}::emotion::`)) {
						DBService.deleteImage(k).catch(() => {});
						URL.revokeObjectURL(UIManager.RUNTIME.characterImageCache[k]);
						delete UIManager.RUNTIME.characterImageCache[k];
					}
				});
			} catch (e) {
				console.warn('Could not clean emotion portraits for deleted character', e);
			}
		});
	},

    /** Updates a specific field of a character object (debounced). */
    updateCharacterField: debounce(function(id, field, value) { 
        const state = StateManager.getState();
        const char = state.characters.find(c => c.id === id); 
        if (char) { 
            char[field] = value; 
            StateManager.saveState(); 
            if (field === 'name') {
                UIManager.updateAICharacterSelector();
                const header = document.querySelector(`#character-detail-modal-content h2[data-char-id="${id}"]`);
                if(header) header.textContent = value;
            }
            if (field === 'name' || field === 'short_description' || field === 'image_url' || field === 'tags') {
                UIManager.renderCharacters();
            }
        } 
    }, 300),
	
	
	/** * Sets the role of a character: 'user', 'narrator', or 'none'.
     * Enforces single-user rule.
     */
    setCharacterRole(charId, role) {
        const state = StateManager.getState();
        
        // 1. Update the target character
        const targetChar = state.characters.find(c => c.id === charId);
        if (!targetChar) return;

        if (role === 'user') {
            targetChar.is_user = true;
            targetChar.is_narrator = false;
            
            // 2. Unset 'is_user' for ALL other characters
            state.characters.forEach(c => {
                if (c.id !== charId) c.is_user = false;
            });
        } else if (role === 'narrator') {
            targetChar.is_user = false;
            targetChar.is_narrator = true;
        } else { // 'none'
            targetChar.is_user = false;
            targetChar.is_narrator = false;
        }

        StateManager.saveState();
        
        // 3. Refresh UI to reflect changes (roster + detail modal)
        UIManager.renderCharacters();
        UIManager.openCharacterDetailModal(charId);
    },
	
	
	/**
     * Updates a specific field of a story object (debounced).
     * REFACTORED: Now calls StoryService.
     */
    updateStoryField: debounce(async function(storyId, field, value) {
        try {
            // 1. Call the service to update the DB
            const updatedStory = await StoryService.updateStoryField(storyId, field, value);

            // 2. Update the in-memory stub
            const library = StateManager.getLibrary();
            const storyInLibrary = library.stories.find(s => s.id === storyId);
            if (storyInLibrary) {
                storyInLibrary[field] = updatedStory[field];
                storyInLibrary.last_modified = updatedStory.last_modified;
            }

            // 3. Update search index if needed
            if (field === 'creator_notes') {
                this.updateSearchIndex(storyInLibrary);
            }
        } catch (e) {
            console.error(`Failed to update story field ${field}:`, e);
            alert("Error: Could not save story update.");
        }
    }, 300),

	/**
     * Updates a story's tags (debounced).
     * REFACTORED: Now calls StoryService.
     */
    updateStoryTags: debounce(async function(storyId, value) {
        const tags = value.split(',').map(t => t.trim()).filter(Boolean);
        try {
            // 1. Call the service to update the DB
            const updatedStory = await StoryService.updateStoryField(storyId, 'tags', tags);

            // 2. Update the in-memory stub
            const library = StateManager.getLibrary();
            const storyInLibrary = library.stories.find(s => s.id === storyId);
            if (storyInLibrary) {
                storyInLibrary.tags = updatedStory.tags;
                storyInLibrary.last_modified = updatedStory.last_modified;
            }

            // 3. Update search and tag cache
            this.updateSearchIndex(storyInLibrary);
            StateManager.updateTagCache();

        } catch (e) {
            console.error("Failed to update story tags:", e);
            alert("Error: Could not save story tags.");
        }
    }, 500),

	/**
     * Uses AI to generate a creator's note for a story.
     * REFACTORED: Now calls StoryService for context.
     */
    async generateStoryNotesAI(event, storyId) {
        const state = StateManager.getState();
        const globalPrompts = state.id ? state : UTILITY.getDefaultSystemPrompts();
        const promptTemplate = globalPrompts.prompt_story_notes_gen;

        // 1. Get context from the StoryService
        const context = await StoryService.buildStoryContext(storyId);
        
        // 2. Call the AI
        const newNotes = await this._generateContentForField(event, promptTemplate, { context });
        
        if (newNotes !== null) {
            // 3. Save the update (this function is now refactored and works)
            this.updateStoryField(storyId, 'creator_notes', newNotes);
            
            // Re-render the details view
            UIManager.openStoryDetails(storyId);
        }
    },

	/**
     * Uses AI to generate tags for a story.
     * REFACTORED: Now calls StoryService for context.
     */
    async generateStoryTagsAI(event, storyId) {
        const state = StateManager.getState();
        const globalPrompts = state.id ? state : UTILITY.getDefaultSystemPrompts();
        const promptTemplate = globalPrompts.prompt_story_tags_gen;
        
        // 1. Get context from the StoryService
        const context = await StoryService.buildStoryContext(storyId);

        // 2. Call the AI
        const tagsString = await this._generateContentForField(event, promptTemplate, { context });
        
        if (tagsString !== null) {
            const library = StateManager.getLibrary();
            const storyInLibrary = library.stories.find(s => s.id === storyId);
            const newTags = tagsString.split(',').map(t => t.trim().toLowerCase());
            const combinedTags = [...new Set([...(storyInLibrary.tags || []), ...newTags])];
            
            // 3. Save the update (this function is now refactored and works)
            this.updateStoryTags(storyId, combinedTags.join(', '));
            
            // Re-render the details view
            UIManager.openStoryDetails(storyId);
        }
    },


/** Handles the upload of a local image for a world map location. */
    async handleWorldMapLocationImageUpload(event, x, y) {
      const file = event.target.files?.[0];
      if (!file) return;

      if (file.size > 5 * 1024 * 1024) { // 5MB Limit
        alert("Error: Image file size should not exceed 5MB.");
        event.target.value = '';
        return;
      }
      
      // Create a unique key for this specific tile
      const locationKey = `location::${x},${y}`;
      UIManager.showLoadingSpinner?.('Processing location image...');

      try {
        const blob = await ImageProcessor.processImageAsBlob(file);
        const saveSuccess = await DBService.saveImage(locationKey, blob);

        if (!saveSuccess) {
            throw new Error("Failed to save image to IndexedDB. This might be due to private browsing or storage limits.");
        }

        // Add to live cache
        UIManager.RUNTIME.worldImageCache = UIManager.RUNTIME.worldImageCache || {};
        const oldUrl = UIManager.RUNTIME.worldImageCache[locationKey];
        if (oldUrl) URL.revokeObjectURL(oldUrl);
        UIManager.RUNTIME.worldImageCache[locationKey] = URL.createObjectURL(blob);

        // Update the model to use the local key and clear the legacy URL
        const state = StateManager.getState();
        const locationInGrid = state.worldMap.grid.find(loc => loc.coords.x === x && loc.coords.y === y);
        if (locationInGrid) {
            // Use a keyword to show it's local, not a real URL
            locationInGrid.imageUrl = `local_idb_location::${x},${y}`;
            StateManager.saveState();
        }

        // Refresh UI
        UIManager.renderWorldMapModal(); // Re-render modal to update hint
        UIManager.applyStyling(); // Apply new background if it's the current location

      } catch (err) {
        console.error("Error processing location image:", err);
        alert(`Upload failed: ${err.message}`);
      } finally {
        UIManager.hideLoadingSpinner?.();
        event.target.value = ''; // Clear file input
      }
    },

    /** Handles the upload of a local image for a character portrait. */
	async handleLocalImageUpload(event, charId) {
	  const file = event.target.files?.[0];
	  if (!file) return;

	  if (file.size > 5 * 1024 * 1024) {
		alert("Error: Image file size should not exceed 5MB.");
		event.target.value = '';
		return;
	  }

	  UIManager.showLoadingSpinner?.('Processing image...');
	  try {
		const blob = await ImageProcessor.processImageAsBlob(file);
		await DBService.saveImage(charId, blob);

		// Live-cache update (no reload)
		UIManager.RUNTIME.characterImageCache = UIManager.RUNTIME.characterImageCache || {};
		const oldUrl = UIManager.RUNTIME.characterImageCache[charId];
		if (oldUrl) URL.revokeObjectURL(oldUrl);
		UIManager.RUNTIME.characterImageCache[charId] = URL.createObjectURL(blob);

		// Normalize the model to IDB-backed (no external URL)
		this.updateCharacterField(charId, 'image_url', '');

		// Minimal, targeted repaints
		UIManager.renderCharacters?.();           // roster tiles
		const active = StateManager.getState?.();
		if (active?.lastSpeakerId) {
		  UIManager.updateSidePortrait?.();       // side portrait in horizontal mode
		}
		UIManager.refreshRecentMessages?.(10)     // if you have it
		  ?? UIManager.renderChat?.();            // otherwise a small full chat repaint

		// Optional UI text hint near the uploader
		const textInput = event.target.closest('div')?.querySelector('input[type="text"]');
		if (textInput) textInput.value = `[Image stored in browser]`;
	  } catch (err) {
		console.error("Error processing local image:", err);
		alert("There was an error processing the image.");
	  } finally {
		UIManager.hideLoadingSpinner?.();
	  }
	},
	
/** Handles the upload of a local image for an emotional portrait. */
    async handleLocalEmotionImageUpload(event, charId, index) {
      const file = event.target.files?.[0];
      if (!file) return;

      if (file.size > 5 * 1024 * 1024) {
        alert("Error: Image file size should not exceed 5MB.");
        event.target.value = '';
        return;
      }

      const state = StateManager.getState();
      const char = state.characters.find(c => c.id === charId);
      if (!char || !Array.isArray(char.extra_portraits) || !char.extra_portraits[index]) return;

      // Read the emotion from the model (source of truth)
      const emotion = (char.extra_portraits[index].emotion || 'neutral').toLowerCase();
      const emoKey = `${charId}::emotion::${emotion}`;

      UIManager.showLoadingSpinner?.('Processing emotion image...');
      try {
        const blob = await ImageProcessor.processImageAsBlob(file);
        await DBService.saveImage(emoKey, blob);

        // Live-cache update (no reload)
        UIManager.RUNTIME.characterImageCache = UIManager.RUNTIME.characterImageCache || {};
        const oldUrl = UIManager.RUNTIME.characterImageCache[emoKey];
        if (oldUrl) URL.revokeObjectURL(oldUrl);
        UIManager.RUNTIME.characterImageCache[emoKey] = URL.createObjectURL(blob);

        // Clear the URL (so getPortraitSrc prefers the local blob)
        char.extra_portraits[index].url = '';
        StateManager.saveState();

        // Targeted UI refresh so the new image shows up immediately
        const active = StateManager.getState();
        UIManager.renderCharacters?.();
        if (active?.lastSpeakerId) UIManager.updateSidePortrait?.();
        UIManager.refreshRecentMessages?.(10) ?? UIManager.renderChat?.();

        // Optional: hint in the nearby URL input box
        const textInput = event.target.closest('div')?.querySelector('input[type="text"]');
        if (textInput) textInput.value = `[Image stored in browser for "${emotion}"]`;
      } catch (err) {
        console.error("Error processing emotion image:", err);
        alert("There was an error processing the emotion image.");
      } finally {
        UIManager.hideLoadingSpinner?.();
      }
    },


    /** Updates a character's color scheme (debounced). */
    updateCharacterColor: debounce(function(charId, type, value) {
        const state = StateManager.getState();
        const char = state.characters.find(c => c.id === charId);
        if (char) {
            if (!char.color || typeof char.color !== 'object') {
                char.color = { base: '#334155', bold: '#94a3b8' };
            }
            char.color[type] = value;
            StateManager.saveState();
            UIManager.renderChat();
        }
    }, 100),

    /** Updates a character's tags (debounced). */
    updateCharacterTags: debounce(function(id, value) {
        const state = StateManager.getState();
        const char = state.characters.find(c => c.id === id);
        if (char) {
            char.tags = value.split(',').map(t => t.trim()).filter(Boolean);
            StateManager.saveState();
            StateManager.updateTagCache();
        }
    }, 500),

    /** Uses AI to generate tags for a character based on their persona. */
    async generateTagsForCharacter(event, charId) {
        UIManager.showConfirmationModal("This will use AI to add to the current tags. Are you sure?", async () => {
            const state = StateManager.getState();
            const char = state.characters.find(c => c.id === charId);
            if (!char) return;

            const prompt = `Analyze the following character. Generate 3 to 5 relevant, one-word, comma-separated tags.\n\nCHARACTER: ${char.name}\nDESCRIPTION: ${char.description}`;
            const tagsString = await this._generateContentForField(event, prompt, {});
            
            if (tagsString !== null) {
                char.tags = (char.tags || []).concat(tagsString.split(',').map(t => t.trim().toLowerCase()));
                char.tags = [...new Set(char.tags)];
                StateManager.saveState();
                UIManager.openCharacterDetailModal(charId);
                StateManager.updateTagCache();
            }
        });
    },

    addExtraPortrait(charId) { const state = StateManager.getState(); const char = state.characters.find(c => c.id === charId); if(char) { if(!char.extra_portraits) char.extra_portraits = []; char.extra_portraits.push({emotion: 'happy', url: ''}); StateManager.saveState(); UIManager.openCharacterDetailModal(charId); } },
    removeExtraPortrait(charId, index) { const state = StateManager.getState(); const char = state.characters.find(c => c.id === charId); if(char && char.extra_portraits) { char.extra_portraits.splice(index, 1); StateManager.saveState(); UIManager.openCharacterDetailModal(charId); } },
    updateExtraPortrait: debounce(function(charId, index, field, value) { const state = StateManager.getState(); const char = state.characters.find(c => c.id === charId); if(char && char.extra_portraits && char.extra_portraits[index]) { char.extra_portraits[index][field] = value; StateManager.saveState(); } }, 300),
    toggleCharacterActive(event, id) { const state = StateManager.getState(); const char = state.characters.find(c => c.id === id); if (char) char.is_active = event.target.checked; StateManager.saveState(); UIManager.updateAICharacterSelector(); },
    
    addStaticEntry() { const state = StateManager.getState(); const newEntry = { id: UTILITY.uuid(), title: "New Static Entry", content: "" }; state.static_entries.push(newEntry); state.selectedStaticEntryId = newEntry.id; this.saveAndRenderStaticEntries(); },
    deleteStaticEntry(id) { const state = StateManager.getState(); state.static_entries = state.static_entries.filter(e => e.id !== id); if(state.selectedStaticEntryId === id) state.selectedStaticEntryId = null; this.saveAndRenderStaticEntries(); },
    selectStaticEntry(id) { StateManager.getState().selectedStaticEntryId = id; UIManager.renderStaticEntries(); },
    updateStaticEntryField: debounce(function(id, field, value) { 
        const state = StateManager.getState();
        const entry = state.static_entries.find(e => e.id === id); 
        if (entry) { 
            entry[field] = value; 
            StateManager.saveState(); 
        } 
    }, 300),

	addDynamicEntry() { 
        const state = StateManager.getState(); 
        // Create the new entry with the new data structure
        const newEntry = {
            id: UTILITY.uuid(), 
            title: "New Dynamic Entry", 
            triggers: "", 
            content_fields: [""], // Start with one empty content field
            current_index: 0,    // Start at index 0
            triggered_at_turn: null 
        };
        state.dynamic_entries.push(newEntry); 
        state.selectedDynamicEntryId = newEntry.id; 
        this.saveAndRenderDynamicEntries(); 
    },
    deleteDynamicEntry(id) { const state = StateManager.getState(); state.dynamic_entries = state.dynamic_entries.filter(e => e.id !== id); if(state.selectedDynamicEntryId === id) state.selectedDynamicEntryId = null; this.saveAndRenderDynamicEntries(); },
	selectDynamicEntry(id) { StateManager.getState().selectedDynamicEntryId = id; UIManager.renderDynamicEntries(); },
    
    /**
     * Updates top-level fields for a dynamic entry (title, triggers).
     */
    updateDynamicEntryField: debounce(function(id, field, value) { 
        const state = StateManager.getState();
        const entry = state.dynamic_entries.find(e => e.id === id); 
        if (entry && (field === 'title' || field === 'triggers')) { 
            entry[field] = value; 
            StateManager.saveState();
        } 
    }, 300),

    /**
     * [NEW] Adds a new, empty content field to a dynamic entry.
     */
    addDynamicContentField(entryId) {
        const state = StateManager.getState();
        const entry = state.dynamic_entries.find(e => e.id === entryId);
        if (entry) {
            entry.content_fields.push("");
            StateManager.saveState();
            UIManager.renderDynamicEntryDetails(); // Re-render just the details pane
        }
    },

    /**
     * [NEW] Updates a specific content field in the sequence (debounced).
     */
    updateDynamicContentField: debounce(function(entryId, index, value) {
        const state = StateManager.getState();
        const entry = state.dynamic_entries.find(e => e.id === entryId);
        if (entry && entry.content_fields[index] !== undefined) {
            entry.content_fields[index] = value;
            StateManager.saveState();
        }
    }, 300),

    addExampleDialogueTurn() {
        const state = StateManager.getState();
        const firstAiChar = state.characters.find(c => !c.is_user);
        if (!firstAiChar) {
            alert("Cannot add example dialogue without at least one AI character.");
            return;
        }
        state.chat_history.push({ character_id: firstAiChar.id, content: "New example dialogue.", type: 'chat', emotion: 'neutral', timestamp: new Date().toISOString(), isHidden: true });
        StateManager.saveState();
        UIManager.renderExampleDialogueModal();
    },
	
	/** * Uses AI to generate content for a dynamic knowledge entry.
     * [MODIFIED] Now accepts an index to update a specific field.
     */
    async generateDynamicEntryContentAI(event, entryId, index) { // <-- Added index
        const state = StateManager.getState();
        const entry = state.dynamic_entries.find(e => e.id === entryId);
        if (!entry || entry.content_fields[index] === undefined) return;

        const newContent = await this._generateContentForField(event, state.prompt_entry_gen, {
            title: entry.title,
            triggers: entry.triggers
        });

        if (newContent !== null) {
            // Update the specific field in the array
            entry.content_fields[index] = newContent;
            StateManager.saveState();
            // Re-render the details to show the new content
            UIManager.renderDynamicEntryDetails();
        }
    },
	
    deleteExampleDialogueTurn(originalIndex) {
        const state = StateManager.getState();
        state.chat_history.splice(originalIndex, 1);
        StateManager.saveState();
        UIManager.renderExampleDialogueModal();
    },
    updateExampleDialogueTurn: debounce(function(originalIndex, field, value) {
        const state = StateManager.getState();
        if (state.chat_history[originalIndex]) {
            state.chat_history[originalIndex][field] = value;
            StateManager.saveState();
        }
    }, 300),
    moveExampleDialogueTurn(originalIndex, direction) {
        const state = StateManager.getState();
        const history = state.chat_history;
        const itemToMove = history[originalIndex];
        if (!itemToMove) return;

        let swapIndex = -1;
        if (direction === 'up') {
            for (let i = originalIndex - 1; i >= 0; i--) { if (history[i].isHidden) { swapIndex = i; break; } }
        } else {
            for (let i = originalIndex + 1; i < history.length; i++) { if (history[i].isHidden) { swapIndex = i; break; } }
        }

        if (swapIndex !== -1) {
            const temp = history[swapIndex];
            history[swapIndex] = itemToMove;
            history[originalIndex] = temp;
            StateManager.saveState();
            UIManager.renderExampleDialogueModal();
        }
    },

    openViewRawPromptModal() {
        if (!StateManager.getLibrary().active_narrative_id) { 
            alert("Please load a narrative first."); 
            return; 
        }
        
        let charToActId = document.getElementById('ai-character-selector').value;
        
        if (charToActId === 'any' || !charToActId) {
            console.log("View Raw Prompt: 'Any' selected, determining next speaker.");
            charToActId = this.determineNextSpeaker(false);
        }

        if (!charToActId) {
            alert("Could not determine an AI character to generate a prompt for. Please ensure at least one AI character is active.");
            return;
        }

        const prompt = PromptBuilder.buildPrompt(charToActId);
        document.getElementById('raw-prompt-content').textContent = prompt;
        this.openModal('view-raw-prompt-modal');
    },

    copyMessage(index) {
        const state = StateManager.getState();
        const message = state.chat_history[index];
        if (!message) return;
        
        const tempTextarea = document.createElement('textarea');
        tempTextarea.value = message.content;
        document.body.appendChild(tempTextarea);
        tempTextarea.select();
        try {
            document.execCommand('copy');
            const copyBtn = document.querySelector(`[data-message-index='${index}'] .action-btn-group button[title='Copy']`);
            if (copyBtn) {
                const originalIcon = copyBtn.innerHTML;
                copyBtn.innerHTML = `<span class="text-xs text-green-400">Copied!</span>`;
                setTimeout(() => { copyBtn.innerHTML = originalIcon; }, 1500);
            }
        } catch (err) {
            console.error('Failed to copy text: ', err);
        }
        document.body.removeChild(tempTextarea);
    },
    
    deleteMessage(index) {
        UIManager.showConfirmationModal('Are you sure you want to permanently delete this message?', () => {
            const state = StateManager.getState();
            const messageToDelete = state.chat_history[index];
            if (messageToDelete && messageToDelete.type === 'chat') {
                state.messageCounter--;
            }
            state.chat_history.splice(index, 1);
            this.saveAndRender();
        });
    },

    stopGeneration() {
        if (this.RUNTIME.activeRequestAbortController) {
            this.RUNTIME.activeRequestAbortController.abort();
            console.log("Request aborted by user.");
        }
        
        const state = StateManager.getState();
        if (state.apiProvider === 'koboldcpp' && state.koboldcpp_url) {
            fetch(`${state.koboldcpp_url}/api/v1/generate/stop`, { method: 'POST' })
                .catch(err => console.error("Failed to send stop request to KoboldCPP:", err));
        }

        UIManager.hideTypingIndicator();
        UIManager.setButtonToSendMode();
        this.RUNTIME.activeRequestAbortController = null;
    },

    // --- World Map Functions ---
    async generateWorldMap(event) {
        UIManager.showConfirmationModal('This will overwrite the existing world map with an AI-generated one and may incur API costs. Are you sure?', async () => {
            const state = StateManager.getState();
            
            const context = {
                characters: state.characters.map(c => `${c.name}: ${c.short_description}`).join('\n'),
                static: (state.static_entries || []).map(e => `* ${e.title}: ${e.content}`).join('\n'),
                recent: (state.chat_history || []).filter(m => m.type === 'chat').slice(-3).map(m => m.content).join('\n---\n'),
            };

            const newGridData = await this._generateContentForField(event, state.prompt_world_map_gen, context, true);
            
            if (newGridData) {
                try {
                    const newWorld = JSON.parse(newGridData);
                    if (newWorld.grid && newWorld.grid.length > 0) {
                        newWorld.grid.forEach(loc => loc.local_static_entries = []);
                        state.worldMap.grid = newWorld.grid;
                        state.worldMap.currentLocation = { x: 4, y: 4 };
                        state.worldMap.destination = { x: null, y: null };
                        state.worldMap.path = [];
                        this.RUNTIME.selectedMapTile = null;
                        StateManager.saveState();
                        UIManager.renderWorldMapModal();
                        UIManager.applyStyling(); 
                    } else {
                        throw new Error("Generated data is not a valid grid.");
                    }
                } catch (e) {
                     console.error("World Map generation failed to parse JSON:", e);
                     alert("Failed to generate world map. The AI returned an invalid format.");
                }
            }
        });
    },

    moveToLocation(x, y) {
        const state = StateManager.getState();
        const targetLocation = state.worldMap.grid.find(loc => loc.coords.x === x && loc.coords.y === y);
        if (targetLocation) {
            const previousLocationCoords = { ...state.worldMap.currentLocation };
            const turnOfDeparture = state.messageCounter;

            if (this.RUNTIME.turnOfArrival !== null && turnOfDeparture > this.RUNTIME.turnOfArrival) {
                 this.summarizeActivityForLocation(previousLocationCoords, this.RUNTIME.turnOfArrival);
            }

            state.worldMap.currentLocation = { x, y };
            this.RUNTIME.turnOfArrival = state.messageCounter;

            if (state.worldMap.destination && state.worldMap.destination.x !== null) {
                state.worldMap.path = UTILITY.findPath(state.worldMap.grid, state.worldMap.currentLocation, state.worldMap.destination);
            } else {
                 state.worldMap.path = [];
            }
            
            this.addSystemMessageToHistory(`You have moved to ${targetLocation.name}.`);
            this.RUNTIME.selectedMapTile = null;
            this.RUNTIME.pendingMove = null;
            StateManager.saveState();
            UIManager.applyStyling();
            
            const narrator = state.characters.find(c => c.is_narrator && c.is_active);
            if (narrator) {
                this.triggerAIResponse(narrator.id, '', true);
            } else {
                this.triggerAIResponse(null, '', true);
            }
        }
    },

    async summarizeActivityForLocation(locationCoords, startTurn) {
        try {
            const state = StateManager.getState();
            const endTurn = state.messageCounter;
            
            const relevantHistory = state.chat_history.slice(startTurn, endTurn).filter(msg => msg.type === 'chat' && !msg.isHidden);

            if (relevantHistory.length === 0) {
                console.log("No new chat activity to summarize for location:", locationCoords);
                return;
            }

            const chatTranscript = relevantHistory.map(msg => {
                const char = state.characters.find(c => c.id === msg.character_id);
                return `${char ? char.name : 'Unknown'}: ${msg.content}`;
            }).join('\n');
            
            const prompt = state.prompt_location_memory_gen.replace('{transcript}', chatTranscript);
            const summaryContent = await APIService.callAI(prompt);

            const currentState = StateManager.getState();
            const location = currentState.worldMap.grid.find(loc => loc.coords.x === locationCoords.x && loc.coords.y === locationCoords.y);
            if (location) {
                if (!location.local_static_entries) {
                    location.local_static_entries = [];
                }
                const newEntry = {
                    id: UTILITY.uuid(),
                    title: `Events from turn ${startTurn} to ${endTurn}`,
                    content: summaryContent
                };
                location.local_static_entries.push(newEntry);
                StateManager.saveState();
                console.log("Location memory auto-generated for:", location.name);
            }
        } catch (error) {
            console.error("Failed to auto-generate location memory:", error);
        }
    },
    
    selectMapTile(x, y) {
        const state = StateManager.getState();
        const tile = state.worldMap.grid.find(loc => loc.coords.x === x && loc.coords.y === y);
        this.RUNTIME.selectedMapTile = tile || null;
        this.RUNTIME.selectedLocalStaticEntryId = null;
        UIManager.renderWorldMapModal();
    },

    selectPendingMove(x, y) {
        this.RUNTIME.pendingMove = { x, y };
        UIManager.renderWorldMapModal();
    },

    confirmMove() {
        const state = StateManager.getState();
        const { pendingMove } = this.RUNTIME;
        const { currentLocation } = state.worldMap;

        if (pendingMove && (pendingMove.x !== currentLocation.x || pendingMove.y !== currentLocation.y)) {
            this.moveToLocation(pendingMove.x, pendingMove.y);
        }

        this.RUNTIME.pendingMove = null;
        this.closeModal('world-map-modal');
    },

    setDestination() {
        const state = StateManager.getState();
        const selected = this.RUNTIME.selectedMapTile;
        if (!selected) return;

        state.worldMap.destination = selected.coords;
        state.worldMap.path = UTILITY.findPath(state.worldMap.grid, state.worldMap.currentLocation, selected.coords);
        StateManager.saveState();
        UIManager.renderWorldMapModal();
    },

    updateLocationDetail: debounce(function(field, value) {
        const state = StateManager.getState();
        const selected = this.RUNTIME.selectedMapTile;
        if (!selected) return;
        const locationInGrid = state.worldMap.grid.find(loc => loc.coords.x === selected.coords.x && loc.coords.y === selected.coords.y);
        if (locationInGrid) {
            locationInGrid[field] = value;
            StateManager.saveState();
        }
    }, 500),

    addLocalStaticEntry() {
        const location = this.RUNTIME.selectedMapTile;
        if (!location) return;
        if (!location.local_static_entries) location.local_static_entries = [];
        const newEntry = { id: UTILITY.uuid(), title: "New Local Entry", content: "" };
        location.local_static_entries.push(newEntry);
        this.RUNTIME.selectedLocalStaticEntryId = newEntry.id;
        StateManager.saveState();
        UIManager.renderLocalStaticEntriesList();
        UIManager.renderLocalStaticEntryDetails();
    },
    
    deleteLocalStaticEntry(entryId) {
        const location = this.RUNTIME.selectedMapTile;
        if (!location || !location.local_static_entries) return;
        location.local_static_entries = location.local_static_entries.filter(e => e.id !== entryId);
        if (this.RUNTIME.selectedLocalStaticEntryId === entryId) {
            this.RUNTIME.selectedLocalStaticEntryId = null;
        }
        StateManager.saveState();
        UIManager.renderLocalStaticEntriesList();
        UIManager.renderLocalStaticEntryDetails();
    },
    
    selectLocalStaticEntry(entryId) {
        this.RUNTIME.selectedLocalStaticEntryId = entryId;
        UIManager.renderLocalStaticEntriesList();
        UIManager.renderLocalStaticEntryDetails();
    },
    
    updateLocalStaticEntryField: debounce(function(entryId, field, value) {
        const location = this.RUNTIME.selectedMapTile;
        if (!location || !location.local_static_entries) return;
        const entry = location.local_static_entries.find(e => e.id === entryId);
        if (entry) {
            entry[field] = value;
            StateManager.saveState();
            if (field === 'title') {
                UIManager.renderLocalStaticEntriesList();
            }
        }
    }, 300),

	async elevateNarrativeToScenario(storyId, narrativeId) {
        UIManager.showLoadingSpinner('Creating scenario...');
        try {
            const story = await DBService.getStory(storyId);
            const narrative = await DBService.getNarrative(narrativeId);
            if (!story || !narrative) throw new Error("Data not found.");

            const firstMessage = (narrative.state.chat_history || []).find(m => !m.isHidden && m.type === 'chat');
            const exampleDialogue = (narrative.state.chat_history || []).filter(m => m.isHidden);

            // --- NEW: Capture Active IDs Only ---
            // We use the list stored in the narrative, or derive it if missing
            let activeIDs = narrative.active_character_ids;
            if (!activeIDs) {
                // Fallback for older narratives: assume everyone in story is active (or just user)
                activeIDs = (story.characters || []).map(c => c.id);
            }
            // ------------------------------------

            const newScenario = {
                id: UTILITY.uuid(),
                name: `${narrative.name} (Scenario)`,
                message: firstMessage ? firstMessage.content : "The story continues...",
                
                // Narrative Data
                static_entries: JSON.parse(JSON.stringify(narrative.state.static_entries || [])),
                worldMap: JSON.parse(JSON.stringify(narrative.state.worldMap || {})),
                example_dialogue: JSON.parse(JSON.stringify(exampleDialogue)),
                
                // --- NEW: Store IDs, NOT full objects ---
                active_character_ids: activeIDs,
                
                // Snapshot other settings (Prompts/Dynamic/UI)
                // We still snapshot prompts because those can change per run,
                // but we DON'T snapshot the 'characters' array anymore.
                dynamic_entries: JSON.parse(JSON.stringify(story.dynamic_entries || [])),
                prompts: {
                    system_prompt: story.system_prompt,
                    event_master_base_prompt: story.event_master_base_prompt,
                    prompt_persona_gen: story.prompt_persona_gen,
                    prompt_world_map_gen: story.prompt_world_map_gen,
                    prompt_location_gen: story.prompt_location_gen,
                    prompt_entry_gen: story.prompt_entry_gen,
                    prompt_location_memory_gen: story.prompt_location_memory_gen,
                    font: story.font,
                    backgroundImageURL: story.backgroundImageURL,
                    bubbleOpacity: story.bubbleOpacity,
                    chatTextColor: story.chatTextColor
                }
            };

            story.scenarios.push(newScenario);
            story.last_modified = new Date().toISOString();
            await DBService.saveStory(story);

            // Update in-memory
            const library = StateManager.getLibrary();
            const storyInLibrary = library.stories.find(s => s.id === storyId);
            if (storyInLibrary) {
                storyInLibrary.scenarios = story.scenarios;
                storyInLibrary.last_modified = story.last_modified;
            }

            UIManager.openStoryDetails(storyId);
        } catch (e) {
            console.error("Failed to elevate narrative:", e);
            alert(`Error: ${e.message}`);
        } finally {
            UIManager.hideLoadingSpinner();
        }
    },
    
    // --- Import / Export ---

    /**
     * Handles a single file upload from the I/O Hub, routing it to the ImportExportService.
     * @param {Event} event - The file input change event.
     */
async handleFileUpload(event) {
        const file = event.target.files[0];
        if (!file) return;

        UIManager.showLoadingSpinner('Parsing file...');
		try {
            const { story: newStory, imageBlob } = await ImportExportService.parseUploadedFile(file);
            const library = StateManager.getLibrary();

            // --- START OF NEW/FIXED LOGIC ---

            // 1. Check for name conflicts (this part was already correct)
            const existingStory = library.stories.find(s => s.name && newStory.name && s.name.toLowerCase() === newStory.name.toLowerCase());
            if (existingStory) {
                const now = new Date();
                const timestamp = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')} ${String(now.getHours()).padStart(2, '0')}-${String(now.getMinutes()).padStart(2, '0')}-${String(now.getSeconds()).padStart(2, '0')}`;
                newStory.name = `${newStory.name} - ${timestamp}`;
                console.log(`Duplicate story name found. Renaming imported story to: ${newStory.name}`);
            }

            // 2. Separate narratives from the story object
            const narratives = newStory.narratives || [];
            
            // 3. Create stubs for the story object
            const narrativeStubs = narratives.map(n => ({ id: n.id, name: n.name, last_modified: n.last_modified }));
            newStory.narratives = narrativeStubs;

            // 4. Save the story (metadata) and all its narratives (heavy data)
            await DBService.saveStory(newStory);
            if (narratives.length > 0) {
                await Promise.all(narratives.map(n => DBService.saveNarrative(n)));
            }
            
            // 5. Add the new story (with stubs) to the in-memory library
            library.stories.push(newStory);

            // --- END OF NEW/FIXED LOGIC ---

            // 6. Save the image (this part was already correct)
            const primaryAiChar = newStory.characters?.find(c => !c.is_user);
            if (imageBlob && primaryAiChar && primaryAiChar.id) {
                const savedToDB = await DBService.saveImage(primaryAiChar.id, imageBlob);

                if (savedToDB) {
                    console.log(`Image saved to DB for ${primaryAiChar.id}, updating cache.`);
                    UIManager.RUNTIME.characterImageCache = UIManager.RUNTIME.characterImageCache || {};
                    const oldUrl = UIManager.RUNTIME.characterImageCache[primaryAiChar.id];
                    if (oldUrl) {
                        URL.revokeObjectURL(oldUrl);
                    }
                    UIManager.RUNTIME.characterImageCache[primaryAiChar.id] = URL.createObjectURL(imageBlob);
                } else {
                     console.warn(`Failed to save image to DB for ${primaryAiChar.id}, cache not updated.`);
                }
            }

            // 7. Update caches and UI (this part was already correct)
            this.updateSearchIndex(newStory);
            StateManager.updateTagCache();
            // saveLibrary() is fine, it just saves active IDs to localStorage
            StateManager.saveLibrary(); 
            UIManager.hideLoadingSpinner();
            alert(`Story "${newStory.name}" imported successfully!`);
            UIManager.renderLibraryInterface();
            this.closeModal('io-hub-modal');

        } catch (err) {
            UIManager.hideLoadingSpinner();
            alert(`Error importing file: ${err.message}`);
            console.error(err);
        } finally {
            event.target.value = ''; // Reset file input
        }
    },

    /**
     * Initiates the bulk import process by opening a directory picker.
     */
    async handleBulkImport() {
        if (!window.showDirectoryPicker) {
            alert("Your browser does not support directory selection. Please use a modern browser like Chrome or Edge.");
            return;
        }
        try {
            const dirHandle = await window.showDirectoryPicker();
            UIManager.showLoadingSpinner('Starting bulk import...');
            
            let processedFiles = 0;
            const failedFiles = [];
            const importedStoryNames = [];
            const library = StateManager.getLibrary();
            let totalSize = 0;

            const storageAvailable = UTILITY.checkLocalStorageQuota(totalSize);
            
		for await (const entry of dirHandle.values()) {
                // --- ADDED CHECKS ---
                if (entry.kind !== 'file' || typeof entry.name !== 'string' || !entry.name) {
                    // Skip if not a file, or if name isn't a non-empty string
                    console.warn("Skipping directory entry:", entry);
                    continue;
                }
                // --- END CHECKS ---

                // Now it's safe to use .toLowerCase()
                const lowerCaseName = entry.name.toLowerCase();

                if (lowerCaseName.endsWith('.png') || lowerCaseName.endsWith('.byaf') || lowerCaseName.endsWith('.zip')) {
                    UIManager.showLoadingSpinner(`Processing file ${++processedFiles}: ${entry.name}`);
                    let currentFileNameForError = entry.name; // Store name for potential error message
                    try {
                        const file = await entry.getFile();
                        if (!file || typeof file.name !== 'string' || !file.name) {
                             // Add a check for the File object itself, just in case
                            throw new Error("Could not retrieve a valid File object from the directory entry.");
                        }
                        currentFileNameForError = file.name; // Update with potentially more accurate name

                        const { story: newStory, imageBlob } = await ImportExportService.parseUploadedFile(file, !storageAvailable);

                        if (!newStory || typeof newStory.name !== 'string') {
                             // Check the result of parsing too
                             throw new Error("File parsed, but did not result in a valid story object with a name.");
                        }

                        // Check for existing story (uses newStory.name)
                        const existingStory = library.stories.find(s => s.name && s.name.toLowerCase() === newStory.name.toLowerCase());
                        if (existingStory) {
                            const now = new Date();
                            const timestamp = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')} ${String(now.getHours()).padStart(2, '0')}-${String(now.getMinutes()).padStart(2, '0')}-${String(now.getSeconds()).padStart(2, '0')}`;
                            newStory.name = `${newStory.name} - ${timestamp}`;
                        }

                        library.stories.push(newStory);

                        // --- IMAGE SAVING (Needs primary char ID) ---
                        const primaryAiChar = newStory.characters?.find(c => !c.is_user);
                        if (imageBlob && primaryAiChar && primaryAiChar.id) {
                            try {
                                // Use await here to ensure saving attempt before continuing loop potentially
                                const savedToDB = await DBService.saveImage(primaryAiChar.id, imageBlob);
								if (savedToDB) {
                                     console.log(`Bulk Import: Image saved to DB for ${primaryAiChar.id}, updating cache.`);
                                    // Ensure cache exists
                                    UIManager.RUNTIME.characterImageCache = UIManager.RUNTIME.characterImageCache || {};
                                    // Revoke old URL if replacing image for the same ID (less likely in bulk import but good practice)
                                    const oldUrl = UIManager.RUNTIME.characterImageCache[primaryAiChar.id];
                                    if (oldUrl) {
                                        URL.revokeObjectURL(oldUrl);
                                    }
                                    // Add new blob URL to cache
                                    UIManager.RUNTIME.characterImageCache[primaryAiChar.id] = URL.createObjectURL(imageBlob);
                                } else {
                                     console.warn(`Bulk Import: Failed to save image to DB for ${primaryAiChar.id}, cache not updated.`);
                                }
                            } catch (dbSaveError) {
                                 console.warn(`Failed to save image to DB for ${primaryAiChar.id} (${newStory.name}) during bulk import:`, dbSaveError);
                                 // Continue import without the image
                            }
                        }
                         // --- END IMAGE SAVING ---

                        this.updateSearchIndex(newStory);
                        importedStoryNames.push(newStory.name);

                    } catch (err) {
                        // --- SAFER ERROR LOGGING ---
                        console.error(`Failed processing ${currentFileNameForError}:`, err);
                        // Ensure err.message exists, provide fallback
                        failedFiles.push({ name: currentFileNameForError, reason: (err && err.message) ? err.message : 'Unknown processing error' });
                        // --- END SAFER LOGGING ---
                    }
                }
            } // End for await loop

            StateManager.updateTagCache();
            StateManager.saveLibrary();
            UIManager.hideLoadingSpinner();
            UIManager.showBulkImportReport(importedStoryNames, failedFiles);
            UIManager.renderLibraryInterface();

        } catch (err) {
            UIManager.hideLoadingSpinner();
            console.error("Bulk import failed:", err);
            if (err.name !== 'AbortError') {
                alert(`An error occurred during bulk import: ${err.message}`);
            }
        }
    },

    /**
     * Handles the export process based on user selections in the I/O Hub.
     * @param {'json'|'png'|'byaf'} format - The desired export format.
     */
    async exportStoryAs(format) {
        const storySelector = document.getElementById('story-export-selector');
        const narrativeSelector = document.getElementById('narrative-export-selector');
        const storyId = storySelector.value;
        const narrativeId = narrativeSelector.value;

        if (!storyId || !narrativeId) {
            alert("Please select a story and a narrative to export.");
            return;
        }

        if (format !== 'json') {
            const proceed = await UIManager.showConfirmationPromise("Exporting to a non-Ellipsis format may result in data loss (e.g., extra characters, world map details). Continue?");
            if (!proceed) return;
        }

        UIManager.showLoadingSpinner(`Exporting as ${format.toUpperCase()}...`);
try {
            const library = StateManager.getLibrary();
            const story = library.stories.find(s => s.id === storyId);
            // Find narrative within the correct story object from the library
            const narrative = story?.narratives.find(n => n.id === narrativeId);
            // Get primary character if needed, also from the correct story object
            const charSelector = document.getElementById('character-export-selector');
            const primaryCharId = (format === 'png' || format === 'byaf') ? charSelector?.value : null;
            const primaryChar = primaryCharId ? story?.characters.find(c => c.id === primaryCharId) : null;


            if (!story || !narrative) {
                 throw new Error("Selected story or narrative not found.");
            }
             if ((format === 'png' || format === 'byaf') && !primaryChar) {
                 throw new Error("Primary character selection is required for PNG/BYAF export and was not found.");
             }


            let blob, filename;

            switch(format) {
                case 'json':
                    // This service function returns the Blob directly
                    blob = ImportExportService.exportStoryAsJSON(story);
                    filename = `${story.name || 'story'}.json`; // Use story name for JSON export
                    break;
                case 'png':
                    if (!primaryCharId) throw new Error("Please select a primary character for PNG export.");
                    // This service function returns a Promise<Blob>
                    blob = await ImportExportService.exportStoryAsV2(story, narrative, primaryCharId);
                    filename = `${story.name || 'story'}_${primaryChar?.name || 'character'}.png`;
                    break;
                case 'byaf':
                     if (!primaryCharId) throw new Error("Please select a primary character for BYAF export.");
                     // This service function returns a Promise<Blob>
                     blob = await ImportExportService.exportStoryAsBYAF(story, narrative, primaryCharId);
                     filename = `${story.name || 'story'}_${primaryChar?.name || 'character'}.byaf`;
                    break;
                default:
                    throw new Error("Unsupported export format.");
            }

            // Ensure blob is actually a Blob before proceeding
            if (!(blob instanceof Blob)) {
                console.error("Export function did not return a Blob:", blob);
                throw new Error(`Export process failed internally for format: ${format}. Expected a Blob.`);
            }

            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            // Sanitize filename (basic example, might need more robust sanitization)
            a.download = filename.replace(/[/\\?%*:|"<>]/g, '-');
            document.body.appendChild(a); // Append link to body for Firefox compatibility
            a.click();
            document.body.removeChild(a); // Clean up link
            URL.revokeObjectURL(url);

        } catch (e) {
            alert(`Export failed: ${e.message}`);
            console.error("Export error:", e);
        } finally {
            UIManager.hideLoadingSpinner();
        }
    },

    // --- Helper & Utility Actions ---
    _ensureCharacterColors() {
        const state = StateManager.getState();
        if (!state || !state.characters) return;
        let aiCharCount = 0;
        state.characters.forEach(char => {
            if (!char.is_user) {
                 if (!char.color || typeof char.color !== 'object') { 
                    char.color = this.CONSTANTS.CHARACTER_COLORS[aiCharCount % this.CONSTANTS.CHARACTER_COLORS.length];
                 }
                aiCharCount++;
            }
        });
    },
    saveAndRender() { StateManager.saveState(); UIManager.renderAll(); },
    saveAndRenderStaticEntries() { StateManager.saveState(); UIManager.renderStaticEntries(); },
    saveAndRenderDynamicEntries() { StateManager.saveState(); UIManager.renderDynamicEntries(); },
};

/**
 * =================================================================================================
 * app Module (The Initializer)
 * =================================================================================================
 * This is the main entry point of the application. It initializes all the other modules
 * and sets up the initial event listeners.
 */
const app = {
  async init() {
  
  if ('scrollRestoration' in history) {
        history.scrollRestoration = 'manual';
    }
  
// --- NEW: ONE-TIME MIGRATION LOGIC ---
    
    // 1. Init the DB service first. Must be version 2.
    let dbReady = false;
    try {
      await DBService.init(); // This will try to open version 2
      dbReady = true;
    } catch (e) {
      console.error("CRITICAL: DBService failed to init. App cannot start.", e);
      alert("Error: Your browser's database failed to start. The app cannot load.");
      return;
    }

    // 2. Check if migration has already been run.
    const migrationFlag = 'v2_idb_migration_complete';
    if (!localStorage.getItem(migrationFlag)) {
        console.log("No migration flag found. Checking for old localStorage data...");
        
        // 3. Try to get the old library data
        const oldLibraryJSON = localStorage.getItem('aiStorytellerLibrary');
        
        if (oldLibraryJSON) {
            console.log("Old library data found. Starting migration to IndexedDB...");
            UIManager.showLoadingSpinner("Upgrading database... Please wait.");
            
            try {
                const parsedLibrary = JSON.parse(oldLibraryJSON);
                
                if (parsedLibrary.stories && parsedLibrary.stories.length > 0) {
                    for (const story of parsedLibrary.stories) {
                        // a. Split the story into metadata and narratives
                        const narrativeStubs = [];
                        
                        if (story.narratives && story.narratives.length > 0) {
                            for (const narrative of story.narratives) {
                                // Save the full narrative object to IDB
                                await DBService.saveNarrative(narrative);
                                // Create a stub for the story object
                                narrativeStubs.push({ id: narrative.id, name: narrative.name });
                            }
                        }
                        
                        // b. Create the new story metadata object
                        const storyData = { ...story };
                        delete storyData.narratives; // Remove heavy data
                        storyData.narratives = narrativeStubs; // Replace with light stubs
                        
                        // c. Save the story metadata object to IDB
                        await DBService.saveStory(storyData);
                    }
                }
                
                // 4. Set the active IDs from the old library
                localStorage.setItem('active_story_id', parsedLibrary.active_story_id || null);
                localStorage.setItem('active_narrative_id', parsedLibrary.active_narrative_id || null);

                // 5. Migration successful! Set flag and clean up.
                console.log(`Migration complete! Moved ${parsedLibrary.stories.length} stories.`);
                localStorage.setItem(migrationFlag, 'true');
                localStorage.removeItem('aiStorytellerLibrary'); // Clean up old 5MB+ key
                
            } catch (e) {
                console.error("Migration failed:", e);
                UIManager.hideLoadingSpinner(); // Make sure spinner hides on fail
                alert("An error occurred while upgrading your database. Old data may not be available.");
                localStorage.setItem(migrationFlag, 'failed'); // Avoid re-running a failed migration
            }
        } else {
            // No old data, just set the flag.
            console.log("No old library data found. Setting migration flag.");
            localStorage.setItem(migrationFlag, 'true');
        }
        
        // We always hide spinner, even if no migration was needed
        UIManager.hideLoadingSpinner(); 
    }
    // --- END OF MIGRATION LOGIC ---
	
	// --- [NEW] ONE-TIME MIGRATION FOR DYNAMIC ENTRIES --- [REMOVE THIS CODE LATER]
    const dynamicEntryMigrationFlag = 'v3_dynamic_entry_migration_complete';
    if (!localStorage.getItem(dynamicEntryMigrationFlag)) {
        console.log("Running one-time migration for dynamic entries...");
        UIManager.showLoadingSpinner("Updating data structure...");

        try {
            // 1. Fetch ALL stories directly from the database
            const allStories = await DBService.getAllStories();
            let storiesToUpdate = [];

            for (const story of allStories) {
                let storyWasModified = false;
                
                if (story.dynamic_entries && Array.isArray(story.dynamic_entries)) {
                    // 2. Iterate through each dynamic entry
                    for (const entry of story.dynamic_entries) {
                        
                        // 3. Check if it's the old model (has 'content' and not 'content_fields')
                        if (entry.content !== undefined && entry.content_fields === undefined) {
                            
                            // 4. Perform the migration
                            console.log(`Migrating entry: ${entry.title} in story: ${story.name}`);
                            entry.content_fields = [entry.content || ""]; // Create array from old string
                            entry.current_index = 0;                     // Add new required field
                            delete entry.content;                        // Delete old, invalid field
                            
                            storyWasModified = true;
                        }
                    }
                }
                
                if (storyWasModified) {
                    // 5. Add the modified story to the update queue
                    storiesToUpdate.push(story);
                }
            }

            // 6. Save all modified stories back to the database
            if (storiesToUpdate.length > 0) {
                console.log(`Saving ${storiesToUpdate.length} updated stories...`);
                await Promise.all(storiesToUpdate.map(story => DBService.saveStory(story)));
            }

            // 7. Set the flag so it doesn't run again
            localStorage.setItem(dynamicEntryMigrationFlag, 'true');
            console.log("Dynamic entry migration complete.");

        } catch (err) {
            console.error("Critical error during dynamic entry migration:", err);
            alert("An error occurred while updating your story data. Some entries might still be in the old format.");
        } finally {
            UIManager.hideLoadingSpinner(); // Always hide spinner
        }
    }
    // --- END OF NEW MIGRATION ---	
	
	// Load data first (NOW reads from IDB via StateManager)
    await StateManager.loadLibrary();
    
    const library = StateManager.getLibrary();
	
    if (library.stories.length === 0) {
      // This is now an async function
      const { newStory, newNarrative } = await StoryService.createDefaultStoryAndNarrative();
      // Manually set the active session and reload
      localStorage.setItem('active_story_id', newStory.id);
      localStorage.setItem('active_narrative_id', newNarrative.id);
      window.location.reload();
      return; // The create function reloads the page
    }
	
	// --- [NEW] HYDRATE ALL IMAGES ---
    // We run this *after* loading the library stubs and *before* loading the active state.
    // This populates the cache for the entire library, fixing the Story Library bug.
    if (dbReady && library.stories && library.stories.length > 0) {
        console.log(`Hydrating images for ${library.stories.length} stories...`);
        UIManager.RUNTIME.characterImageCache = UIManager.RUNTIME.characterImageCache || {};
        
        // Loop over ALL stories in the library
        for (const story of library.stories) {
            if (!story.characters) continue;
            
            // Loop over ALL characters in each story
            for (const char of story.characters) {
                try {
                    // 1. Hydrate base portrait
                    // We check if it's already cached to avoid duplicate DB calls/blob URLs
                    if (!UIManager.RUNTIME.characterImageCache[char.id]) {
                        const blob = await DBService.getImage(char.id);
                        if (blob) {
                            UIManager.RUNTIME.characterImageCache[char.id] = URL.createObjectURL(blob);
                        }
                    }

                    // 2. Hydrate emotion portraits
                    if (Array.isArray(char.extra_portraits)) {
                        for (const p of char.extra_portraits) {
                            const emotion = (p.emotion || 'neutral').toLowerCase();
                            const emoKey = `${char.id}::emotion::${emotion}`;
                            if (!UIManager.RUNTIME.characterImageCache[emoKey]) {
                                const blob = await DBService.getImage(emoKey);
                                if (blob) {
                                    UIManager.RUNTIME.characterImageCache[emoKey] = URL.createObjectURL(blob);
                                }
                            }
                        }
                    }
                } catch (e) {
                    console.warn("getImage failed for char", char.id, e);
                }
            }
        }
        console.log("Image hydration complete.");
    }
    // --- END NEW IMAGE HYDRATION ---
	
	// Now, load the active narrative
    await StateManager.loadActiveNarrative();
    
    const state = StateManager.getState();

    // --- Make the UI responsive immediately (listeners + layout + send-button state) ---
    // Doing this early ensures you don't get stuck in vertical-only layout with dead buttons.
    this.setupEventListeners();            // calls updateLayout() internally on load and on resize
    UIManager.setButtonToSendMode();       // ensures the input button is in the correct mode

    // --- Try IndexedDB, but DO NOT let it block the UI ---
    dbReady = false;
    try {
      await DBService.init();              // DBService is fail-soft; still guard with try/catch
      dbReady = true;
    } catch (e) {
      console.warn("DB init failed; proceeding without image cache", e);
    }

    // Always have a cache objecteven if DB isn't ready
    UIManager.RUNTIME.characterImageCache = UIManager.RUNTIME.characterImageCache || {};

    // --- One-time image migration from legacy image_url/LocalStorage into IndexedDB ---
    // Define helpers locally so they don't leak globals.
    async function migrateLegacyImagesToIDB(root) {
      if (!root) return;

      // Accept either an active narrative with characters, or the full library
      const characters =
        root.characters ? root.characters :
        (root.stories && Array.isArray(root.stories))
          ? root.stories.flatMap(s => s.characters || [])
          : [];

      if (!characters || characters.length === 0) return;

      let changed = false;

      for (const char of characters) {
        try {
          // If there is already a blob in IDB for this char, skip
          const existing = await DBService.getImage(char.id);
          if (existing) continue;

          // If the character has a legacy inline/base64 or remote URL, try to fetch and store
          const url = (char.image_url || '').trim();
          if (!url) continue;

          const blob = url.startsWith('data:')
            ? dataURLToBlob(url)
            : await fetch(url, { cache: 'no-store' }).then(r => (r.ok ? r.blob() : null));

          if (blob) {
            // Save under the base key = char.id (keeps compatibility with your current hydrator)
            await DBService.saveImage(char.id, blob);

            // Normalize model to IDB-backed
            char.image_url = '';

            // Live-cache for immediate UI usage
            const oldUrl = UIManager.RUNTIME.characterImageCache[char.id];
            if (oldUrl) URL.revokeObjectURL(oldUrl);
            UIManager.RUNTIME.characterImageCache[char.id] = URL.createObjectURL(blob);

            changed = true;
          }
        } catch (e) {
          console.warn('Legacy image migration failed for char', char?.id, e);
          // leave image_url as-is; renderers will still fall back to it if present
        }
      }

      if (changed) {
        StateManager.saveLibrary?.();
        // Minimal repaint to reflect newly cached portraits
        UIManager.renderCharacters?.();
        const active = StateManager.getState?.();
        if (active?.lastSpeakerId) {
          UIManager.updateSidePortrait?.(active.lastSpeakerId);
        }
      }
    }

    function dataURLToBlob(dataUrl) {
      const [header, data] = dataUrl.split(',');
      const isBase64 = /;base64$/i.test(header);
      const mime = (header.match(/data:(.*?)(;|$)/) || [])[1] || 'application/octet-stream';
      const bytes = isBase64 ? atob(data) : decodeURIComponent(data);
      const arr = new Uint8Array(bytes.length);
      for (let i = 0; i < bytes.length; i++) arr[i] = bytes.charCodeAt(i);
      return new Blob([arr], { type: mime });
    }

    // Run migration only if DB is ready
    if (dbReady) {
      try {
        await migrateLegacyImagesToIDB(
          StateManager.getState() || StateManager.getLibrary?.()
        );
      } catch (e) {
        console.warn("Legacy image migration failed:", e);
      }
    }
	
// Hydrate global background image
    if (dbReady && state) { // Check if DB is ready and state is loaded
        let stateNeedsUpdate = false;
        try {
            const blob = await DBService.getImage('global_background_image');
            if (blob) {
                // Image FOUND in IDB
                console.log("Found local background image in IDB during init.");
                UIManager.RUNTIME.globalBackgroundImageCache = URL.createObjectURL(blob);
                // Ensure state reflects reality
                if (state.backgroundImageURL !== 'local_idb_background') {
                    console.log("Correcting state: Setting backgroundImageURL to local_idb_background.");
                    state.backgroundImageURL = 'local_idb_background';
                    stateNeedsUpdate = true; // Mark state as changed
                }
            } else {
                // Image NOT found in IDB
                console.log("No local background image found in IDB during init.");
                // If state mistakenly thinks there's a local image, clear it
                if (state.backgroundImageURL === 'local_idb_background') {
                    console.log("Correcting state: Clearing backgroundImageURL because local image is missing.");
                    state.backgroundImageURL = '';
                    stateNeedsUpdate = true; // Mark state as changed
                }
                // Clear cache just in case
                UIManager.RUNTIME.globalBackgroundImageCache = null;
            }
        } catch (e) {
            console.warn("Failed during IDB background image check/load", e);
            // Fallback: If DB check fails, clear local flag if set, to avoid broken state
            if (state.backgroundImageURL === 'local_idb_background') {
                 state.backgroundImageURL = '';
                 stateNeedsUpdate = true;
            }
        }
        // Save state *only* if we made corrections during hydration
        if (stateNeedsUpdate) {
            console.log("Saving corrected state after background hydration.");
            StateManager.saveState();
        }
    }

// Hydrate world map location images
    if (dbReady && state && state.worldMap && state.worldMap.grid) {
      UIManager.RUNTIME.worldImageCache = UIManager.RUNTIME.worldImageCache || {};
      for (const loc of state.worldMap.grid) {
        // Only try to load images that are marked as local
        if (loc.imageUrl && loc.imageUrl.startsWith('local_idb_location')) {
          const locationKey = `location::${loc.coords.x},${loc.coords.y}`;
          try {
            const blob = await DBService.getImage(locationKey);
            if (blob) {
              UIManager.RUNTIME.worldImageCache[locationKey] = URL.createObjectURL(blob);
            } else {
              // Image missing from DB, correct the state
              console.warn(`Correcting missing location image for ${locationKey}`);
              loc.imageUrl = '';
              stateNeedsUpdate = true; // Mark for saving
            }
          } catch (e) {
            console.warn(`Failed to load location image ${locationKey} from IDB`, e);
          }
        }
      }
    }

    // --- Render the app regardless of DB status (your original logic, unchanged) ---
    if (!state || Object.keys(state).length === 0) {
      const activeStory = library.stories.find(s => s.id === library.active_story_id);
      document.getElementById('story-title-input').value = activeStory ? activeStory.name : "No Story Loaded";
      document.getElementById('mobile-story-title-overlay').value = activeStory ? activeStory.name : "No Story Loaded";
      UIManager.renderChat();
    } else {
      Controller.RUNTIME.turnOfArrival = state.messageCounter; // Initialize on load
      Controller._ensureCharacterColors();
      UIManager.applyStyling();
      UIManager.renderAll();
    }
  },

  /** Sets up all global and persistent event listeners for the application. */
  setupEventListeners() {
    this.updateLayout();
    window.addEventListener('resize', debounce(() => this.updateLayout(), 100));
        
        const titleInputHandler = debounce((e) => { 
            const state = StateManager.getState();
            if(state) {
                state.narrativeName = e.target.value;
                StateManager.saveState();
            }
        }, 500);

        document.getElementById('story-title-input').addEventListener('input', titleInputHandler);
        document.getElementById('mobile-story-title-overlay').addEventListener('input', titleInputHandler);

        const hamburgerBtn = document.getElementById('hamburger-menu-button');
        if (hamburgerBtn) { hamburgerBtn.addEventListener('click', (e) => { e.stopPropagation(); Controller.toggleMobileMenu(); }); }
        
        document.addEventListener('click', (e) => {
            const menu = document.getElementById('mobile-menu');
            const btn = document.getElementById('hamburger-menu-button');
            if (menu && !menu.classList.contains('hidden') && !menu.contains(e.target) && !btn.contains(e.target)) { Controller.toggleMobileMenu(); }
        });
        
        const titleTrigger = document.getElementById('title-trigger-area');
        const mobileTitle = document.getElementById('mobile-story-title-overlay');
        const showTitle = () => { if(document.body.classList.contains('layout-vertical')) { clearTimeout(UIManager.RUNTIME.titleTimeout); mobileTitle.style.opacity = '1'; } };
        const hideTitle = (immediate = false) => { if(document.body.classList.contains('layout-vertical')) { clearTimeout(UIManager.RUNTIME.titleTimeout); if (document.activeElement !== mobileTitle) { if (immediate) { mobileTitle.style.opacity = '0'; } else { UIManager.RUNTIME.titleTimeout = setTimeout(() => { mobileTitle.style.opacity = '0'; }, 2500); } } } };
        
        titleTrigger.addEventListener('mouseenter', showTitle);
        titleTrigger.addEventListener('mouseleave', () => hideTitle());
        titleTrigger.addEventListener('touchstart', (e) => { e.preventDefault(); if (mobileTitle.style.opacity === '1') { hideTitle(true); } else { showTitle(); hideTitle(); } });
        
        document.getElementById('regen-btn').addEventListener('click', () => Controller.handleRegen());
        document.getElementById('undo-btn').addEventListener('click', () => Controller.undoLastTurn());
  },

  /** Updates the body class based on screen orientation for responsive styling. */
  updateLayout() {
    if (window.innerHeight > window.innerWidth) {
      document.body.classList.add('layout-vertical');
      document.body.classList.remove('layout-horizontal');
    } else {
      document.body.classList.add('layout-horizontal');
      document.body.classList.remove('layout-vertical');
    }
    UIManager.updateSidePortrait();
  },
};

// Start the application once the DOM is fully loaded.
document.addEventListener('DOMContentLoaded', () => app.init());



	</script>

    
</body>
</html>
