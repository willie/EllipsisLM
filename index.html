<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <!-- Updated Viewport for Notch Support -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">

    <!-- PWA and iOS Home Screen Support -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="EllipsisLM">
    <title>EllipsisLM</title>
    <link rel="apple-touch-icon" href="https://github.com/pacmanincarnate/EllipsisLM/blob/main/logo.png?raw=true">
    <link rel="icon" type="image/png" href="https://github.com/pacmanincarnate/EllipsisLM/blob/main/logo.png?raw=true">

    <!-- External Libraries -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/jszip/dist/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Caveat:wght@400;700&family=Comic+Neue:wght@400;700&family=Cormorant+Garamond:ital,wght@0,400;1,400&family=Dancing+Script:wght@700&family=Domine:wght@400;700&family=EB+Garamond:ital,wght@0,400;1,400&family=Inter:wght@400;500;700&family=Lora:ital,wght@0,400;1,400&family=Nunito+Sans:ital,wght@0,400;1,400&family=Patrick+Hand&family=Prompt:wght@400;700&family=Roboto+Slab:wght@400;700&family=Source+Code+Pro:ital,wght@0,400;1,400&family=Titan+One&display=swap"
        rel="stylesheet">

    <!-- Application Styles -->
    <style>
        /* ==========================================================================
           1. CSS VARIABLES & THEME
           ========================================================================== */
        :root {
            /* Typography */
            --font-primary: 'Inter', sans-serif;
            --chat-font-family: 'Inter', sans-serif;
            --chat-font-size: 16px;

            /* Colors */
            --text-primary: #e5e7eb;
            --text-secondary: #cbd5e1;
            --text-accent: #a5b4fc;
            --chat-text-color: #e5e7eb;

            /* Surfaces */
            --surface-glass: rgba(17, 24, 39, 0.15);
            --surface-card: rgba(55, 65, 81, 0.6);
            --surface-overlay: rgba(0, 0, 0, 0.6);

            /* Brand */
            --border-hue-color: rgba(75, 85, 99, 0.8);
            --border-primary: var(--border-hue-color);
            --brand-color: #6366f1;
            --brand-color-hover: #4f46e5;

            /* Dimensions */
            --border-radius-md: 0.75rem;
            --border-radius-sm: 4px;
            --bubble-image-size: 100px;

            /* Animation */
            --transition-fast: 0.2s ease-in-out;
            --transition-medium: 0.4s ease-out;
        }

        /* ==========================================================================
           2. RESET & BASE STYLES
           ========================================================================== */
        html,
        body {
            height: 100%;
            height: 100dvh;
            width: 100%;
            overflow: hidden;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: var(--font-primary);
            color: var(--text-primary);
            background-color: #111827;
        }

        /* Form Elements: Custom styling to remove default browser outlines and unify appearance */
        input,
        textarea,
        select {
            color: var(--text-primary);
            background-color: rgba(17, 24, 39, 0.7);
            font-family: inherit;
        }

        input::placeholder,
        textarea::placeholder {
            color: #9ca3af;
        }

        input:focus,
        textarea:focus,
        select:focus {
            outline: none;
        }

        .glass-bg {
            background-color: var(--surface-glass);
            -webkit-backdrop-filter: blur(5px);
            backdrop-filter: blur(5px);
        }

        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: #4b5563;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #6b7280;
        }

        /* ==========================================================================
           3. LAYOUT & RESPONSIVENESS
           ========================================================================== */

        #app-container {
            padding-top: env(safe-area-inset-top);
            padding-bottom: env(safe-area-inset-bottom);
            transition: backdrop-filter 0.3s ease;
        }

        /* --- Vertical Layout (Mobile) --- */
        body.layout-vertical #desktop-header {
            display: none;
        }

        body.layout-vertical #mobile-header {
            display: flex;
        }

        body.layout-vertical #app-container {
            padding: 0;
        }

        body.layout-vertical #main-header {
            position: absolute;
            top: env(safe-area-inset-top);
            left: 0;
            right: 0;
            z-index: 60;
            padding: 0.5rem;
            padding-left: calc(0.5rem + env(safe-area-inset-left));
            padding-right: calc(0.5rem + env(safe-area-inset-right));
            pointer-events: none;
        }

        body.layout-vertical #hamburger-menu-button-container {
            pointer-events: auto;
            opacity: 0.6;
            z-index: 51;
            position: relative;
        }

        body.layout-vertical #hamburger-menu-button-container:hover {
            opacity: 1;
        }

        body.layout-vertical #chat-window-container {
            margin: 0 !important;
            border-radius: 0;
            width: 100%;
            padding-left: env(safe-area-inset-left);
            padding-right: env(safe-area-inset-right);
        }

        body.layout-vertical #character-portrait-container {
            display: none;
        }

        body.layout-vertical #chat-input-container {
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            padding: 1rem;
            padding-bottom: calc(1rem + env(safe-area-inset-bottom));
            padding-left: calc(1rem + env(safe-area-inset-left));
            padding-right: calc(1rem + env(safe-area-inset-right));
            background: rgba(17, 24, 39, 0.5);
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
        }

        /* --- Horizontal Layout (Desktop) --- */
        body.layout-horizontal #desktop-header {
            display: flex;
        }

        body.layout-horizontal #mobile-header {
            display: none;
        }

        body.layout-horizontal #app-container {
            padding: .5rem;
        }

        body.layout-horizontal #chat-window-container {
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: var(--border-radius-md);
            justify-content: space-between;
        }

        body.layout-horizontal #chat-input-container {
            background: rgba(17, 24, 39, 0.5);
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: var(--border-radius-md);
        }

        body.layout-horizontal #chat-window {
            width: 65%;
            margin: 0 auto;
        }

        body.layout-horizontal #character-portrait-container {
            display: flex;
            width: 35%;
            height: 100%;
            justify-content: center;
            align-items: inherit;
        }

        body.layout-horizontal #title-trigger-area {
            display: none;
        }

        /* FIX: Hide redundant close button in horizontal mode */
        body.layout-horizontal .story-details-close-btn {
            display: none;
        }

        #mobile-story-title-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            z-index: 50;
            background: linear-gradient(to bottom, rgba(0, 0, 0, 0.8), transparent);
            padding-top: calc(0.5rem + env(safe-area-inset-top));
            padding-bottom: 1rem;
            padding-left: env(safe-area-inset-left);
            padding-right: env(safe-area-inset-right);
            text-align: center;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            border: none;
            border-bottom: none;
            color: var(--chat-text-color);
            font-family: var(--chat-font-family);
        }

        /* ==========================================================================
           iOS PWA SAFE AREA FIXES
           Ensures modals and fixed elements respect iPhone notch and home indicator
           ========================================================================== */

        /* Modal containers need safe area padding for iOS PWA */
        #story-library-modal,
        #gen-story-modal,
        #io-hub-modal,
        #report-modal,
        #story-details-modal,
        #characters-modal,
        #character-detail-modal,
        #knowledge-modal,
        #world-map-modal,
        #location-details-modal,
        #settings-modal,
        #edit-response-modal,
        #view-raw-prompt-modal,
        #example-dialogue-modal,
        #confirmation-modal,
        #openrouter-model-modal,
        #lightbox-modal {
            padding-top: env(safe-area-inset-top);
            padding-bottom: env(safe-area-inset-bottom);
            padding-left: env(safe-area-inset-left);
            padding-right: env(safe-area-inset-right);
        }

        /* Ensure modal content doesn't exceed safe viewport */
        #story-library-modal > div:not(.modal-overlay),
        #gen-story-modal > div:not(.modal-overlay),
        #io-hub-modal > div:not(.modal-overlay),
        #settings-modal > div:not(.modal-overlay),
        #characters-modal > div:not(.modal-overlay),
        #character-detail-modal > div:not(.modal-overlay),
        #knowledge-modal > div:not(.modal-overlay),
        #world-map-modal > div:not(.modal-overlay),
        #location-details-modal > div:not(.modal-overlay),
        #story-details-modal > div:not(.modal-overlay),
        #edit-response-modal > div:not(.modal-overlay),
        #view-raw-prompt-modal > div:not(.modal-overlay) {
            max-height: calc(100% - env(safe-area-inset-top) - env(safe-area-inset-bottom));
        }

        #mobile-story-title-overlay:focus,
        #mobile-story-title-overlay:hover {
            opacity: 1 !important;
            pointer-events: auto;
        }

        /* ==========================================================================
           4. COMPONENTS
           ========================================================================== */

        /* Character Roster Card */
        .char-roster-btn {
            position: relative;
            background-size: cover;
            background-position: center 20%;
            border-radius: var(--border-radius-md);
            overflow: hidden;
            aspect-ratio: 3 / 4;
            border: 1px solid rgba(255, 255, 255, 0.1);
            cursor: pointer;
            transition: transform var(--transition-fast), box-shadow var(--transition-fast);
        }

        .char-roster-btn:hover {
            transform: scale(1.02);
            box-shadow: 0 0 15px rgba(99, 102, 241, 0.4);
        }

        .char-roster-btn::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 60%;
            background: linear-gradient(to top, rgba(0, 0, 0, 0.9), transparent);
            pointer-events: none;
        }

        .char-roster-content {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 1rem;
            z-index: 10;
        }

        .modal-overlay {
            background-color: var(--surface-overlay);
            backdrop-filter: blur(2px);
        }

        /* Edit Response Modal: Set to occupy 2/3 of the viewport height for better visibility */
        #edit-response-modal>div:not(.modal-overlay) {
            height: 66vh !important;
            max-height: 90vh !important;
            display: flex;
            flex-direction: column;
        }

        /* Ensure text area fills the modal */
        #edit-response-modal textarea {
            height: 100% !important;
            flex-grow: 1;
        }

        /* Toggle Switch */
        .toggle-bg {
            transition: background-color var(--transition-fast);
        }

        .toggle-bg:after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 1.25rem;
            height: 1.25rem;
            background: white;
            border-radius: 50%;
            transition: left var(--transition-fast);
        }

        input:checked+.toggle-bg {
            background-color: var(--brand-color);
        }

        input:checked+.toggle-bg:after {
            left: calc(100% - 2px - 1.25rem);
        }

        /* ==========================================================================
           5. CHAT WINDOW STYLING
           ========================================================================== */
        #chat-window {
            display: flex;
            flex-direction: column;
        }

        /* Vertical Mode Adjustment: Push top bubble down to prevent overlap with the header */
        body.layout-vertical #chat-window {
            padding-top: 4rem;
        }

        /* Markdown Styles */
        /* Markdown Styles: Controlled via CSS Variables for theming support */
        #chat-window h1 {
            color: var(--md-h1-color, #818cf8);
            font-family: var(--md-h1-font, var(--chat-font-family));
            font-size: 1.5em;
            font-weight: 700;
            margin: 0.5em 0;
        }

        #chat-window h2 {
            color: var(--md-h2-color, #a5b4fc);
            font-family: var(--md-h2-font, var(--chat-font-family));
            font-size: 1.25em;
            font-weight: 600;
            margin: 0.4em 0;
        }

        #chat-window h3 {
            color: var(--md-h3-color, #c7d2fe);
            font-family: var(--md-h3-font, var(--chat-font-family));
            font-size: 1.1em;
            font-weight: 600;
            margin: 0.3em 0;
        }

        /* Bold Text: Uses the CSS variable for dynamic coloring */
        #chat-window strong {
            color: var(--md-bold-color, #ffffff);
            font-family: var(--md-bold-font, var(--chat-font-family));
            font-weight: 700;
        }

        #chat-window em {
            color: var(--md-italic-color, #9ca3af);
            font-family: var(--md-italic-font, var(--chat-font-family));
        }

        #chat-window blockquote {
            border-left: 3px solid var(--brand-color);
            padding-left: 1rem;
            color: var(--md-quote-color, #9ca3af);
            font-family: var(--md-quote-font, var(--chat-font-family));
            font-style: italic;
        }

        /* Smart Quotation Formatting 
           Uses dynamic variables to toggle between the default "Filtered" look 
           and a specific "User Color" look. */
        .dialogue-quote {
            color: var(--active-quote-color, inherit);
            filter: var(--active-quote-filter, saturate(175%) opacity(75%) drop-shadow(1px 1px 5px black));
            font-family: var(--md-quote-font, inherit);
            font-weight: 500;
        }

        /* Bubble Container */
        .chat-bubble-container {
            width: 100%;
            max-width: 900px;
            margin: 0 auto 1rem auto;
            animation: fadeIn var(--transition-medium);
        }

        .bubble-header {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            padding: 0 0.5rem 0.25rem 0.5rem;
            font-size: 0.85rem;
        }

        /* Timestamps: Hidden by default to reduce clutter, revealed on hover */
        .bubble-header .timestamp {
            opacity: 0;
            transition: opacity var(--transition-fast);
        }

        .chat-bubble-container:hover .bubble-header .timestamp {
            opacity: 1;
        }

        /* Bubble Styling: Sizing constraints and shadow effects */
        .bubble-body {
            font-size: var(--chat-font-size);
            font-family: var(--chat-font-family);
            position: relative;
            border: none;
            /* No outline */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);

            /* Shrink to fit text, but max out at page width */
            width: fit-content;
            min-width: 120px;
            max-width: 100%;

            display: flow-root;
        }

        .bubble-body .whitespace-pre-wrap {
            /* This tells the browser: "If there is a newline character, show it." */
            white-space: pre-wrap !important;
            word-wrap: break-word;
            /* Prevent long words from breaking layout */
        }

        .bubble-char-image {
            float: left;
            width: var(--bubble-image-size);
            height: auto;
            border-radius: 0.5rem;
            margin-right: 1rem;
            margin-bottom: 0.5rem;
            shape-outside: margin-box;
        }

        /* Restore natural spacing for Markdown elements inside bubbles */
        .bubble-body p {
            margin-bottom: 0.0rem;
            /* Space between paragraphs */
        }

        .bubble-body p:last-child {
            margin-bottom: 0;
            /* No space after the last paragraph */
        }

        .bubble-body ul,
        .bubble-body ol {
            margin-bottom: 0.5rem;
            padding-left: 1.5rem;
            /* Indent lists */
        }

        .bubble-body li {
            list-style-type: disc;
            /* Restore bullet points */
        }

        .action-btn-group {
            opacity: 0;
            /* FIX: Add delay ONLY when hiding (mouse out) so cursor can bridge the gap */
            transition: opacity 0.2s ease-in-out 0.4s;
        }

        .chat-bubble-container:hover .action-btn-group {
            opacity: 1;
            /* FIX: Instant show on hover */
            transition-delay: 0s;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes pulseOpacity {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }
        }

        .typing-bubble-pulse {
            animation: pulseOpacity 1.5s infinite;
        }

        /* ==========================================================================
           6. CINEMATIC MODE STYLES
           ========================================================================== */
        body[data-mode="cinematic_overlay"] #app-container {
            background: transparent;
            backdrop-filter: none;
        }

        body[data-mode="cinematic_overlay"] #cinematic-bg-1,
        body[data-mode="cinematic_overlay"] #cinematic-bg-2 {
            position: fixed;
            inset: 0;
            z-index: 0;
            background-size: auto 100%;
            background-position: center top;
            transition: opacity 1s ease-in-out;
            pointer-events: none;
        }

        /* Chat Window Container - Bottom 1/3 Position */
        body[data-mode="cinematic_overlay"] #chat-window-container {
            align-items: flex-end;
            margin-top: auto !important;
            /* Force bottom alignment, overriding vertical layout defaults */
            background: linear-gradient(to top, rgba(0, 0, 0, 0.9) 0%, rgba(0, 0, 0, 0.4) 70%, transparent 100%);
            border: none;
            border-radius: 0;
            /* Flush edges look better in cinematic */
            -webkit-mask-image: linear-gradient(to bottom, transparent, black 15%);
            /* Fade out text at the very top */
            mask-image: linear-gradient(to bottom, transparent, black 15%);
        }

        body[data-mode="cinematic_overlay"] #character-portrait-container {
            display: none !important;
        }

        /* Internal Chat Alignment: Forces text to the bottom of the container */
        body[data-mode="cinematic_overlay"] #chat-window {
            width: 100% !important;
            height: 33%;
            display: flex;
            flex-direction: column;
            padding-bottom: 0.5rem;
        }

        /* This is the key trick: Auto margin on the first child pushes 
           the whole stack of messages to the bottom of the flex container */
        body[data-mode="cinematic_overlay"] #chat-window> :first-child {
            margin-top: auto !important;
        }

        /* Bubble Styling for Cinematic Mode: Adds blur for readability against backgrounds */
        body[data-mode="cinematic_overlay"] .bubble-body {
            backdrop-filter: blur(6px);
        }

        /* Input Area Visibility: Ensures input remains visible and readable in cinematic mode */
        body[data-mode="cinematic_overlay"] #chat-input-container {
            background-color: #0f172a;
            /* Solid dark color for readability */
            border-top: 1px solid rgba(255, 255, 255, 0.15);
            position: relative;
            z-index: 20;
            padding-bottom: max(1rem, env(safe-area-inset-bottom));
            padding-left: calc(1rem + env(safe-area-inset-left));
            padding-right: calc(1rem + env(safe-area-inset-right));
        }

        /* Visual settings sliders */
        input[type="range"] {
            -webkit-appearance: none;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            height: 6px;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            background: var(--brand-color);
            height: 16px;
            width: 16px;
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.1s;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        /* Custom Radio Button: Robust Implementation using Sibling Pseudo-elements */
        input[type="radio"].custom-radio {
            /* FORCE Hide the actual input visually */
            appearance: none !important;
            -webkit-appearance: none !important;
            width: 0 !important;
            height: 0 !important;
            opacity: 0 !important;
            position: absolute !important;
            margin: 0 !important;
            pointer-events: none;
        }

        /* The text span acts as the visual container */
        input[type="radio"].custom-radio+span {
            position: relative;
            padding-left: 1.75rem;
            cursor: pointer;
            -webkit-user-select: none;
            user-select: none;
            display: inline-flex;
            align-items: center;
            min-height: 1.5rem;
        }

        /* Outer Circle */
        input[type="radio"].custom-radio+span::before {
            content: "";
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 1.25rem;
            height: 1.25rem;
            border: 2px solid #6b7280;
            border-radius: 50%;
            /* Explicit dark background to prevent "white fill" from underlying elements */
            background-color: #1f2937;
            transition: border-color var(--transition-fast), background-color var(--transition-fast);
            box-sizing: border-box;
        }

        /* Inner Dot */
        input[type="radio"].custom-radio+span::after {
            content: "";
            position: absolute;
            left: 0.3125rem;
            top: 50%;
            transform: translateY(-50%) scale(0);
            width: 0.625rem;
            height: 0.625rem;

            input[type="radio"].custom-radio:checked+span::after {
                transform: translateY(-50%) scale(1);
            }

            /* 3. Gen Story Modal Inputs (Edit-Before-Commit) */
            .gen-input {
                background-color: rgba(0, 0, 0, 0.3);
                border: 1px solid #4b5563;
                color: white;
                padding: 0.5rem;
                border-radius: 0.5rem;
                width: 100%;
                transition: border-color 0.2s;
            }

            .gen-input:focus {
                border-color: #6366f1;
                outline: none;
            }
    </style>



</head>




<body data-mode="none" class="bg-gray-900 h-full flex flex-col">

    <!-- Background Image Container -->
    <div id="global-background"
        class="fixed inset-0 -z-10 bg-gray-900 bg-[length:auto_100vh] bg-no-repeat bg-center transition-all duration-500">
    </div>

    <!-- Main Application Container -->
    <div class="w-full h-full flex flex-col glass-bg" id="app-container">

        <!-- Header: Contains navigation and global actions. Uses event delegation. -->
        <header class="mb-4 flex justify-between items-center" id="main-header">
            <!-- Desktop Header -->
            <div id="desktop-header" class="justify-between items-center w-full">

                <div class="flex items-center space-x-2">
                    <button data-action="open-modal" data-target="story-library-modal"
                        class="bg-gray-700/80 hover:bg-gray-600/80 text-white font-bold py-2 px-4 rounded-lg"
                        title="Story Library"
                        style="border-color: color-mix(in srgb, var(--chat-text-color) 50%, transparent); border-width: 2px;">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"
                            xmlns="http://www.w3.org/2000/svg">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M4 6h16M4 12h16M4 18h7"></path>
                            <path d="M4 6h16M4 12h16M4 18h7" stroke-linecap="round" stroke-linejoin="round"
                                stroke-width="2"></path>
                            <path d="M18 18v-6" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"></path>
                            <path d="M15 12h6" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"></path>
                        </svg>
                    </button>

                    <input type="text" id="story-title-input" aria-label="Story Title"
                        class="text-2xl font-bold bg-transparent text-white p-1 rounded focus:outline-none focus:bg-black/20 w-96"
                        style="color: var(--chat-text-color);font-weight: 100; font-family: var(--chat-font-family);">
                </div>

                <div class="flex space-x-2">
                    <button data-action="quick-create-character"
                        class="bg-gray-700/40 hover:bg-indigo-500/80 text-white font-bold py-2 px-4 rounded-lg"
                        title="Quickly Generate Character from Chat">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M18 9v3m0 0v3m0-3h3m-3 0h-3m-2-5a4 4 0 11-8 0 4 4 0 018 0zM3 20a6 6 0 0112 0v1H3v-1z">
                            </path>
                        </svg>
                    </button>
                    <button data-action="open-modal" data-target="characters-modal"
                        class="bg-gray-700/40 hover:bg-gray-600/80 text-white font-bold py-2 px-4 rounded-lg" title="Characters
					"><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M12 4.354a4 4 0 110 5.292M15 21H3v-1a6 6 0 0112 0v1zm0 0h6v-1a6 6 0 00-9-5.197M15 21a6 6 0 00-9-5.197m0 0A5.965 5.965 0 0112 13a5.965 5.965 0 013 1.803">
                            </path>
                        </svg></button>
                    <button data-action="open-modal" data-target="world-map-modal"
                        class="bg-gray-700/40 hover:bg-gray-600/80 text-white font-bold py-2 px-4 rounded-lg"
                        title="World Map"><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"
                            xmlns="http://www.w3.org/2000/svg">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M9 20l-5.447-2.724A1 1 0 013 16.382V5.618a1 1 0 011.447-.894L9 7m0 13l6-3m-6 3V7m6 10l5.447 2.724A1 1 0 0021 18.382V7.618a1 1 0 00-1.447-.894L15 9m-6 4v.01">
                            </path>
                        </svg></button>
                    <button data-action="open-modal" data-target="knowledge-modal"
                        class="bg-gray-700/40 hover:bg-gray-600/80 text-white font-bold py-2 px-4 rounded-lg"
                        title="Knowledge"><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"
                            xmlns="http://www.w3.org/2000/svg">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.246 18 16.5 18c-1.746 0-3.332.477-4.5 1.253z">
                            </path>
                        </svg></button>
                    <button data-action="check-world-info"
                        class="bg-gray-700/40 hover:bg-gray-600/80 text-white font-bold py-2 px-4 rounded-lg"
                        title="Update Static Memory"><svg class="w-6 h-6" fill="none" stroke="currentColor"
                            viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z">
                            </path>
                        </svg></button>
                    <button data-action="open-modal" data-target="settings-modal"
                        class="bg-gray-700/40 hover:bg-gray-600/80 text-white font-bold py-2 px-4 rounded-lg"
                        title="Settings"><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"
                            xmlns="http://www.w3.org/2000/svg">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066 2.573c-.94-1.543.826 3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z">
                            </path>
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path>
                        </svg></button>
                </div>
            </div>

            <!-- Mobile Header -->
            <div id="mobile-header" class="justify-end items-center w-full">
                <div class="relative" id="hamburger-menu-button-container">
                    <button id="hamburger-menu-button" data-action="toggle-mobile-menu" aria-label="Toggle Menu"
                        class="bg-gray-700/80 hover:bg-gray-600/80 text-white p-2 rounded-lg">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"
                            xmlns="http://www.w3.org/2000/svg">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M4 6h16M4 12h16M4 18h16"></path>
                        </svg>
                    </button>
                    <div id="mobile-menu"
                        class="hidden absolute right-0 mt-2 w-56 bg-gray-800/90 backdrop-blur-md rounded-lg shadow-xl z-50">
                        <a href="#" data-action="open-modal" data-target="story-library-modal"
                            onclick="AppController.toggleMobileMenu(); return false;"
                            class="block px-4 py-3 text-white hover:bg-gray-700">Story Library</a>
                        <div class="px-4 py-2 text-gray-400 text-sm font-bold border-t border-gray-700">Narrative
                            Settings</div>
                        <a href="#" data-action="quick-create-character"
                            onclick="AppController.toggleMobileMenu(); return false;"
                            class="block pl-8 pr-4 py-3 text-white hover:bg-gray-700">Generate Character</a>
                        <a href="#" data-action="open-modal" data-target="characters-modal"
                            onclick="AppController.toggleMobileMenu(); return false;"
                            class="block pl-8 pr-4 py-3 text-white hover:bg-gray-700">Characters</a>
                        <a href="#" data-action="open-modal" data-target="world-map-modal"
                            onclick="AppController.toggleMobileMenu(); return false;"
                            class="block pl-8 pr-4 py-3 text-white hover:bg-gray-700">World Map</a>
                        <a href="#" data-action="open-modal" data-target="knowledge-modal"
                            onclick="AppController.toggleMobileMenu(); return false;"
                            class="block pl-8 pr-4 py-3 text-white hover:bg-gray-700">Knowledge</a>
                        <a href="#" data-action="check-world-info"
                            onclick="AppController.toggleMobileMenu(); return false;"
                            class="block pl-8 pr-4 py-3 text-white hover:bg-gray-700">Update Static</a>
                        <div class="px-4 py-2 text-gray-400 text-sm font-bold border-t border-gray-700">Story Settings
                        </div>
                        <a href="#"
                            onclick="AppController.openSettingsToTab('appearance'); AppController.toggleMobileMenu(); return false;"
                            class="block pl-8 pr-4 py-3 text-white hover:bg-gray-700">Appearance</a>
                        <a href="#"
                            onclick="AppController.openSettingsToTab('prompt'); AppController.toggleMobileMenu(); return false;"
                            class="block pl-8 pr-4 py-3 text-white hover:bg-gray-700">Prompt</a>
                        <div class="px-4 py-2 text-gray-400 text-sm font-bold border-t border-gray-700">Global Settings
                        </div>
                        <a href="#"
                            onclick="AppController.openSettingsToTab('model'); AppController.toggleMobileMenu(); return false;"
                            class="block pl-8 pr-4 py-3 text-white hover:bg-gray-700">Model</a>
                        <a href="#"
                            onclick="AppController.openSettingsToTab('image-gen'); AppController.toggleMobileMenu(); return false;"
                            class="block pl-8 pr-4 py-3 text-white hover:bg-gray-700">Images</a>
                        <a href="#"
                            onclick="AppController.openSettingsToTab('export'); AppController.toggleMobileMenu(); return false;"
                            class="block pl-8 pr-4 py-3 text-white hover:bg-gray-700">Export</a>
                        <a href="#"
                            onclick="AppController.openSettingsToTab('personas'); AppController.toggleMobileMenu(); return false;"
                            class="block pl-8 pr-4 py-3 text-white hover:bg-gray-700">User Personas</a>
                    </div>
                </div>
            </div>
        </header>
        <!-- /Header -->

        <div id="mobile-header-elements">
            <input type="text" id="mobile-story-title-overlay" aria-label="Mobile Story Title"
                class="text-xl font-bold text-white truncate text-center bg-transparent focus:bg-black/20 w-1/2">
        </div>

        <!-- Main Content Area -->
        <main class="flex-grow min-h-0 flex flex-col relative">
            <div id="title-trigger-area" class="absolute top-0 left-0 w-full h-16 z-40" style="height: 2rem;"></div>
            <!-- Chat Window & Portrait -->
            <div id="chat-window-container"
                class="relative flex-grow p-2 flex min-h-0 bg-black/30 rounded-lg overflow-hidden"
                style="padding-bottom: revert; padding-top: revert;">
                <div id="cinematic-bg-1"
                    class="absolute inset-0 bg-cover bg-no-repeat bg-center transition-opacity duration-1000 pointer-events-none opacity-0">
                </div>
                <div id="cinematic-bg-2"
                    class="absolute inset-0 bg-cover bg-no-repeat bg-center transition-opacity duration-1000 pointer-events-none opacity-0">
                </div>
                <div id="chat-window" class="relative z-10 flex-grow overflow-y-auto"></div>
                <div id="character-portrait-container" class="flex-shrink-0 flex-col justify-center items-center"
                    style="padding-right: 0.5rem;"></div>
            </div>

            <!-- Chat Input & Controls -->
            <div id="chat-input-container" class="flex items-start space-x-2 sm:space-x-4"
                style="padding: 1rem; border-top: 1px solid; border-top-color: color-mix(in srgb, var(--chat-text-color) 50%, transparent);">
                <textarea id="chat-input"
                    class="flex-grow bg-black/30 border border-gray-800 rounded-lg p-2 color: black"
                    placeholder="Enter your message..." rows="4"
                    style="color: var(--chat-text-color); font-family: var(--chat-font-family);"></textarea>
                <div class="flex flex-col space-y-2" style="width: 8.5rem;">
                    <select id="ai-character-selector" aria-label="Select Character"
                        class="bg-black/30 border border-gray-600 rounded-lg p-2 w-full mb-2 text-xs truncate"></select>
                    <div class="flex items-center justify-center space-x-1">
                        <button id="primary-action-btn"
                            class="bg-indigo-600/50 hover:bg-indigo-600/80 text-white font-bold p-2 rounded-lg transition-colors"
                            title="Send / Write for Me">
                            <svg class="w-5 h-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                                stroke-linecap="round" stroke-linejoin="round">
                                <line x1="22" y1="2" x2="11" y2="13"></line>
                                <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
                            </svg>
                        </button>

                        <button id="regen-btn"
                            class="bg-sky-600/40 hover:bg-sky-600/70 text-white font-bold p-2 rounded-lg transition-colors"
                            title="Regenerate / New Response">
                            <svg class="w-5 h-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                                stroke-linecap="round" stroke-linejoin="round">
                                <path d="M21 12a9 9 0 0 0-9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"></path>
                                <path d="M3 3v5h5"></path>
                                <path d="M3 12a9 9 0 0 0 9 9 9.75 9.75 0 0 0 6.74-2.74L21 16"></path>
                                <path d="M16 21h5v-5"></path>
                            </svg>
                        </button>

                        <button id="undo-btn"
                            class="bg-gray-600/40 hover:bg-gray-500/70 text-white font-bold p-2 rounded-lg transition-colors"
                            title="Undo Last Turn">
                            <svg class="w-5 h-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                                stroke-linecap="round" stroke-linejoin="round">
                                <path d="M9 14 4 9l5-5" />
                                <path d="M4 9h10.5a5.5 5.5 0 0 1 5.5 5.5v0a5.5 5.5 0 0 1-5.5 5.5H11" />
                            </svg>
                        </button>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <!-- MODALS -->

    <!-- Story Library Modal -->
    <div id="story-library-modal" class="fixed inset-0 z-50 items-center justify-center hidden">
        <div class="modal-overlay absolute inset-0" data-action="close-modal" data-id="story-library-modal"></div>
        <div class="bg-gray-800/80 backdrop-blur-md rounded-lg shadow-xl relative flex flex-col"
            style="width: 100%; max-height: 100%">
            <div class="p-6 border-b border-gray-700 flex justify-between items-center">
                <h2 class="text-2xl font-semibold">Story Library</h2>
                <div class="flex space-x-2">
                    <button data-action="open-modal" data-target="io-hub-modal"
                        class="bg-teal-600/80 hover:bg-teal-700/80 text-white font-bold py-2 px-4 rounded-lg">Import</button>

                    <div class="relative inline-block text-left">
                        <button
                            onclick="event.stopPropagation(); document.getElementById('new-story-dropdown').classList.toggle('hidden')"
                            class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg flex items-center gap-2">
                            New
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M19 9l-7 7-7-7"></path>
                            </svg>
                        </button>
                        <!-- Dropdown Menu -->
                        <div id="new-story-dropdown"
                            class="hidden absolute right-0 mt-2 w-56 rounded-md shadow-lg bg-gray-800 ring-1 ring-black ring-opacity-5 z-50 focus:outline-none border border-gray-700">
                            <div class="py-1" role="menu" aria-orientation="vertical" aria-labelledby="options-menu">
                                <button data-action="open-modal" data-target="gen-story-modal"
                                    onclick="document.getElementById('new-story-dropdown').classList.add('hidden')"
                                    class="w-full text-left text-gray-300 hover:bg-gray-700 hover:text-white px-4 py-3 text-sm flex items-center gap-3"
                                    role="menuitem">
                                    <svg class="w-5 h-5 text-gray-400" fill="none" stroke="currentColor"
                                        viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                            d="M13 10V3L4 14h7v7l9-11h-7z"></path>
                                    </svg>
                                    <div>
                                        <span class="font-normal block">Generate Story</span>
                                    </div>
                                </button>
                                <button
                                    onclick="LibraryController.createNewStory(); document.getElementById('new-story-dropdown').classList.add('hidden')"
                                    class="w-full text-left text-gray-300 hover:bg-gray-700 hover:text-white px-4 py-3 text-sm flex items-center gap-3"
                                    role="menuitem">
                                    <svg class="w-5 h-5 text-gray-400" fill="none" stroke="currentColor"
                                        viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                            d="M9 13h6m-3-3v6m5 5H6a2 2 0 01-2-2V6a2 2 0 012-2h10a2 2 0 012 2v10a2 2 0 01-2 2z">
                                        </path>
                                    </svg>
                                    Create Blank Story
                                </button>
                            </div>
                        </div>
                    </div>

                    <button data-action="close-modal" data-id="story-library-modal" aria-label="Close"
                        class="bg-gray-700 hover:bg-gray-600 text-gray-300 hover:text-white p-2 rounded-lg transition-colors">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M6 18L18 6M6 6l12 12"></path>
                        </svg>
                    </button>
                </div>
            </div>
            <div id="library-content-container" class="flex-grow flex min-h-0"></div>
            <!-- Footer Removed -->
        </div>
    </div>

    <!-- Story Generation Modal -->
    <div id="gen-story-modal" class="fixed inset-0 z-[60] items-center justify-center hidden">
        <div class="modal-overlay absolute inset-0 bg-black/60" data-action="close-modal" data-id="gen-story-modal">
        </div>
        <div
            class="bg-gray-800/90 backdrop-blur-md rounded-lg shadow-2xl w-11/12 max-w-2xl relative flex flex-col p-6 border border-gray-600">
            <div class="flex justify-between items-start mb-4">
                <h2
                    class="text-2xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-indigo-400 to-cyan-400">
                    AI Story Architect</h2>
                <button data-action="close-modal" data-id="gen-story-modal"
                    class="bg-gray-700 hover:bg-gray-600 text-gray-300 hover:text-white p-2 rounded-lg transition-colors"
                    title="Close">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12">
                        </path>
                    </svg>
                </button>
            </div>

            <div id="gen-story-input-view">
                <label class="block text-sm text-gray-400 mb-2">What kind of story should we tell?</label>
                <textarea id="gen-story-prompt"
                    class="w-full bg-black/40 border border-gray-600 rounded-lg p-3 text-white focus:border-indigo-500 focus:ring-1 focus:ring-indigo-500 h-32 resize-none"
                    placeholder="e.g. A cyberpunk noir detective story on Mars where water is more expensive than gold."></textarea>
                <div class="flex justify-end mt-4 space-x-3">
                    <button data-action="close-modal" data-id="gen-story-modal"
                        class="px-4 py-2 rounded-lg text-gray-300 hover:bg-gray-700 transition-colors">Cancel</button>
                    <button data-action="gen-story-phase-1"
                        class="px-4 py-2 rounded-lg bg-indigo-600 hover:bg-indigo-500 text-white font-bold transition-all">Draft
                        Concept</button>
                </div>
            </div>

            <div id="gen-story-approval-view" class="hidden flex-col space-y-4">
                <div class="bg-black/30 p-4 rounded-lg border border-gray-600 space-y-3">
                    <div>
                        <label class="block text-xs text-gray-400 uppercase font-bold mb-1">Title</label>
                        <input type="text" id="gen-approval-title-input" class="gen-input w-full font-bold text-lg">
                    </div>
                    <div>
                        <label class="block text-xs text-gray-400 uppercase font-bold mb-1">Summary / Creator's
                            Note</label>
                        <textarea id="gen-approval-summary-input"
                            class="gen-input w-full h-48 resize-none text-sm"></textarea>
                    </div>
                    <div>
                        <label class="block text-xs text-gray-400 uppercase font-bold mb-1">Tags (comma
                            separated)</label>
                        <input type="text" id="gen-approval-tags-input"
                            class="gen-input w-full text-sm text-indigo-300">
                    </div>
                    <div class="flex items-center space-x-3 pt-2">
                        <div
                            class="relative inline-block w-10 mr-2 align-middle select-none transition duration-200 ease-in">
                            <input type="checkbox" name="toggle" id="gen-approval-map-toggle" checked
                                class="toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 appearance-none cursor-pointer text-indigo-600 focus:ring-0 checked:right-0 checked:border-indigo-600 right-4" />
                            <label for="gen-approval-map-toggle"
                                class="toggle-label block overflow-hidden h-6 rounded-full bg-gray-600 cursor-pointer"></label>
                        </div>
                        <label for="gen-approval-map-toggle"
                            class="text-sm text-gray-300 cursor-pointer font-bold">Generate World Map</label>
                    </div>
                </div>

                <p class="text-xs text-gray-400 text-center">Refine the concept above. When ready, we will generate the
                    full world.</p>

                <div class="flex justify-between mt-4">
                    <button data-action="gen-story-retry"
                        class="px-4 py-2 rounded-lg text-red-300 hover:bg-red-900/50 hover:text-white transition-colors border border-red-900/50">Retry
                        / New Prompt</button>
                    <button data-action="gen-story-confirm"
                        class="px-4 py-2 rounded-lg bg-emerald-600 hover:bg-emerald-500 text-white font-bold shadow-lg shadow-emerald-500/30 transition-all transform hover:scale-105">Build
                        This World</button>
                </div>
            </div>

            <div id="gen-story-progress-view" class="hidden flex-col items-center justify-center py-8 space-y-6">
                <div class="w-full bg-gray-700 rounded-full h-4 overflow-hidden relative">
                    <div id="gen-story-bar"
                        class="bg-gradient-to-r from-indigo-500 via-purple-500 to-pink-500 h-4 rounded-full transition-all duration-500"
                        style="width: 0%"></div>
                </div>
                <p id="gen-story-status" class="text-indigo-300 font-mono text-sm animate-pulse text-center">
                    Initializing creative subroutines...</p>
            </div>
        </div>
    </div>

    <!-- Import/Export Hub Modal -->
    <div id="io-hub-modal" class="fixed inset-0 z-[60] items-center justify-center hidden">
        <div class="modal-overlay absolute inset-0 bg-black/50" data-action="close-modal" data-id="io-hub-modal">
        </div>
        <div id="io-hub-modal-content"
            class="bg-gray-800/80 backdrop-blur-md rounded-lg shadow-xl w-11/12 max-w-4xl relative flex flex-col max-h-[90vh]">
        </div>
    </div>

    <!-- Bulk Import Report Modal -->
    <div id="report-modal" class="fixed inset-0 z-[70] items-center justify-center hidden">
        <div class="modal-overlay absolute inset-0 bg-black/60" data-action="close-modal" data-id="report-modal">
        </div>
        <div id="report-modal-content"
            class="bg-gray-800/80 backdrop-blur-md rounded-lg shadow-xl w-11/12 max-w-2xl relative flex flex-col max-h-[90vh]">
        </div>
    </div>

    <!-- Loading Spinner Overlay -->
    <div id="loading-spinner"
        class="fixed inset-0 z-[80] bg-black/60 backdrop-blur-sm flex-col items-center justify-center hidden"
        style="display: none;">
        <div class="w-16 h-16 border-4 border-t-indigo-500 border-gray-600 rounded-full animate-spin"></div>
        <p id="spinner-message" class="mt-4 text-white font-semibold">Loading...</p>
    </div>

    <!-- Story Details Modal (Mobile) -->
    <div id="story-details-modal" class="fixed inset-0 z-50 items-center justify-center hidden">
        <div class="modal-overlay absolute inset-0" data-action="close-modal" data-id="story-details-modal"></div>
        <div class="bg-gray-800/80 backdrop-blur-md rounded-lg shadow-xl relative flex flex-col"
            style="width: 100%; max-width: 1200px; height: 100%;">
            <div id="story-details-content-mobile" class="flex-grow flex flex-col min-h-0"></div>
        </div>
    </div>

    <!-- Characters Modal -->
    <div id="characters-modal" class="fixed inset-0 z-50 items-center justify-center hidden">
        <div class="modal-overlay absolute inset-0" data-action="close-modal" data-id="characters-modal"></div>
        <div
            class="bg-gray-800/80 backdrop-blur-md rounded-lg shadow-xl w-11/12 md:w-3/4 lg:w-2/3 relative flex flex-col max-h-[90vh]">
            <div class="p-6 border-b border-gray-700 flex justify-between items-center">
                <h2 class="text-2xl font-semibold">Character Roster</h2>
                <div class="flex items-center gap-2">
                    <button onclick="NarrativeController.addCharacter()"
                        class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold p-2 rounded-lg"
                        title="Add Character">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M12 6v6m0 0v6m0-6h6m-6 0H6">
                            </path>
                        </svg>
                    </button>
                    <button data-action="close-modal" data-id="characters-modal" aria-label="Close"
                        class="bg-gray-700 hover:bg-gray-600 text-gray-300 hover:text-white p-2 rounded-lg transition-colors">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M6 18L18 6M6 6l12 12"></path>
                        </svg>
                    </button>
                </div>
            </div>
            <div class="p-6 overflow-y-auto">
                <div id="characters-container" class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6"></div>
            </div>
        </div>
    </div>

    <!-- Individual Character Detail Modal -->
    <div id="character-detail-modal" class="fixed inset-0 z-[60] items-center justify-center hidden">
        <div class="modal-overlay absolute inset-0 bg-black/50" data-action="close-modal"
            data-id="character-detail-modal"></div>
        <div id="character-detail-modal-content"
            class="bg-gray-800/80 backdrop-blur-md rounded-lg shadow-xl relative flex flex-col max-h-[90vh]"
            style="width: 95%; max-width: 1200px;"></div>
    </div>

    <!-- Knowledge Modal -->
    <div id="knowledge-modal" class="fixed inset-0 z-50 items-center justify-center hidden p-4">
        <div class="modal-overlay absolute inset-0" data-action="close-modal" data-id="knowledge-modal"></div>
        <div
            class="bg-gray-800/80 backdrop-blur-md rounded-lg shadow-xl relative flex flex-col w-full max-w-6xl h-[90vh] overflow-hidden">
            <div class="p-4 flex-shrink-0 flex justify-between items-center border-b border-gray-700">
                <div class="flex space-x-4">
                    <button id="knowledge-tab-static" onclick="UIManager.switchKnowledgeTab('static')"
                        class="py-2 px-2 font-semibold text-lg border-b-2 border-indigo-500 text-white">Static</button>
                    <button id="knowledge-tab-dynamic" onclick="UIManager.switchKnowledgeTab('dynamic')"
                        class="py-2 px-2 font-semibold text-lg border-b-2 border-transparent text-gray-400 hover:text-white">Dynamic</button>
                </div>
                <div class="flex items-center space-x-2">
                    <button data-action="close-modal" data-id="knowledge-modal"
                        class="bg-gray-700 hover:bg-gray-600 text-gray-300 hover:text-white p-2 rounded-lg transition-colors"
                        title="Close">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M6 18L18 6M6 6l12 12"></path>
                        </svg>
                    </button>
                </div>
            </div>
            <div class="p-4 flex-grow overflow-hidden min-h-0">
                <div id="knowledge-static-content" class="h-full flex flex-col md:flex-row gap-4">
                    <div class="w-full md:w-1/3 flex flex-col h-1/3 md:h-full">
                        <div id="static-entries-list" class="bg-black/30 rounded-t-lg p-2 overflow-y-auto flex-grow">
                        </div>
                    </div>
                    <div id="static-entry-details"
                        class="w-full md:w-2/3 bg-black/30 rounded-lg p-4 overflow-y-auto flex-1 md:flex-none md:h-full">
                        <div id="static-entry-details-content" class="h-full">
                            <div class="text-gray-400 flex items-center justify-center h-full">Select a static entry.
                            </div>
                        </div>
                    </div>
                </div>
                <div id="knowledge-dynamic-content" class="hidden h-full flex flex-col md:flex-row gap-4">
                    <div class="w-full md:w-1/3 flex flex-col h-1/3 md:h-full">
                        <div id="dynamic-entries-list" class="bg-black/30 rounded-t-lg p-2 overflow-y-auto flex-grow">
                        </div>
                    </div>
                    <div id="dynamic-entry-details"
                        class="w-full md:w-2/3 bg-black/30 rounded-lg p-4 overflow-y-auto flex-1 md:flex-none md:h-full">
                        <div id="dynamic-entry-details-content" class="h-full">
                            <div class="text-gray-400 flex items-center justify-center h-full">Select a dynamic entry.
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- World Map Modal -->
    <div id="world-map-modal" class="fixed inset-0 z-50 items-center justify-center hidden">
        <div class="modal-overlay absolute inset-0" data-action="close-modal" data-id="world-map-modal"></div>
        <div id="world-map-modal-content"
            class="bg-gray-800/80 backdrop-blur-md rounded-lg shadow-xl w-11/12 max-w-6xl relative flex flex-col max-h-[90vh] min-h-[50vh]">
        </div>
    </div>

    <div id="location-details-modal" class="fixed inset-0 z-[60] items-center justify-center hidden">
        <div class="modal-overlay absolute inset-0 bg-black/60" data-action="close-modal"
            data-id="location-details-modal"></div>
        <div
            class="bg-gray-800/90 backdrop-blur-md rounded-lg shadow-2xl w-11/12 max-w-4xl h-[85vh] relative flex flex-col border border-gray-600">
            <div
                class="p-4 border-b border-gray-700 flex justify-between items-center flex-shrink-0 bg-black/20 rounded-t-lg">
                <h3 class="text-xl font-bold text-white flex items-center gap-2">
                    <svg class="w-5 h-5 text-indigo-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z">
                        </path>
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M15 11a3 3 0 11-6 0 3 3 0 016 0z"></path>
                    </svg>
                    Location Details
                </h3>
                <button data-action="close-modal" data-id="location-details-modal" aria-label="Close"
                    class="bg-gray-700 hover:bg-gray-600 text-gray-300 hover:text-white p-2 rounded-lg transition-colors">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12">
                        </path>
                    </svg>
                </button>
            </div>

            <div id="location-details-content" class="p-6 overflow-y-auto flex-grow min-h-0"></div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settings-modal" class="fixed inset-0 z-50 items-center justify-center hidden p-4">
        <div class="modal-overlay absolute inset-0" data-action="close-modal" data-id="settings-modal"></div>
        <div
            class="bg-gray-800/80 backdrop-blur-md rounded-lg shadow-xl w-full max-w-2xl max-h-[85vh] relative flex flex-col overflow-hidden">
            <div class="p-6 flex-shrink-0 border-b border-gray-700 flex justify-between items-start"
                style="padding-bottom: .1rem;">
                <div class="min-w-0 flex-1">
                    <h2 class="text-2xl font-semibold mb-4">Settings</h2>
                    <div class="flex -mb-px space-x-4 overflow-x-auto no-scrollbar pb-1"
                        style="-webkit-overflow-scrolling: touch; scrollbar-width: none;">
                        <button id="settings-tab-appearance" onclick="AppController.switchSettingsTab('appearance')"
                            class="pb-2 font-semibold border-b-2 border-indigo-500 text-white transition-colors flex-shrink-0">Appearance</button>
                        <button id="settings-tab-prompt" onclick="AppController.switchSettingsTab('prompt')"
                            class="pb-2 font-semibold border-b-2 border-transparent text-gray-400 hover:text-white transition-colors flex-shrink-0">Prompts</button>
                        <button id="settings-tab-model" onclick="AppController.switchSettingsTab('model')"
                            class="pb-2 font-semibold border-b-2 border-transparent text-gray-400 hover:text-white transition-colors flex-shrink-0">Model</button>
                        <button id="settings-tab-image-gen" onclick="AppController.switchSettingsTab('image-gen')"
                            class="pb-2 font-semibold border-b-2 border-transparent text-gray-400 hover:text-white transition-colors flex-shrink-0">Images</button>
                        <button id="settings-tab-export" onclick="AppController.switchSettingsTab('export')"
                            class="pb-2 font-semibold border-b-2 border-transparent text-gray-400 hover:text-white transition-colors flex-shrink-0">Export</button>
                        <button id="settings-tab-personas" onclick="AppController.switchSettingsTab('personas')"
                            class="pb-2 font-semibold border-b-2 border-transparent text-gray-400 hover:text-white transition-colors flex-shrink-0">Users</button>
                    </div>
                </div>
                <button data-action="close-modal" data-id="settings-modal"
                    class="bg-gray-700 hover:bg-gray-600 text-gray-300 hover:text-white p-2 rounded-lg transition-colors -mt-2"
                    title="Close">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12">
                        </path>
                    </svg>
                </button>
            </div>
            <div class="p-4 md:p-6 pb-24 md:pb-6 overflow-y-auto flex-grow min-h-0 overscroll-auto"
                id="settings-content-container">...</div>
        </div>
    </div>

    <!-- Edit Response Modal -->
    <div id="edit-response-modal" class="fixed inset-0 z-50 items-center justify-center hidden">
        <div class="modal-overlay absolute inset-0" data-action="close-modal" data-id="edit-response-modal"></div>
        <div
            class="bg-gray-800/80 backdrop-blur-md rounded-lg shadow-xl w-11/12 max-w-[750px] h-[75vh] relative flex flex-col">
            <div class="p-4 border-b border-gray-700 flex-shrink-0 flex justify-between items-center">
                <h3 class="text-xl font-bold">Edit Response</h3>
                <div class="flex items-center space-x-2">
                    <button id="edit-modal-save-button"
                        class="bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-1 px-3 rounded-lg text-sm">Save</button>
                    <button data-action="close-modal" data-id="edit-response-modal" aria-label="Close"
                        class="bg-gray-700 hover:bg-gray-600 text-gray-300 hover:text-white p-2 rounded-lg transition-colors">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M6 18L18 6M6 6l12 12"></path>
                        </svg>
                    </button>
                </div>
            </div>
            <div class="p-4 overflow-y-auto flex-grow flex flex-col min-h-0">
                <textarea id="edit-modal-input" aria-label="Edit Response Content"
                    class="w-full h-full bg-gray-900 border-gray-700 rounded-lg p-4 resize-none focus:bg-black/40 transition-colors"></textarea>
            </div>
        </div>
    </div>

    <!-- View Raw Prompt Modal -->
    <div id="view-raw-prompt-modal" class="fixed inset-0 z-50 items-center justify-center hidden">
        <div class="modal-overlay absolute inset-0" data-action="close-modal" data-id="view-raw-prompt-modal"></div>
        <div
            class="bg-gray-800/80 backdrop-blur-md rounded-lg shadow-xl w-11/12 md:w-3/4 lg:w-2/3 relative flex flex-col max-h-[90vh]">
            <div class="p-6 border-b border-gray-700 flex justify-between items-center">
                <h2 class="text-2xl font-semibold">Raw Prompt</h2>
                <button data-action="close-modal" data-id="view-raw-prompt-modal"
                    class="bg-gray-700 hover:bg-gray-600 text-gray-300 hover:text-white p-2 rounded-lg transition-colors"
                    title="Close">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12">
                        </path>
                    </svg>
                </button>
            </div>
            <div class="p-6 overflow-y-auto flex-grow bg-gray-900">
                <pre id="raw-prompt-content" class="text-sm whitespace-pre-wrap"></pre>
            </div>
            <div class="p-4 bg-black/20 border-t border-gray-700 flex justify-end"><button data-action="close-modal"
                    data-id="view-raw-prompt-modal"
                    class="bg-gray-600 hover:bg-gray-700 font-bold py-2 px-4 rounded-lg">Done</button></div>
        </div>
    </div>

    <!-- Example Dialogue Modal -->
    <div id="example-dialogue-modal" class="fixed inset-0 z-[60] items-center justify-center hidden">
        <div class="modal-overlay absolute inset-0 bg-black/50" data-action="close-modal"
            data-id="example-dialogue-modal"></div>
        <div
            class="bg-gray-800/80 backdrop-blur-md rounded-lg shadow-xl w-11/12 md:w-3/4 lg:w-2/3 relative flex flex-col max-h-[90vh]">
            <div class="p-6 border-b border-gray-700 flex justify-between items-center">
                <h2 class="text-2xl font-semibold">Edit Example Dialogue</h2>
                <button onclick="NarrativeController.addExampleDialogueTurn()"
                    class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg">Add
                    Turn</button>
            </div>
            <div id="example-dialogue-container" class="p-6 overflow-y-auto flex-grow space-y-4"></div>
            <div class="p-4 bg-black/20 border-t border-gray-700 flex justify-end">
                <button data-action="close-modal" data-id="example-dialogue-modal"
                    class="bg-gray-600 hover:bg-gray-700 font-bold py-2 px-4 rounded-lg">Done</button>
            </div>
        </div>
    </div>

    <!-- Generic Confirmation Modal -->
    <div id="confirmation-modal" class="fixed inset-0 z-[70] items-center justify-center hidden">
        <div class="modal-overlay absolute inset-0 bg-black/60" data-action="close-modal" data-id="confirmation-modal">
        </div>
        <div class="bg-gray-800/80 backdrop-blur-md rounded-lg shadow-xl w-11/12 max-w-md relative flex flex-col">
            <div class="p-6">
                <h3 class="text-xl font-bold mb-4">Are you sure?</h3>
                <p id="confirmation-modal-message" class="text-gray-300">This action cannot be undone.</p>
            </div>
            <div class="p-4 bg-black/20 border-t border-gray-700 flex justify-end space-x-4">
                <button data-action="close-modal" data-id="confirmation-modal"
                    class="bg-gray-600 hover:bg-gray-700 font-bold py-2 px-4 rounded-lg">Cancel</button>
                <button id="confirmation-modal-confirm-button"
                    class="bg-red-600 hover:bg-red-700 font-bold py-2 px-4 rounded-lg">Confirm</button>
            </div>
        </div>
    </div>

    <!-- OpenRouter Model Browser Modal -->
    <div id="openrouter-model-modal" class="fixed inset-0 z-[80] items-center justify-center hidden">
        <div class="modal-overlay absolute inset-0 bg-black/60" data-action="close-modal"
            data-id="openrouter-model-modal"></div>
        <div
            class="bg-gray-800/95 backdrop-blur-md rounded-lg shadow-xl w-11/12 max-w-2xl relative flex flex-col max-h-[85vh]">
            <div class="p-4 border-b border-gray-700 flex justify-between items-center">
                <h3 class="text-xl font-bold">Browse OpenRouter Models</h3>
                <button data-action="close-modal" data-id="openrouter-model-modal"
                    class="text-gray-400 hover:text-white">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12">
                        </path>
                    </svg>
                </button>
            </div>
            <div class="p-4 border-b border-gray-700">
                <input type="text" id="openrouter-model-search"
                    class="w-full rounded-lg p-3 bg-gray-900/50 border border-gray-600 focus:border-indigo-500 focus:outline-none"
                    placeholder="Search models by name or provider...">
            </div>
            <div id="openrouter-model-list" class="flex-1 overflow-y-auto p-2 min-h-[300px]">
                <div class="flex items-center justify-center h-full text-gray-400">
                    <span>Loading models...</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Hidden template for settings tabs -->
    <div id="settings-templates" class="hidden">
        <!-- IMAGE GEN SETTINGS -->


        <div id="settings-appearance-content" class="space-y-6">
            <div>
                <div class="grid grid-cols-2 gap-4 mb-4">
                    <div>
                        <label for="font-selector" class="text-gray-400 text-sm block mb-2">Chat Font</label>
                        <select id="font-selector" class="w-full rounded-lg p-2">
                            <option value="'Inter', sans-serif" style="font-family: 'Inter', sans-serif">Inter
                                (Standard)</option>
                            <option value="'Prompt', sans-serif" style="font-family: 'Prompt', sans-serif">Prompt
                                (Modern)</option>
                            <option value="'Nunito Sans', sans-serif" style="font-family: 'Nunito Sans', sans-serif">
                                Nunito Sans (Soft)</option>
                            <option value="'Source Code Pro', monospace"
                                style="font-family: 'Source Code Pro', monospace">Source Code Pro (Code)</option>
                            <option value="'Lora', serif" style="font-family: 'Lora', serif">Lora (Serif)</option>
                            <option value="'Domine', serif" style="font-family: 'Domine', serif">Domine (Bold Serif)
                            </option>
                            <option value="'Roboto Slab', serif" style="font-family: 'Roboto Slab', serif">Roboto Slab
                                (Slab)</option>
                            <option value="'EB Garamond', serif" style="font-family: 'EB Garamond', serif">E Garamond
                                (Classic)</option>
                            <option value="'Cormorant Garamond', serif"
                                style="font-family: 'Cormorant Garamond', serif">Cormorant Garamond (Elegant)</option>
                            <option value="'Comic Neue', sans-serif" style="font-family: 'Comic Neue', sans-serif">Comic
                                Neue (Comic)</option>
                            <option value="'Caveat', cursive" style="font-family: 'Caveat', cursive">Caveat
                                (Handwriting)</option>
                            <option value="'Patrick Hand', cursive" style="font-family: 'Patrick Hand', cursive">Patrick
                                Hand (Neat Hand)</option>
                            <option value="'Dancing Script', cursive" style="font-family: 'Dancing Script', cursive">
                                Dancing Script (Cursive)</option>
                            <option value="'Titan One', cursive" style="font-family: 'Titan One', cursive">Titan One
                                (Chunky)</option>
                        </select>
                    </div>
                    <div><label for="chat-text-color" class="text-gray-400 text-sm block mb-2">Chat Text
                            Color</label><input type="color" id="chat-text-color" class="w-full rounded-lg p-1 h-10">
                    </div>
                </div>

                <details class="bg-black/20 rounded-lg p-2 mb-4 w-full">
                    <summary class="cursor-pointer font-semibold text-gray-300 hover:text-white select-none p-2">
                        Markdown Styling</summary>
                    <div class="grid grid-cols-2 gap-4 p-2 mt-2 border-t border-gray-700">

                        <div>
                            <label class="text-xs text-gray-400 block mb-1">Heading 1 Font</label>
                            <select id="md-h1-font-input"
                                class="w-full rounded p-1 text-xs bg-gray-700 border border-gray-600">
                                <option value="">Use Default</option>
                                <option value="'Inter', sans-serif" style="font-family: 'Inter', sans-serif">Inter
                                    (Standard)</option>
                                <option value="'Prompt', sans-serif" style="font-family: 'Prompt', sans-serif">
                                    Prompt
                                    (Modern)</option>
                                <option value="'Nunito Sans', sans-serif"
                                    style="font-family: 'Nunito Sans', sans-serif">Nunito Sans (Soft)</option>
                                <option value="'Source Code Pro', monospace"
                                    style="font-family: 'Source Code Pro', monospace">Source Code Pro (Code)
                                </option>
                                <option value="'Lora', serif" style="font-family: 'Lora', serif">Lora (Serif)
                                </option>
                                <option value="'Domine', serif" style="font-family: 'Domine', serif">Domine (Bold
                                    Serif)
                                </option>
                                <option value="'Roboto Slab', serif" style="font-family: 'Roboto Slab', serif">
                                    Roboto
                                    Slab (Slab)</option>
                                <option value="'EB Garamond', serif" style="font-family: 'EB Garamond', serif">EB
                                    Garamond (Classic)</option>
                                <option value="'Cormorant Garamond', serif"
                                    style="font-family: 'Cormorant Garamond', serif">Cormorant Garamond (Elegant)
                                </option>
                                <option value="'Comic Neue', sans-serif" style="font-family: 'Comic Neue', sans-serif">
                                    Comic Neue (Comic)</option>
                                <option value="'Caveat', cursive" style="font-family: 'Caveat', cursive">Caveat
                                    (Handwriting)</option>
                                <option value="'Patrick Hand', cursive" style="font-family: 'Patrick Hand', cursive">
                                    Patrick Hand (Neat Hand)</option>
                                <option value="'Dancing Script', cursive"
                                    style="font-family: 'Dancing Script', cursive">Dancing Script (Cursive)</option>
                                <option value="'Titan One', cursive" style="font-family: 'Titan One', cursive">Titan
                                    One
                                    (Chunky)</option>
                            </select>
                        </div>
                        <div><label class="text-xs text-gray-400 block mb-1">Heading 1 Color</label><input type="color"
                                id="md-h1-color-input" class="w-full h-7 rounded cursor-pointer"></div>

                        <div>
                            <label class="text-xs text-gray-400 block mb-1">Heading 2 Font</label>
                            <select id="md-h2-font-input"
                                class="w-full rounded p-1 text-xs bg-gray-700 border border-gray-600">
                                <option value="">Use Default</option>
                                <option value="'Inter', sans-serif" style="font-family: 'Inter', sans-serif">Inter
                                    (Standard)</option>
                                <option value="'Prompt', sans-serif" style="font-family: 'Prompt', sans-serif">
                                    Prompt
                                    (Modern)</option>
                                <option value="'Nunito Sans', sans-serif"
                                    style="font-family: 'Nunito Sans', sans-serif">Nunito Sans (Soft)</option>
                                <option value="'Source Code Pro', monospace"
                                    style="font-family: 'Source Code Pro', monospace">Source Code Pro (Code)
                                </option>
                                <option value="'Lora', serif" style="font-family: 'Lora', serif">Lora (Serif)
                                </option>
                                <option value="'Domine', serif" style="font-family: 'Domine', serif">Domine (Bold
                                    Serif)
                                </option>
                                <option value="'Roboto Slab', serif" style="font-family: 'Roboto Slab', serif">
                                    Roboto
                                    Slab (Slab)</option>
                                <option value="'EB Garamond', serif" style="font-family: 'EB Garamond', serif">EB
                                    Garamond (Classic)</option>
                                <option value="'Cormorant Garamond', serif"
                                    style="font-family: 'Cormorant Garamond', serif">Cormorant Garamond (Elegant)
                                </option>
                                <option value="'Comic Neue', sans-serif" style="font-family: 'Comic Neue', sans-serif">
                                    Comic Neue (Comic)</option>
                                <option value="'Caveat', cursive" style="font-family: 'Caveat', cursive">Caveat
                                    (Handwriting)</option>
                                <option value="'Patrick Hand', cursive" style="font-family: 'Patrick Hand', cursive">
                                    Patrick Hand (Neat Hand)</option>
                                <option value="'Dancing Script', cursive"
                                    style="font-family: 'Dancing Script', cursive">Dancing Script (Cursive)</option>
                                <option value="'Titan One', cursive" style="font-family: 'Titan One', cursive">Titan
                                    One
                                    (Chunky)</option>
                            </select>
                        </div>
                        <div><label class="text-xs text-gray-400 block mb-1">Heading 2 Color</label><input type="color"
                                id="md-h2-color-input" class="w-full h-7 rounded cursor-pointer"></div>

                        <div>
                            <label class="text-xs text-gray-400 block mb-1">Heading 3 Font</label>
                            <select id="md-h3-font-input"
                                class="w-full rounded p-1 text-xs bg-gray-700 border border-gray-600">
                                <option value="">Use Default</option>
                                <option value="'Inter', sans-serif" style="font-family: 'Inter', sans-serif">Inter
                                    (Standard)</option>
                                <option value="'Prompt', sans-serif" style="font-family: 'Prompt', sans-serif">
                                    Prompt
                                    (Modern)</option>
                                <option value="'Nunito Sans', sans-serif"
                                    style="font-family: 'Nunito Sans', sans-serif">Nunito Sans (Soft)</option>
                                <option value="'Source Code Pro', monospace"
                                    style="font-family: 'Source Code Pro', monospace">Source Code Pro (Code)
                                </option>
                                <option value="'Lora', serif" style="font-family: 'Lora', serif">Lora (Serif)
                                </option>
                                <option value="'Domine', serif" style="font-family: 'Domine', serif">Domine (Bold
                                    Serif)
                                </option>
                                <option value="'Roboto Slab', serif" style="font-family: 'Roboto Slab', serif">
                                    Roboto
                                    Slab (Slab)</option>
                                <option value="'EB Garamond', serif" style="font-family: 'EB Garamond', serif">EB
                                    Garamond (Classic)</option>
                                <option value="'Cormorant Garamond', serif"
                                    style="font-family: 'Cormorant Garamond', serif">Cormorant Garamond (Elegant)
                                </option>
                                <option value="'Comic Neue', sans-serif" style="font-family: 'Comic Neue', sans-serif">
                                    Comic Neue (Comic)</option>
                                <option value="'Caveat', cursive" style="font-family: 'Caveat', cursive">Caveat
                                    (Handwriting)</option>
                                <option value="'Patrick Hand', cursive" style="font-family: 'Patrick Hand', cursive">
                                    Patrick Hand (Neat Hand)</option>
                                <option value="'Dancing Script', cursive"
                                    style="font-family: 'Dancing Script', cursive">Dancing Script (Cursive)</option>
                                <option value="'Titan One', cursive" style="font-family: 'Titan One', cursive">Titan
                                    One
                                    (Chunky)</option>
                            </select>
                        </div>
                        <div><label class="text-xs text-gray-400 block mb-1">Heading 3 Color</label><input type="color"
                                id="md-h3-color-input" class="w-full h-7 rounded cursor-pointer"></div>

                        <div>
                            <label class="text-xs text-gray-400 block mb-1">Bold Text Font</label>
                            <select id="md-bold-font-input"
                                class="w-full rounded p-1 text-xs bg-gray-700 border border-gray-600">
                                <option value="">Use Default</option>
                                <option value="'Inter', sans-serif" style="font-family: 'Inter', sans-serif">Inter
                                    (Standard)</option>
                                <option value="'Prompt', sans-serif" style="font-family: 'Prompt', sans-serif">
                                    Prompt
                                    (Modern)</option>
                                <option value="'Nunito Sans', sans-serif"
                                    style="font-family: 'Nunito Sans', sans-serif">Nunito Sans (Soft)</option>
                                <option value="'Source Code Pro', monospace"
                                    style="font-family: 'Source Code Pro', monospace">Source Code Pro (Code)
                                </option>
                                <option value="'Lora', serif" style="font-family: 'Lora', serif">Lora (Serif)
                                </option>
                                <option value="'Domine', serif" style="font-family: 'Domine', serif">Domine (Bold
                                    Serif)
                                </option>
                                <option value="'Roboto Slab', serif" style="font-family: 'Roboto Slab', serif">
                                    Roboto
                                    Slab (Slab)</option>
                                <option value="'EB Garamond', serif" style="font-family: 'EB Garamond', serif">EB
                                    Garamond (Classic)</option>
                                <option value="'Cormorant Garamond', serif"
                                    style="font-family: 'Cormorant Garamond', serif">Cormorant Garamond (Elegant)
                                </option>
                                <option value="'Comic Neue', sans-serif" style="font-family: 'Comic Neue', sans-serif">
                                    Comic Neue (Comic)</option>
                                <option value="'Caveat', cursive" style="font-family: 'Caveat', cursive">Caveat
                                    (Handwriting)</option>
                                <option value="'Patrick Hand', cursive" style="font-family: 'Patrick Hand', cursive">
                                    Patrick Hand (Neat Hand)</option>
                                <option value="'Dancing Script', cursive"
                                    style="font-family: 'Dancing Script', cursive">Dancing Script (Cursive)</option>
                                <option value="'Titan One', cursive" style="font-family: 'Titan One', cursive">Titan
                                    One
                                    (Chunky)</option>
                            </select>
                        </div>
                        <div><label class="text-xs text-gray-400 block mb-1">Bold Text Color</label><input type="color"
                                id="md-bold-color-input" class="w-full h-7 rounded cursor-pointer">
                        </div>

                        <div>
                            <label class="text-xs text-gray-400 block mb-1">Italic Text Font</label>
                            <select id="md-italic-font-input"
                                class="w-full rounded p-1 text-xs bg-gray-700 border border-gray-600">
                                <option value="">Use Default</option>
                                <option value="'Inter', sans-serif" style="font-family: 'Inter', sans-serif">Inter
                                    (Standard)</option>
                                <option value="'Prompt', sans-serif" style="font-family: 'Prompt', sans-serif">
                                    Prompt
                                    (Modern)</option>
                                <option value="'Nunito Sans', sans-serif"
                                    style="font-family: 'Nunito Sans', sans-serif">Nunito Sans (Soft)</option>
                                <option value="'Source Code Pro', monospace"
                                    style="font-family: 'Source Code Pro', monospace">Source Code Pro (Code)
                                </option>
                                <option value="'Lora', serif" style="font-family: 'Lora', serif">Lora (Serif)
                                </option>
                                <option value="'Domine', serif" style="font-family: 'Domine', serif">Domine (Bold
                                    Serif)
                                </option>
                                <option value="'Roboto Slab', serif" style="font-family: 'Roboto Slab', serif">
                                    Roboto
                                    Slab (Slab)</option>
                                <option value="'EB Garamond', serif" style="font-family: 'EB Garamond', serif">EB
                                    Garamond (Classic)</option>
                                <option value="'Cormorant Garamond', serif"
                                    style="font-family: 'Cormorant Garamond', serif">Cormorant Garamond (Elegant)
                                </option>
                                <option value="'Comic Neue', sans-serif" style="font-family: 'Comic Neue', sans-serif">
                                    Comic Neue (Comic)</option>
                                <option value="'Caveat', cursive" style="font-family: 'Caveat', cursive">Caveat
                                    (Handwriting)</option>
                                <option value="'Patrick Hand', cursive" style="font-family: 'Patrick Hand', cursive">
                                    Patrick Hand (Neat Hand)</option>
                                <option value="'Dancing Script', cursive"
                                    style="font-family: 'Dancing Script', cursive">Dancing Script (Cursive)</option>
                                <option value="'Titan One', cursive" style="font-family: 'Titan One', cursive">Titan
                                    One
                                    (Chunky)</option>
                            </select>
                        </div>
                        <div><label class="text-xs text-gray-400 block mb-1">Italic Text Color</label><input
                                type="color" id="md-italic-color-input" class="w-full h-7 rounded cursor-pointer">
                        </div>

                        <div>
                            <label class="text-xs text-gray-400 block mb-1">Quote Font</label>
                            <select id="md-quote-font-input"
                                class="w-full rounded p-1 text-xs bg-gray-700 border border-gray-600">
                                <option value="">Use Default</option>
                                <option value="'Inter', sans-serif" style="font-family: 'Inter', sans-serif">Inter
                                    (Standard)</option>
                                <option value="'Prompt', sans-serif" style="font-family: 'Prompt', sans-serif">
                                    Prompt
                                    (Modern)</option>
                                <option value="'Nunito Sans', sans-serif"
                                    style="font-family: 'Nunito Sans', sans-serif">Nunito Sans (Soft)</option>
                                <option value="'Source Code Pro', monospace"
                                    style="font-family: 'Source Code Pro', monospace">Source Code Pro (Code)
                                </option>
                                <option value="'Lora', serif" style="font-family: 'Lora', serif">Lora (Serif)
                                </option>
                                <option value="'Domine', serif" style="font-family: 'Domine', serif">Domine (Bold
                                    Serif)
                                </option>
                                <option value="'Roboto Slab', serif" style="font-family: 'Roboto Slab', serif">
                                    Roboto
                                    Slab (Slab)</option>
                                <option value="'EB Garamond', serif" style="font-family: 'EB Garamond', serif">EB
                                    Garamond (Classic)</option>
                                <option value="'Cormorant Garamond', serif"
                                    style="font-family: 'Cormorant Garamond', serif">Cormorant Garamond (Elegant)
                                </option>
                                <option value="'Comic Neue', sans-serif" style="font-family: 'Comic Neue', sans-serif">
                                    Comic Neue (Comic)</option>
                                <option value="'Caveat', cursive" style="font-family: 'Caveat', cursive">Caveat
                                    (Handwriting)</option>
                                <option value="'Patrick Hand', cursive" style="font-family: 'Patrick Hand', cursive">
                                    Patrick Hand (Neat Hand)</option>
                                <option value="'Dancing Script', cursive"
                                    style="font-family: 'Dancing Script', cursive">Dancing Script (Cursive)</option>
                                <option value="'Titan One', cursive" style="font-family: 'Titan One', cursive">Titan
                                    One
                                    (Chunky)</option>
                            </select>
                        </div>
                        <div><label class="text-xs text-gray-400 block mb-1">Quote Color</label><input type="color"
                                id="md-quote-color-input" class="w-full h-7 rounded cursor-pointer"></div>
                    </div>
                </details>

                <div>
                    <label for="background-image-upload" class="text-gray-400 text-sm block mb-2">Background
                        Image</label>
                    <span id="background-image-hint" class="text-xs text-gray-500 block mb-1"></span>
                    <div class="flex space-x-2">
                        <input type="file" id="background-image-upload" accept="image/*"
                            class="block w-full text-sm text-gray-400 file:mr-4 file:py-1 file:px-3 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-gray-700 file:text-gray-200 hover:file:bg-gray-600 cursor-pointer">
                        <button onclick="AppController.openBackgroundImageGenerator()"
                            class="bg-indigo-600/80 hover:bg-indigo-700/80 text-white font-bold py-1 px-3 rounded-lg flex items-center gap-1 flex-shrink-0">
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z">
                                </path>
                            </svg>
                            Generate
                        </button>
                        <button id="background-image-clear"
                            class="bg-red-600/80 hover:bg-red-700/80 text-white font-bold py-1 px-3 rounded-lg flex-shrink-0">Clear</button>
                    </div>
                </div>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-4">
                    <div><label for="bubble-opacity-slider" class="text-gray-400 text-sm block mb-2">Chat Bubble
                            Opacity</label>
                        <div class="flex items-center space-x-4"><input type="range" id="bubble-opacity-slider"
                                class="w-full" min="0" max="1" step="0.05"><span id="bubble-opacity-value"
                                class="text-sm text-gray-400 w-12 text-right"></span></div>
                    </div>
                    <div><label for="blur-slider" class="text-gray-400 text-sm block mb-2">Background Blur
                            (px)</label>
                        <div class="flex items-center space-x-4"><input type="range" id="blur-slider" class="w-full"
                                min="0" max="20" step="1"><span id="blur-value"
                                class="text-sm text-gray-400 w-12 text-right"></span></div>
                    </div>
                    <div><label for="text-size-slider" class="text-gray-400 text-sm block mb-2">Text Size
                            (px)</label>
                        <div class="flex items-center space-x-4"><input type="range" id="text-size-slider"
                                class="w-full" min="12" max="36" step="1"><span id="text-size-value"
                                class="text-sm text-gray-400 w-12 text-right"></span></div>
                    </div>
                    <div><label for="bubble-image-size-slider" class="text-gray-400 text-sm block mb-2">Bubble Image
                            Size (px)</label>
                        <div class="flex items-center space-x-4"><input type="range" id="bubble-image-size-slider"
                                class="w-full" min="50" max="200" step="10"><span id="bubble-image-size-value"
                                class="text-sm text-gray-400 w-12 text-right"></span></div>
                    </div>
                </div>
                <label class="text-gray-400 text-sm block mt-4 mb-2">Character Image Display</label>
                <div class="flex space-x-4" id="character-image-display"><label
                        class="flex items-center space-x-2 cursor-pointer"><input type="radio" name="imageDisplayMode"
                            value="none"><span>None</span></label><label
                        class="flex items-center space-x-2 cursor-pointer"><input type="radio" name="imageDisplayMode"
                            value="cinematic_overlay"><span>Cinematic</span></label><label
                        class="flex items-center space-x-2 cursor-pointer"><input type="radio" name="imageDisplayMode"
                            value="bubble"><span>Bubble</span></label></div>
            </div>
            <div class="mt-4 p-3 bg-black/20 rounded-lg border border-gray-700">
                <label class="flex items-center justify-between cursor-pointer">
                    <span class="text-gray-300 font-medium">Show Portrait Panel (Desktop)</span>
                    <div class="relative">
                        <input type="checkbox" id="show-portrait-panel-toggle" class="sr-only peer">
                        <div
                            class="w-11 h-6 bg-gray-700 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-indigo-600">
                        </div>
                    </div>
                </label>
                <p class="text-xs text-gray-500 mt-1">If disabled, the chat window will be centered.</p>
            </div>
            <div class="pt-6 mt-4 border-t border-gray-700/50 text-center">
                <p id="build-info-display"
                    class="text-xs text-gray-600 font-mono uppercase tracking-widest opacity-75 select-all"></p>
            </div>
        </div>

        <div id="settings-prompt-content" class="space-y-6">
            <!-- Action Buttons -->
            <div class="flex justify-center flex-wrap gap-4 pt-2 pb-6 border-b border-gray-700/30">
                <button onclick="NarrativeController.viewRawPrompt()"
                    class="flex items-center space-x-2 bg-gray-800 hover:bg-gray-700 border border-gray-600 hover:border-gray-500 text-white font-medium py-2 px-4 rounded-lg transition-all shadow-sm">
                    <svg class="w-4 h-4 text-indigo-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4"></path>
                    </svg>
                    <span>View Raw Prompt</span>
                </button>
                <button data-action="open-modal" data-target="example-dialogue-modal"
                    class="flex items-center space-x-2 bg-gray-800 hover:bg-gray-700 border border-gray-600 hover:border-gray-500 text-white font-medium py-2 px-4 rounded-lg transition-all shadow-sm">
                    <svg class="w-4 h-4 text-sky-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M8 10h.01M12 10h.01M16 10h.01M9 16H5a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v8a2 2 0 01-2 2h-5l-5 5v-5z">
                        </path>
                    </svg>
                    <span>Edit Example Dialogue</span>
                </button>
            </div>

            <!-- Global Settings Grid -->
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div class="bg-gray-900/30 p-4 rounded-lg border border-gray-700/50">
                    <label class="block text-xs font-bold text-gray-500 uppercase tracking-wider mb-2">Response
                        Length</label>
                    <div class="relative">
                        <select id="response-length-selector"
                            class="w-full appearance-none rounded-lg p-3 bg-gray-800 border border-gray-600 text-white focus:border-indigo-500 focus:ring-1 focus:ring-indigo-500 transition-colors">
                            <option value="short">Short (1-2 Sentences)</option>
                            <option value="medium">Medium (2-4 Sentences)</option>
                            <option value="normal">Default (Unconstrained)</option>
                            <option value="long">Long (Detailed)</option>
                            <option value="novel">Novel (Creative Writing)</option>
                        </select>
                        <div
                            class="pointer-events-none absolute inset-y-0 right-0 flex items-center px-4 text-gray-400">
                            <svg class="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M19 9l-7 7-7-7">
                                </path>
                            </svg>
                        </div>
                    </div>
                </div>

                <!-- AI Analysis Toggle -->
                <div
                    class="flex items-center justify-between bg-gray-900/30 p-4 rounded-lg border border-gray-700/50 hover:bg-gray-900/40 transition-colors">
                    <div>
                        <span class="text-gray-200 font-medium block">Enable AI Analysis</span>
                        <span class="text-xs text-gray-500">Auto-detects emotions and location changes. Disabling saves
                            tokens.</span>
                    </div>
                    <label class="relative inline-flex items-center cursor-pointer">
                        <input type="checkbox" id="enable-analysis-toggle" class="sr-only peer">
                        <div
                            class="w-11 h-6 bg-gray-700 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-indigo-600">
                        </div>
                    </label>
                </div>
            </div>

            <div class="space-y-3 pt-4">
                <h3 class="text-xs font-bold text-gray-500 uppercase tracking-wider px-1">Masters & Logic</h3>

                <!-- Event Master -->
                <details
                    class="group bg-gray-900/30 border border-gray-700/50 rounded-lg overflow-hidden transition-all duration-200 open:border-indigo-500/30">
                    <summary
                        class="flex items-center justify-between p-4 cursor-pointer hover:bg-white/5 transition-colors list-none">
                        <span class="font-medium text-gray-200">Event Master</span>
                        <svg class="w-5 h-5 text-gray-500 group-open:rotate-180 transition-transform duration-200"
                            fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7">
                            </path>
                        </svg>
                    </summary>
                    <div class="p-4 pt-0 border-t border-gray-700/30 mt-2">
                        <p class="text-gray-400 text-sm mb-3">Define the base instruction for the Event Master, which
                            injects plot twists.</p>
                        <textarea id="event-master-prompt-input"
                            class="w-full bg-black/20 border border-gray-600 rounded-lg p-3 text-sm text-gray-300 focus:border-indigo-500 focus:ring-1 focus:ring-indigo-500 resize-y mb-4 font-mono"
                            rows="4"></textarea>

                        <div
                            class="flex items-center justify-between bg-black/20 rounded-lg p-3 border border-gray-700/50">
                            <label for="event-master-prob-input" class="text-gray-300 text-sm font-medium">Trigger
                                Probability</label>
                            <div class="flex items-center space-x-2">
                                <input type="number" id="event-master-prob-input" min="0" max="100"
                                    class="w-16 bg-gray-800 border border-gray-600 rounded-md p-1.5 text-center text-white text-sm focus:border-indigo-500"
                                    placeholder="0">
                                <span class="text-gray-500 text-sm">%</span>
                            </div>
                        </div>
                    </div>
                </details>

                <!-- Visual Master -->
                <details
                    class="group bg-gray-900/30 border border-gray-700/50 rounded-lg overflow-hidden transition-all duration-200 open:border-indigo-500/30">
                    <summary
                        class="flex items-center justify-between p-4 cursor-pointer hover:bg-white/5 transition-colors list-none">
                        <span class="font-medium text-gray-200">Visual Master</span>
                        <svg class="w-5 h-5 text-gray-500 group-open:rotate-180 transition-transform duration-200"
                            fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7">
                            </path>
                        </svg>
                    </summary>
                    <div class="p-4 pt-0 border-t border-gray-700/30 mt-2">
                        <p class="text-gray-400 text-sm mb-3">Automatically generates visuals for the scene based on
                            chat context.</p>

                        <div
                            class="flex items-center justify-between bg-black/20 rounded-lg p-3 border border-gray-700/50 mb-4">
                            <label for="visual-master-prob-input" class="text-gray-300 text-sm font-medium">Trigger
                                Probability</label>
                            <div class="flex items-center space-x-2">
                                <input type="number" id="visual-master-prob-input" min="0" max="100"
                                    class="w-16 bg-gray-800 border border-gray-600 rounded-md p-1.5 text-center text-white text-sm focus:border-indigo-500"
                                    placeholder="0">
                                <span class="text-gray-500 text-sm">%</span>
                            </div>
                        </div>

                        <div>
                            <label class="text-xs text-gray-500 uppercase font-bold block mb-2">Visual Master Prompt
                                (Base)</label>
                            <textarea id="visual-master-prompt-input"
                                class="w-full bg-black/20 border border-gray-600 rounded-lg p-3 text-sm text-gray-300 focus:border-indigo-500 focus:ring-1 focus:ring-indigo-500 resize-y font-mono"
                                rows="3" placeholder="Describe the artistic style..."></textarea>
                        </div>
                    </div>
                </details>
            </div>

            <div class="space-y-3 pt-4">
                <h3 class="text-xs font-bold text-gray-500 uppercase tracking-wider px-1">Generation Prompts</h3>

                <!-- Persona Gen -->
                <details
                    class="group bg-gray-900/30 border border-gray-700/50 rounded-lg overflow-hidden transition-all duration-200 open:border-indigo-500/30">
                    <summary
                        class="flex items-center justify-between p-4 cursor-pointer hover:bg-white/5 transition-colors list-none">
                        <span class="font-medium text-gray-200">Persona Generation</span>
                        <svg class="w-5 h-5 text-gray-500 group-open:rotate-180 transition-transform duration-200"
                            fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7">
                            </path>
                        </svg>
                    </summary>
                    <div class="p-4 pt-0 border-t border-gray-700/30 mt-2">
                        <p class="text-gray-400 text-sm mb-3">Used by the AI button on a character's persona. Variable:
                            <code class="bg-black/40 px-1 rounded text-indigo-300">{concept}</code>
                        </p>
                        <textarea id="prompt-persona-gen-input"
                            class="w-full bg-black/20 border border-gray-600 rounded-lg p-3 text-sm text-gray-300 focus:border-indigo-500 focus:ring-1 focus:ring-indigo-500 resize-y font-mono"
                            rows="4"></textarea>
                    </div>
                </details>

                <!-- World Map Gen -->
                <details
                    class="group bg-gray-900/30 border border-gray-700/50 rounded-lg overflow-hidden transition-all duration-200 open:border-indigo-500/30">
                    <summary
                        class="flex items-center justify-between p-4 cursor-pointer hover:bg-white/5 transition-colors list-none">
                        <span class="font-medium text-gray-200">World Map Generation</span>
                        <svg class="w-5 h-5 text-gray-500 group-open:rotate-180 transition-transform duration-200"
                            fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7">
                            </path>
                        </svg>
                    </summary>
                    <div class="p-4 pt-0 border-t border-gray-700/30 mt-2">
                        <p class="text-gray-400 text-sm mb-3">Generates the entire world map. Variables: <code
                                class="bg-black/40 px-1 rounded text-indigo-300">{characters}</code>, <code
                                class="bg-black/40 px-1 rounded text-indigo-300">{static}</code>, <code
                                class="bg-black/40 px-1 rounded text-indigo-300">{recent}</code></p>
                        <textarea id="prompt-world-map-gen-input"
                            class="w-full bg-black/20 border border-gray-600 rounded-lg p-3 text-sm text-gray-300 focus:border-indigo-500 focus:ring-1 focus:ring-indigo-500 resize-y font-mono"
                            rows="6"></textarea>
                    </div>
                </details>

                <!-- Location Gen -->
                <details
                    class="group bg-gray-900/30 border border-gray-700/50 rounded-lg overflow-hidden transition-all duration-200 open:border-indigo-500/30">
                    <summary
                        class="flex items-center justify-between p-4 cursor-pointer hover:bg-white/5 transition-colors list-none">
                        <span class="font-medium text-gray-200">Location Prompt Generation</span>
                        <svg class="w-5 h-5 text-gray-500 group-open:rotate-180 transition-transform duration-200"
                            fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7">
                            </path>
                        </svg>
                    </summary>
                    <div class="p-4 pt-0 border-t border-gray-700/30 mt-2">
                        <p class="text-gray-400 text-sm mb-3">Generates a location's detailed prompt. Variables: <code
                                class="bg-black/40 px-1 rounded text-indigo-300">{name}</code>, <code
                                class="bg-black/40 px-1 rounded text-indigo-300">{description}</code></p>
                        <textarea id="prompt-location-gen-input"
                            class="w-full bg-black/20 border border-gray-600 rounded-lg p-3 text-sm text-gray-300 focus:border-indigo-500 focus:ring-1 focus:ring-indigo-500 resize-y font-mono"
                            rows="4"></textarea>
                    </div>
                </details>

                <!-- Memory Entry Gen -->
                <details
                    class="group bg-gray-900/30 border border-gray-700/50 rounded-lg overflow-hidden transition-all duration-200 open:border-indigo-500/30">
                    <summary
                        class="flex items-center justify-between p-4 cursor-pointer hover:bg-white/5 transition-colors list-none">
                        <span class="font-medium text-gray-200">Memory Entry Generation</span>
                        <svg class="w-5 h-5 text-gray-500 group-open:rotate-180 transition-transform duration-200"
                            fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7">
                            </path>
                        </svg>
                    </summary>
                    <div class="p-4 pt-0 border-t border-gray-700/30 mt-2">
                        <p class="text-gray-400 text-sm mb-3">Used for Static/Dynamic memory entries. Variables: <code
                                class="bg-black/40 px-1 rounded text-indigo-300">{title}</code>, <code
                                class="bg-black/40 px-1 rounded text-indigo-300">{triggers}</code></p>
                        <textarea id="prompt-entry-gen-input"
                            class="w-full bg-black/20 border border-gray-600 rounded-lg p-3 text-sm text-gray-300 focus:border-indigo-500 focus:ring-1 focus:ring-indigo-500 resize-y font-mono"
                            rows="4"></textarea>
                    </div>
                </details>

                <!-- Location Memory Summary -->
                <details
                    class="group bg-gray-900/30 border border-gray-700/50 rounded-lg overflow-hidden transition-all duration-200 open:border-indigo-500/30">
                    <summary
                        class="flex items-center justify-between p-4 cursor-pointer hover:bg-white/5 transition-colors list-none">
                        <span class="font-medium text-gray-200">Location Memory Summary</span>
                        <svg class="w-5 h-5 text-gray-500 group-open:rotate-180 transition-transform duration-200"
                            fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7">
                            </path>
                        </svg>
                    </summary>
                    <div class="p-4 pt-0 border-t border-gray-700/30 mt-2">
                        <p class="text-gray-400 text-sm mb-3">Auto-summarizes events when leaving a location. Variable:
                            <code class="bg-black/40 px-1 rounded text-indigo-300">{transcript}</code>
                        </p>
                        <textarea id="prompt-location-memory-gen-input"
                            class="w-full bg-black/20 border border-gray-600 rounded-lg p-3 text-sm text-gray-300 focus:border-indigo-500 focus:ring-1 focus:ring-indigo-500 resize-y font-mono"
                            rows="4"></textarea>
                    </div>
                </details>
            </div>


        </div>
        <div id="settings-personas-content" class="h-full flex flex-col">
            <div class="flex-grow flex flex-col md:flex-row gap-4 min-h-0 h-[60vh]">
                <div class="w-full md:w-1/3 flex flex-col h-full">
                    <div id="user-personas-list"
                        class="bg-black/30 rounded-t-lg p-2 overflow-y-auto flex-grow border border-gray-700 border-b-0">
                    </div>
                    <div class="flex-shrink-0 bg-black/30 rounded-b-lg p-2 border border-gray-700 border-t-0">
                        <button onclick="AppController.addUserPersona()"
                            class="w-full py-2 bg-gray-700 hover:bg-indigo-600 text-white rounded flex justify-center items-center transition-colors">
                            <span class="font-bold mr-2">New Persona</span>
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M12 6v6m0 0v6m0-6h6m-6 0H6"></path>
                            </svg>
                        </button>
                    </div>
                </div>

                <div id="user-persona-details"
                    class="w-full md:w-2/3 bg-black/30 rounded-lg p-4 overflow-y-auto h-full border border-gray-700">
                    <div class="text-gray-400 flex items-center justify-center h-full">Select a persona to edit.
                    </div>
                </div>
            </div>
        </div>

        <div id="settings-model-content" class="space-y-6">
            <p class="text-sm text-amber-300 bg-amber-900/50 p-3 rounded-lg -mt-2 mb-4"><strong>Note:</strong> These
                model settings are persistent and apply globally to all stories.</p>

            <div>
                <h3 class="text-lg font-medium mb-2">AI Provider</h3>
                <select id="api-provider-selector"
                    class="w-full rounded-lg p-2 bg-gray-700 border border-gray-600 text-white"
                    onchange="AppController.setApiProvider(this.value)">
                    <option value="gemini">Gemini</option>
                    <option value="openrouter">OpenRouter</option>
                    <option value="koboldcpp">KoboldCPP</option>
                    <option value="lmstudio">LM Studio</option>
                </select>
            </div>
            <div id="gemini-settings">
                <div class="flex justify-between items-center mb-2">
                    <h3 class="text-lg font-medium">Gemini API Settings</h3>
                    <a href="https://aistudio.google.com/app/apikey" target="_blank"
                        class="text-xs text-indigo-400 hover:text-indigo-300 flex items-center">
                        Get Key
                        <svg class="w-3 h-3 ml-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14"></path>
                        </svg>
                    </a>
                </div>
                <p class="text-gray-400 text-sm mb-2">Required for text generation.</p>
                <input type="password" id="gemini-api-key-input" class="w-full rounded-lg p-2 mb-3"
                    placeholder="Enter Gemini API key">

                <label class="text-gray-400 text-sm block mb-1">Model</label>
                <select id="gemini-model-selector"
                    class="w-full rounded-lg p-2 bg-gray-700 border border-gray-600 text-white">
                    <option value="gemini-1.5-flash">Gemini 1.5 Flash (Fast/Cheap)</option>
                    <option value="gemini-1.5-flash-8b">Gemini 1.5 Flash-8B (Fastest)</option>
                    <option value="gemini-1.5-pro">Gemini 1.5 Pro (High Intelligence)</option>
                    <option value="gemini-1.0-pro">Gemini 1.0 Pro (Legacy)</option>
                </select>
            </div>
            <div id="openrouter-settings">
                <div class="flex justify-between items-center mb-2">
                    <h3 class="text-lg font-medium">OpenRouter API Settings</h3>
                    <div class="flex space-x-3">
                        <a href="https://openrouter.ai/keys" target="_blank"
                            class="text-xs text-indigo-400 hover:text-indigo-300 flex items-center">
                            Get Key
                            <svg class="w-3 h-3 ml-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14">
                                </path>
                            </svg>
                        </a>
                        <a href="https://openrouter.ai/models" target="_blank"
                            class="text-xs text-indigo-400 hover:text-indigo-300 flex items-center">
                            Browse Models
                            <svg class="w-3 h-3 ml-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14">
                                </path>
                            </svg>
                        </a>
                    </div>
                </div>
                <p class="text-gray-400 text-sm mb-2">Your key and the model name.</p>
                <input type="password" id="openrouter-api-key-input" class="w-full rounded-lg p-2"
                    placeholder="Enter OpenRouter API key">

                <div class="mt-2 flex space-x-2">
                    <input type="text" id="openrouter-model-input" class="flex-grow rounded-lg p-2"
                        placeholder="Enter model name (e.g. anthropic/claude-3-opus)">
                    <button onclick="AppController.openOpenRouterModelBrowser()"
                        class="bg-gray-700 hover:bg-indigo-600 text-white font-bold py-2 px-3 rounded-lg transition-colors"
                        title="Browse models">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
                        </svg>
                    </button>
                    <button onclick="AppController.saveOpenRouterModel()"
                        class="bg-gray-700 hover:bg-indigo-600 text-white font-bold py-2 px-3 rounded-lg transition-colors"
                        title="Save to list">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M12 6v6m0 0v6m0-6h6m-6 0H6"></path>
                        </svg>
                    </button>
                </div>

                <div id="openrouter-saved-models-list" class="mt-3 flex flex-wrap gap-2"></div>
            </div>
            <div id="koboldcpp-settings">
                <div class="flex justify-between items-center mb-2">
                    <h3 class="text-lg font-medium">KoboldCPP Settings</h3>
                    <a href="https://github.com/LostRuins/koboldcpp/releases" target="_blank"
                        class="text-xs text-indigo-400 hover:text-indigo-300 flex items-center">
                        Get Software
                        <svg class="w-3 h-3 ml-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14"></path>
                        </svg>
                    </a>
                </div>
                <p class="text-amber-400 text-sm mb-2 bg-amber-900/50 p-2 rounded-md">Ensure your local server is
                    running.</p>
                <input type="text" id="koboldcpp-url-input" class="w-full rounded-lg p-2 mb-4"
                    placeholder="http://localhost:5001">
                <div>
                    <label for="koboldcpp-template-selector" class="text-gray-400 text-sm block mb-2">Prompt
                        Template</label>
                    <select id="koboldcpp-template-selector" class="w-full rounded-lg p-2">
                        <option value="none">None (Raw Text)</option>
                        <option value="llama3">Llama 3</option>
                        <option value="gemma">Gemma 2 (Google)</option>
                        <option value="phi3">Phi-3 (Microsoft)</option>
                        <option value="mistral">Mistral</option>
                        <option value="chatml">ChatML (Qwen/DeepSeek)</option>
                        <option value="alpaca">Alpaca</option>
                    </select>
                </div>
                <div>
                    <label for="koboldcpp-min-p-slider" class="text-gray-400 text-sm block mt-4 mb-2">Min P</label>
                    <div class="flex items-center space-x-4">
                        <input type="range" id="koboldcpp-min-p-slider" class="w-full" min="0" max="1" step="0.05">
                        <span id="koboldcpp-min-p-value" class="text-sm text-gray-400 w-12 text-right"></span>
                    </div>
                </div>
                <div>
                    <label for="koboldcpp-dry-slider" class="text-gray-400 text-sm block mt-4 mb-2">DRY (Repetition
                        Penalty)</label>
                    <div class="flex items-center space-x-4">
                        <input type="range" id="koboldcpp-dry-slider" class="w-full" min="0" max="1" step="0.05">
                        <span id="koboldcpp-dry-value" class="text-sm text-gray-400 w-12 text-right"></span>
                    </div>
                </div>
            </div>
            <div id="lmstudio-settings">
                <div class="flex justify-between items-center mb-2">
                    <h3 class="text-lg font-medium">LM Studio Settings</h3>
                    <a href="https://lmstudio.ai/download" target="_blank"
                        class="text-xs text-indigo-400 hover:text-indigo-300 flex items-center">
                        Get Software
                        <svg class="w-3 h-3 ml-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14"></path>
                        </svg>
                    </a>
                </div>
                <p class="text-amber-400 text-sm mb-2 bg-amber-900/50 p-2 rounded-md">Ensure LM Studio is running
                    with a
                    model loaded. Default URL is http://localhost:1234</p>
                <div>
                    <label for="lmstudio-url-input" class="text-gray-400 text-sm block mb-2">LM Studio Server
                        URL</label>
                    <input type="text" id="lmstudio-url-input" class="w-full rounded-lg p-2"
                        placeholder="http://localhost:1234">
                </div>
            </div>
        </div>

        <div id="settings-image-gen-content">
            <div class="mb-4">
                <label class="block text-sm font-bold text-gray-400 mb-2">Image Generation Backend</label>
                <select id="image-gen-backend" data-setting-key="imageGenBackend"
                    class="w-full rounded-lg p-3 bg-gray-700 border border-gray-600 text-white focus:border-indigo-500 transition-colors"
                    onchange="AppController.updateImageGenSettingsVisibility()">
                    <option value="disabled">Disabled</option>
                    <option value="koboldcpp">Local (Stable Diffusion / KoboldCPP)</option>
                    <option value="openrouter">Cloud (OpenRouter / DALL-E)</option>
                </select>
            </div>

            <!-- KoboldCPP / Local SD Settings -->
            <div id="image-gen-kobold-settings" class="space-y-4">
                <h4 class="font-bold text-gray-300">KoboldCPP / SDAPI Settings</h4>
                <div>
                    <label class="block text-xs uppercase text-gray-500 font-bold mb-1">API URL</label>
                    <input type="text" id="image-gen-kobold-url" data-setting-key="koboldImageGenUrl"
                        placeholder="http://localhost:5001"
                        class="w-full bg-black/30 border border-gray-600 rounded p-2 text-sm text-white focus:border-indigo-500">
                    <p class="text-xs text-gray-500 mt-1">Must expose <code>/sdapi/v1/txt2img</code>.</p>
                </div>
                <div class="grid grid-cols-2 gap-4">
                    <div>
                        <label class="block text-xs uppercase text-gray-500 font-bold mb-1">Width</label>
                        <input type="number" id="image-gen-width" data-setting-key="imageGenWidth" placeholder="512"
                            class="w-full bg-black/30 border border-gray-600 rounded p-2 text-sm text-white focus:border-indigo-500">
                    </div>
                    <div>
                        <label class="block text-xs uppercase text-gray-500 font-bold mb-1">Height</label>
                        <input type="number" id="image-gen-height" data-setting-key="imageGenHeight" placeholder="512"
                            class="w-full bg-black/30 border border-gray-600 rounded p-2 text-sm text-white focus:border-indigo-500">
                    </div>
                </div>
                <div>
                    <label class="block text-xs uppercase text-gray-500 font-bold mb-1">CFG Scale (Guidance)</label>
                    <input type="number" id="kobold-cfg-scale" data-setting-key="koboldImageGenCfg" placeholder="7"
                        step="0.5"
                        class="w-full bg-black/30 border border-gray-600 rounded p-2 text-sm text-white focus:border-indigo-500">
                </div>
                <div class="grid grid-cols-2 gap-4">
                    <div>
                        <label class="block text-xs uppercase text-gray-500 font-bold mb-1">Sampler</label>
                        <input type="text" id="kobold-sampler" data-setting-key="koboldImageGenSampler"
                            placeholder="Euler"
                            class="w-full bg-black/30 border border-gray-600 rounded p-2 text-sm text-white focus:border-indigo-500">
                    </div>
                    <div>
                        <label class="block text-xs uppercase text-gray-500 font-bold mb-1">Scheduler</label>
                        <input type="text" id="kobold-scheduler" data-setting-key="koboldImageGenScheduler"
                            placeholder="simple"
                            class="w-full bg-black/30 border border-gray-600 rounded p-2 text-sm text-white focus:border-indigo-500">
                    </div>
                </div>
                <div>
                    <label class="block text-xs uppercase text-gray-500 font-bold mb-1">Steps</label>
                    <input type="number" id="kobold-steps" data-setting-key="koboldImageGenSteps" placeholder="20"
                        class="w-full bg-black/30 border border-gray-600 rounded p-2 text-sm text-white focus:border-indigo-500">
                </div>
            </div>

            <!-- OpenRouter Settings -->
            <div id="image-gen-openrouter-settings" class="space-y-4 hidden">
                <div>
                    <label class="block text-sm font-bold text-gray-400 mb-1">OpenRouter API Key</label>
                    <input type="password" id="image-gen-openrouter-key-input"
                        class="w-full rounded-lg p-2 bg-black/20 border border-gray-600 text-white"
                        placeholder="sk-or-...">
                    <p class="text-xs text-gray-500 mt-1">Leave blank to use the main OpenRouter key.</p>
                </div>
                <div>
                    <label class="block text-sm font-bold text-gray-400 mb-1">Model ID</label>
                    <div class="flex space-x-2">
                        <input type="text" id="image-gen-openrouter-model-input"
                            class="flex-grow rounded-lg p-2 bg-black/20 border border-gray-600 text-white"
                            placeholder="openai/dall-e-3">
                        <button onclick="AppController.openOpenRouterImageModelBrowser()"
                            class="bg-gray-700 hover:bg-indigo-600 text-white font-bold py-2 px-3 rounded-lg transition-colors"
                            title="Browse models">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
                            </svg>
                        </button>
                        <button onclick="AppController.saveOpenRouterImageModel()"
                            class="bg-gray-700 hover:bg-indigo-600 text-white font-bold py-2 px-3 rounded-lg transition-colors"
                            title="Save to list">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M12 6v6m0 0v6m0-6h6m-6 0H6"></path>
                            </svg>
                        </button>
                    </div>
                </div>

                <div id="image-gen-openrouter-saved-models-list" class="mt-3 flex flex-wrap gap-2"></div>
            </div>


            <div class="mt-6 p-4 bg-gray-800 rounded-lg flex items-center justify-between">
                <span id="img-gen-status" class="text-gray-400 text-sm">Status: Not Checked</span>
                <button
                    onclick="ImageGenerationService.testConnection().then(ok => document.getElementById('img-gen-status').textContent = ok ? 'Status: Online ' : 'Status: Offline ')"
                    class="bg-indigo-600 hover:bg-indigo-500 text-white text-xs font-bold py-2 px-3 rounded transition-colors">
                    Test Connection
                </button>
            </div>
        </div>

        <!-- NEW: Export Settings Content -->
        <div id="settings-export-content">
            <div class="space-y-6">
                <!-- Current Narrative Export Section -->
                <div class="bg-black/20 p-4 rounded-lg border border-gray-700">
                    <h3 class="text-lg font-medium text-white mb-2">Export Current Narrative</h3>
                    <p class="text-gray-400 text-sm mb-4">Choose a format to save your current story.</p>

                    <div class="mb-4">
                        <label class="block text-sm font-bold text-gray-400 mb-2">Primary Character</label>
                        <select id="export-primary-character-selector"
                            class="w-full rounded-lg p-2 bg-gray-700 border border-gray-600 text-white focus:border-indigo-500">
                            <option value="">Auto-detect (First AI)</option>
                        </select>
                        <p class="text-xs text-gray-500 mt-1">For PNG/BYAF exports. Defaults to first AI character if
                            not selected.</p>
                    </div>

                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">

                        <!-- ZIP Export -->
                        <button onclick="LibraryController.exportStoryAs('zip')"
                            class="group flex items-center justify-center space-x-2 bg-gray-900/40 border border-blue-500/30 hover:border-blue-400 hover:bg-blue-500/10 text-gray-200 hover:text-white font-medium py-3 px-4 rounded-lg transition-all duration-200">
                            <svg class="w-5 h-5 text-blue-500 group-hover:text-blue-400 transition-colors" fill="none"
                                stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z">
                                </path>
                            </svg>
                            <span>ZIP <span class="text-xs opacity-60 ml-1">(Recommended)</span></span>
                        </button>

                        <!-- JSON Export -->
                        <button onclick="LibraryController.exportStoryAs('json')"
                            class="group flex items-center justify-center space-x-2 bg-gray-900/40 border border-indigo-500/30 hover:border-indigo-400 hover:bg-indigo-500/10 text-gray-200 hover:text-white font-medium py-3 px-4 rounded-lg transition-all duration-200">
                            <svg class="w-5 h-5 text-indigo-500 group-hover:text-indigo-400 transition-colors"
                                fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path>
                            </svg>
                            <span>JSON <span class="text-xs opacity-60 ml-1">(Data Only)</span></span>
                        </button>

                        <!-- PNG Export -->
                        <button onclick="LibraryController.exportStoryAs('png')"
                            class="group flex items-center justify-center space-x-2 bg-gray-900/40 border border-pink-500/30 hover:border-pink-400 hover:bg-pink-500/10 text-gray-200 hover:text-white font-medium py-3 px-4 rounded-lg transition-all duration-200">
                            <svg class="w-5 h-5 text-pink-500 group-hover:text-pink-400 transition-colors" fill="none"
                                stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z">
                                </path>
                            </svg>
                            <span>PNG <span class="text-xs opacity-60 ml-1">(Card)</span></span>
                        </button>

                        <!-- BYAF Export -->
                        <button onclick="LibraryController.exportStoryAs('byaf')"
                            class="group flex items-center justify-center space-x-2 bg-gray-900/40 border border-amber-500/30 hover:border-amber-400 hover:bg-amber-500/10 text-gray-200 hover:text-white font-medium py-3 px-4 rounded-lg transition-all duration-200">
                            <svg class="w-5 h-5 text-amber-500 group-hover:text-amber-400 transition-colors" fill="none"
                                stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M5 8h14M5 8a2 2 0 110-4h14a2 2 0 110 4M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8m-9 4h4">
                                </path>
                            </svg>
                            <span>BYAF <span class="text-xs opacity-60 ml-1">(Backyard)</span></span>
                        </button>
                    </div>
                </div>

                <!-- Full Library Export -->
                <div class="bg-black/20 p-4 rounded-lg border border-gray-700">
                    <h3 class="text-lg font-medium text-white mb-2">Create Library Backup</h3>
                    <p class="text-gray-400 text-sm mb-4">Export your entire library including all stories, characters,
                        and
                        settings.</p>
                    <button onclick="LibraryController.exportLibrary()"
                        class="w-full group flex items-center justify-center space-x-2 bg-gray-900/60 hover:bg-emerald-900/20 border border-gray-600 hover:border-emerald-500/50 text-gray-200 hover:text-emerald-100 font-medium py-4 px-6 rounded-lg transition-all duration-200">
                        <svg class="w-6 h-6 text-gray-400 group-hover:text-emerald-400 transition-colors" fill="none"
                            stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M8 7v8a2 2 0 002 2h6M8 7V5a2 2 0 012-2h4.586a1 1 0 01.707.293l4.414 4.414a1 1 0 01.293.707V15a2 2 0 01-2 2h-2M8 7H6a2 2 0 00-2 2v10a2 2 0 002 2h8a2 2 0 002-2v-2">
                            </path>
                        </svg>
                        <span>Export Full Library Backup (ZIP)</span>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <div id="lightbox-modal"
        class="fixed inset-0 z-[100] bg-black/90 hidden items-center justify-center backdrop-blur-sm">
        <button data-action="close-lightbox" aria-label="Close Lightbox"
            class="absolute top-4 right-4 text-white/50 hover:text-white p-2 z-50">
            <svg class="w-10 h-10" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12">
                </path>
            </svg>
        </button>

        <button data-action="lightbox-prev" aria-label="Previous Image"
            class="absolute left-4 top-1/2 -translate-y-1/2 text-white/50 hover:text-white p-4 z-50 bg-black/20 hover:bg-black/50 rounded-full transition-all">
            <svg class="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path>
            </svg>
        </button>

        <img id="lightbox-image" class="max-h-[90vh] max-w-[90vw] object-contain shadow-2xl rounded-lg" src=""
            alt="Character Portrait">

        <button data-action="lightbox-next" aria-label="Next Image"
            class="absolute right-4 top-1/2 -translate-y-1/2 text-white/50 hover:text-white p-4 z-50 bg-black/20 hover:bg-black/50 rounded-full transition-all">
            <svg class="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
            </svg>
        </button>

        <div id="lightbox-caption"
            class="absolute bottom-6 left-0 right-0 text-center text-white/80 font-bold text-xl drop-shadow-md">
        </div>
    </div>
















    <!-- Application Logic -->
    <script>

        /**
         * Application Build Information
         * Update this variable to change the footer in Appearance Settings.
         */
        const APP_BUILD_TIMESTAMP = "Version: 2026.02.02 - 10:00 CST";


        /**
         * HTML Sanitizer
         */
        const DOM = {
            SafeString: class {
                constructor(str) { this.str = str; }
                toString() { return this.str; }
            },
            html(strings, ...values) {
                let result = "";
                strings.forEach((string, i) => {
                    result += string;
                    if (i < values.length) {
                        const val = values[i];
                        if (Array.isArray(val)) {
                            // Recursively join arrays
                            result += val.join('');
                        } else if (val instanceof DOM.SafeString) {
                            result += val;
                        } else if (val !== null && val !== undefined) {
                            // Securely escape unsafe values
                            result += String(val)
                                .replace(/&/g, "&amp;")
                                .replace(/</g, "&lt;")
                                .replace(/>/g, "&gt;")
                                .replace(/"/g, "&quot;")
                                .replace(/'/g, "&#039;");
                        }
                    }
                });
                return new DOM.SafeString(result);
            },
            unsafe(str) {
                return new DOM.SafeString(str);
            }
        };

        /**
         * =================================================================================================
         * BLOCK 1: ActionHandler Module
         * Centralized Event Delegation
         * =================================================================================================
         */
        /**
         * ActionHandler Module
         * Centralized Event Delegation for handling user interactions efficiently.
         * Registers handlers for data-action attributes and manages global event listeners.
         */
        const ActionHandler = {
            actions: {},

            // Register an action name to a function
            /**
             * Registers an action handler.
             * @param {string} name - The action name (data-action value).
             * @param {Function} fn - The callback function.
             */
            register(name, fn) {
                this.actions[name] = fn;
            },

            // Initialize the global listener
            /**
             * Initializes the global click and change listeners.
             */
            init() {
                // We attach one listener to the body to catch ALL bubbled clicks
                document.body.addEventListener('click', (e) => {
                    // 1. Find the closest element with a data-action attribute
                    const target = e.target.closest('[data-action]');
                    if (!target) return;

                    const actionName = target.dataset.action;
                    const handler = this.actions[actionName];

                    if (handler) {
                        // 2. Prevent default browser behavior for links/buttons if handled
                        if (target.tagName === 'A' || target.tagName === 'BUTTON') {
                            e.preventDefault();
                        }

                        // 3. Pass the element's dataset (data-id, data-type, etc.) and the event
                        handler(target.dataset, e);
                    } else {
                        console.warn(`No handler registered for action: ${actionName}`);
                    }
                });

                // Handle 'change' events for inputs using data-action-change
                document.body.addEventListener('change', (e) => {
                    const target = e.target.closest('[data-action-change]');
                    if (!target) return;

                    const actionName = target.dataset.actionChange;
                    const handler = this.actions[actionName];
                    if (handler) handler(target.dataset, target.value, e);
                });
            }
        };

        // Utility function to prevent a function from being called too frequently.
        const debounce = (func, wait) => { let timeout; return function (...args) { const context = this; clearTimeout(timeout); timeout = setTimeout(() => func.apply(context, args), wait); }; };

        /**
         * DBService (resilient, fail-soft, self-initializing)
         */
        /**
         * DBService
         * A resilient, fail-soft wrapper for IndexedDB to handle persistent storage.
         * Includes self-initialization, error handling for restricted environments, and transaction management.
         */
        const DBService = {
            db: null,
            DB_NAME: "EllipsisDB",
            OPEN_TIMEOUT_MS: 3000,

            /**
             * Opens the IndexedDB connection.
             * @param {number} [version=1] - The schema version.
             * @returns {Promise<boolean>} - True if successful, false otherwise.
             * @private
             */
            _open(version = 1) {
                return new Promise((resolve) => {
                    try {
                        if (this.db) return resolve(true);
                        if (!("indexedDB" in window)) {
                            console.warn("IndexedDB not supported in this environment.");
                            return resolve(false);
                        }

                        const request = indexedDB.open(this.DB_NAME, version);

                        const timeout = setTimeout(() => {
                            console.warn("IDB open timed out (likely blocked). Failing soft.");
                            resolve(false);
                        }, this.OPEN_TIMEOUT_MS);

                        request.onerror = (event) => {
                            clearTimeout(timeout);
                            console.warn("IndexedDB open error (fail-soft):", event?.target?.error);
                            resolve(false);
                        };

                        request.onblocked = () => {
                            clearTimeout(timeout);
                            console.warn("IndexedDB upgrade blocked. Continuing without cache.");
                            resolve(false);
                        };

                        request.onupgradeneeded = (event) => {
                            try {
                                const db = event.target.result;
                                if (!db.objectStoreNames.contains("characterImages")) {
                                    db.createObjectStore("characterImages");
                                }
                                if (!db.objectStoreNames.contains("stories")) {
                                    db.createObjectStore("stories", { keyPath: "id" });
                                }
                                if (!db.objectStoreNames.contains("narratives")) {
                                    db.createObjectStore("narratives", { keyPath: "id" });
                                }
                            } catch (e) {
                                console.warn("onupgradeneeded failed (fail-soft):", e);
                            }
                        };

                        request.onsuccess = (event) => {
                            clearTimeout(timeout);
                            try {
                                this.db = event.target.result;
                                this.db.onversionchange = () => {
                                    try { this.db.close(); } catch { }
                                    this.db = null;
                                };
                                resolve(true);
                            } catch (e) {
                                resolve(false);
                            }
                        };
                    } catch (err) {
                        resolve(false);
                    }
                });
            },

            _saveQueue: Promise.resolve(),

            /**
             * Performs a write operation to the database using a queue to prevent concurrency issues.
             * @param {string} storeName - The name of the object store.
             * @param {Object} data - The data to write.
             * @returns {Promise<boolean>} - True if successful, false otherwise.
             * @private
             */
            async _performWrite(storeName, data) {
                // Chain the write operation to the queue
                this._saveQueue = this._saveQueue.then(async () => {
                    if (!(await this.ensure())) throw new Error("Database closed.");

                    return new Promise((resolve, reject) => {
                        const tx = this.db.transaction([storeName], "readwrite");
                        const store = tx.objectStore(storeName);
                        const req = store.put(data); // Overwrite logic

                        tx.oncomplete = () => resolve(true);

                        tx.onerror = (e) => {
                            console.error(`DB Write Error (${storeName}):`, e.target.error);
                            reject(e.target.error);
                        };

                        req.onerror = (e) => {
                            // Specific check for Quota Exceeded
                            if (e.target.error.name === 'QuotaExceededError') {
                                alert("CRITICAL: Storage Quota Exceeded. Your recent chat cannot be saved. Please delete old stories or images.");
                            }
                            reject(e.target.error);
                        };
                    });
                }).catch(err => {
                    console.error("Critical Save Failure:", err);
                    // OPTIONAL: Update UI to show "Save Failed" icon
                    const saveIndicator = document.getElementById('save-status-indicator');
                    if (saveIndicator) { saveIndicator.textContent = " Save Failed"; saveIndicator.style.color = "red"; }
                    return false;
                });

                return this._saveQueue;
            },

            /**
             * Initializes the database connection.
             * @returns {Promise<void>}
             */
            async init() {
                if (this.db) return;
                await this._open(2);
            },

            /**
             * Ensures the database is initialized and open.
             * @returns {Promise<boolean>} - True if the database is ready.
             */
            async ensure() {
                if (this.db) return true;
                await this.init();
                return !!this.db;
            },

            /**
             * Iterates over all items in a store and applies a callback.
             * @param {string} storeName - The name of the object store.
             * @param {Function} callback - The function to call for each item (key, value).
             * @returns {Promise<{success: boolean, processedCount: number, errors: Array<{key: string, error: string}>}>}
             */
            async iterateStore(storeName, callback) {
                if (!(await this.ensure())) return { success: false, processedCount: 0, errors: [] };
                return new Promise((resolve, reject) => {
                    try {
                        const tx = this.db.transaction([storeName], "readonly");
                        const store = tx.objectStore(storeName);
                        const req = store.openCursor();

                        let processedCount = 0;
                        const errors = [];

                        req.onsuccess = async (event) => {
                            const cursor = event.target.result;
                            if (cursor) {
                                try {
                                    await callback(cursor.key, cursor.value);
                                    processedCount++;
                                    cursor.continue();
                                } catch (err) {
                                    console.error(`Error processing item ${cursor.key} in ${storeName}:`, err);
                                    errors.push({ key: cursor.key, error: err.message });
                                    cursor.continue(); // Continue even if one item fails
                                }
                            } else {
                                resolve({ success: true, processedCount, errors });
                            }
                        };
                        req.onerror = () => resolve({ success: false, processedCount, errors, globalError: req.error });
                    } catch (e) { resolve({ success: false, processedCount: 0, errors: [], globalError: e }); }
                });
            },

            /**
             * Saves an image blob to the database.
             * @param {string} id - The unique ID for the image.
             * @param {Blob} blob - The image data.
             * @returns {Promise<boolean>} - True if saved successfully.
             */
            async saveImage(id, blob) {
                if (!(await this.ensure())) return false;
                return new Promise((resolve) => {
                    try {
                        const tx = this.db.transaction(["characterImages"], "readwrite");
                        const store = tx.objectStore("characterImages");
                        tx.onabort = () => resolve(false);
                        tx.onerror = (e) => {
                            console.error("DBService.saveImage Transaction Error:", e.target.error);
                            resolve(false);
                        };
                        const req = store.put(blob, id);
                        req.onsuccess = () => resolve(true);
                        req.onerror = (e) => {
                            console.error("DBService.saveImage Request Error:", e.target.error);
                            resolve(false);
                        };
                    } catch (e) {
                        console.error("DBService.saveImage Exception:", e);
                        resolve(false);
                    }
                });
            },

            async getAllKeys(storeName) {
                if (!(await this.ensure())) return [];
                return new Promise((resolve) => {
                    try {
                        const tx = this.db.transaction([storeName], "readonly");
                        const store = tx.objectStore(storeName);
                        const req = store.getAllKeys();
                        req.onsuccess = () => resolve(req.result || []);
                        req.onerror = () => resolve([]);
                    } catch (e) { resolve([]); }
                });
            },

            /**
             * Retrieves an image blob from the database.
             * @param {string} id - The ID of the image.
             * @returns {Promise<Blob|null>} - The image blob or null if not found.
             */
            async getImage(id) {
                if (!(await this.ensure())) return null;
                return new Promise((resolve) => {
                    try {
                        const tx = this.db.transaction(["characterImages"], "readonly");
                        const store = tx.objectStore("characterImages");
                        tx.onabort = () => resolve(null);
                        tx.onerror = () => resolve(null);
                        const req = store.get(id);
                        req.onsuccess = () => resolve(req.result ?? null);
                        req.onerror = () => resolve(null);
                    } catch (e) { resolve(null); }
                });
            },

            /**
             * Deletes an image from the database.
             * @param {string} id - The ID of the image to delete.
             * @returns {Promise<boolean>} - True if deleted successfully.
             */
            async deleteImage(id) {
                if (!(await this.ensure())) return false;
                return new Promise((resolve) => {
                    try {
                        const tx = this.db.transaction(["characterImages"], "readwrite");
                        const store = tx.objectStore("characterImages");
                        tx.onabort = () => resolve(false);
                        tx.onerror = () => resolve(false);
                        const req = store.delete(id);
                        req.onsuccess = () => resolve(true);
                        req.onerror = () => resolve(false);
                    } catch (e) { resolve(false); }
                });
            },

            /**
             * Clears all images from the database.
             * @returns {Promise<boolean>} - True if cleared successfully.
             */
            async clear() {
                if (!(await this.ensure())) return false;
                return new Promise((resolve) => {
                    try {
                        const tx = this.db.transaction(["characterImages"], "readwrite");
                        const store = tx.objectStore("characterImages");
                        const req = store.clear();
                        req.onsuccess = () => resolve(true);
                    } catch (e) { resolve(false); }
                });
            },

            /**
             * Saves a story object to the database.
             * @param {Object} story - The story object.
             * @returns {Promise<boolean>} - True if saved successfully.
             */
            async saveStory(story) {
                return this._performWrite("stories", story);
            },

            /**
             * Retrieves a story by its ID.
             * @param {string} storyId - The ID of the story.
             * @returns {Promise<Object|null>} - The story object or null.
             */
            async getStory(storyId) {
                if (!(await this.ensure())) return null;
                return new Promise((resolve) => {
                    try {
                        const tx = this.db.transaction(["stories"], "readonly");
                        const store = tx.objectStore("stories");
                        const req = store.get(storyId);
                        req.onsuccess = () => resolve(req.result ?? null);
                        req.onerror = () => resolve(null);
                    } catch (e) { resolve(null); }
                });
            },

            /**
             * Retrieves all stories from the database.
             * @returns {Promise<Array<Object>>} - An array of story objects.
             */
            async getAllStories() {
                if (!(await this.ensure())) return [];
                return new Promise((resolve) => {
                    try {
                        const tx = this.db.transaction(["stories"], "readonly");
                        const store = tx.objectStore("stories");
                        const req = store.getAll();
                        req.onsuccess = () => resolve(req.result ?? []);
                        req.onerror = () => resolve([]);
                    } catch (e) { resolve([]); }
                });
            },

            /**
             * Deletes a story by its ID.
             * @param {string} storyId - The ID of the story to delete.
             * @returns {Promise<boolean>} - True if deleted successfully.
             */
            async deleteStory(storyId) {
                if (!(await this.ensure())) return false;
                return new Promise((resolve) => {
                    try {
                        const tx = this.db.transaction(["stories"], "readwrite");
                        const store = tx.objectStore("stories");
                        const req = store.delete(storyId);
                        req.onsuccess = () => resolve(true);
                        req.onerror = () => resolve(false);
                    } catch (e) { resolve(false); }
                });
            },

            /**
             * Saves a narrative object to the database.
             * @param {Object} narrative - The narrative object.
             * @returns {Promise<boolean>} - True if saved successfully.
             */
            async saveNarrative(narrative) {
                return this._performWrite("narratives", narrative);
            },

            /**
             * Retrieves a narrative by its ID.
             * @param {string} narrativeId - The ID of the narrative.
             * @returns {Promise<Object|null>} - The narrative object or null.
             */
            async getNarrative(narrativeId) {
                if (!(await this.ensure())) return null;
                return new Promise((resolve) => {
                    try {
                        const tx = this.db.transaction(["narratives"], "readonly");
                        const store = tx.objectStore("narratives");
                        const req = store.get(narrativeId);
                        req.onsuccess = () => resolve(req.result ?? null);
                        req.onerror = () => resolve(null);
                    } catch (e) { resolve(null); }
                });
            },

            /**
             * Retrieves all narratives from the database.
             * @returns {Promise<Array<Object>>} - An array of narrative objects.
             */
            async getAllNarratives() {
                if (!(await this.ensure())) return [];
                return new Promise((resolve) => {
                    try {
                        const tx = this.db.transaction(["narratives"], "readonly");
                        const store = tx.objectStore("narratives");
                        const req = store.getAll();
                        req.onsuccess = () => resolve(req.result ?? []);
                        req.onerror = () => resolve([]);
                    } catch (e) { resolve([]); }
                });
            },

            /**
             * Deletes a narrative by its ID.
             * @param {string} narrativeId - The ID of the narrative to delete.
             * @returns {Promise<boolean>} - True if deleted successfully.
             */
            async deleteNarrative(narrativeId) {
                if (!(await this.ensure())) return false;
                return new Promise((resolve) => {
                    try {
                        const tx = this.db.transaction(["narratives"], "readwrite");
                        const store = tx.objectStore("narratives");
                        const req = store.delete(narrativeId);
                        req.onsuccess = () => resolve(true);
                        req.onerror = () => resolve(false);
                    } catch (e) { resolve(false); }
                });
            },

            /**
             * Retrieves all entries from a specific store as key-value pairs.
             * @param {string} storeName - The name of the store.
             * @returns {Promise<Array<Array>>} - An array of [key, value] pairs.
             */
            async getAllEntries(storeName) {
                if (!(await this.ensure())) return [];
                return new Promise((resolve) => {
                    try {
                        const tx = this.db.transaction([storeName], "readonly");
                        const store = tx.objectStore(storeName);
                        const entries = [];
                        const req = store.openCursor();
                        req.onsuccess = (event) => {
                            const cursor = event.target.result;
                            if (cursor) {
                                entries.push([cursor.key, cursor.value]);
                                cursor.continue();
                            } else {
                                resolve(entries);
                            }
                        };
                        req.onerror = () => resolve([]);
                    } catch (e) { resolve([]); }
                });
            },

            /**
             * Clears all data from a specific store.
             * @param {string} storeName - The name of the store to clear.
             * @returns {Promise<boolean>} - True if cleared successfully.
             */
            async clearStore(storeName) {
                if (!(await this.ensure())) return false;
                return new Promise((resolve) => {
                    try {
                        const tx = this.db.transaction([storeName], "readwrite");
                        const store = tx.objectStore(storeName);
                        const req = store.clear();
                        req.onsuccess = () => resolve(true);
                        req.onerror = () => resolve(false);
                    } catch (e) { resolve(false); }
                });
            }
        };

        /**
         * =================================================================================================
         * ImageGenerationService Module
         * Handles interactions with Text-to-Image APIs (KoboldCPP / OpenRouter).
         * =================================================================================================
         */
        const ImageGenerationService = {

            /**
             * Generates an image based on the provided prompt and settings.
             * @param {string} prompt - The positive prompt.
             * @param {string} negativePrompt - The negative prompt.
             * @param {Object} options - Override options (width, height, etc.).
             * @returns {Promise<Blob>} - The generated image as a Blob.
             */
            async generateImage(prompt, negativePrompt = "", options = {}) {
                const globalSettings = StateManager.data.globalSettings;
                const backend = globalSettings.imageGenBackend || 'koboldcpp'; // 'koboldcpp' or 'openrouter'

                if (backend === 'disabled') {
                    console.log("Image generation is disabled.");
                    return null;
                }

                if (backend === 'koboldcpp') {
                    return this._generateKoboldCPP(prompt, negativePrompt, options);
                } else if (backend === 'openrouter') {
                    return this._generateOpenRouter(prompt, options);
                } else {
                    throw new Error(`Unknown image generation backend: ${backend}`);
                }
            },

            /**
             * Tests the connection to the configured backend.
             * @returns {Promise<boolean>}
             */
            async testConnection() {
                const globalSettings = StateManager.data.globalSettings;
                const backend = globalSettings.imageGenBackend || 'koboldcpp';

                try {
                    if (backend === 'koboldcpp') {
                        const url = (globalSettings.koboldImageGenUrl || "http://localhost:5001").replace(/\/$/, "");
                        const res = await fetch(`${url}/sdapi/v1/options`, { method: 'GET' }); // Check SDAPI options
                        return res.ok;
                    } else if (backend === 'openrouter') {
                        // No easy lightweight check for OR image gen specifically, so we assume valid if we can hit models
                        const key = globalSettings.imageGenOpenRouterKey;
                        if (!key) return false;
                        const res = await fetch("https://openrouter.ai/api/v1/models", {
                            headers: { "Authorization": `Bearer ${key}` }
                        });
                        return res.ok;
                    }
                } catch (e) {
                    console.error("ImageGen Connection Test Failed:", e);
                    return false;
                }
                return false;
            },

            // --- Internal Adapters ---

            /**
             * KoboldCPP (SDAPI Compatible) Adapter
             */
            async _generateKoboldCPP(prompt, negativePrompt, options) {
                const globalSettings = StateManager.data.globalSettings;
                const url = (globalSettings.koboldImageGenUrl || "http://localhost:5001").replace(/\/$/, "");

                const width = options.width || globalSettings.imageGenWidth || 512;
                const height = options.height || globalSettings.imageGenHeight || 512;
                const steps = parseInt(globalSettings.koboldImageGenSteps || 20);

                const payload = {
                    prompt: prompt,
                    negative_prompt: negativePrompt || "",
                    width: width,
                    height: height,
                    steps: steps,
                    cfg_scale: parseFloat(globalSettings.koboldImageGenCfg || 7),
                    sampler_name: globalSettings.koboldImageGenSampler || "Euler",
                    scheduler: globalSettings.koboldImageGenScheduler || "simple",
                    send_images: true,
                    save_images: false,
                };

                try {
                    const response = await fetch(`${url}/sdapi/v1/txt2img`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        const errText = await response.text();
                        throw new Error(`KoboldCPP Error (${response.status}): ${errText}`);
                    }

                    const data = await response.json();
                    if (data.images && data.images.length > 0) {
                        // Kobold/SDAPI returns base64 string
                        return UTILITY.base64ToBlob(data.images[0], 'image/png');
                    } else {
                        throw new Error("KoboldCPP returned no images.");
                    }
                } catch (e) {
                    console.error("KoboldCPP Image Gen Failed:", e);
                    throw e;
                }
            },

            /**
             * OpenRouter (OpenAI Compatible) Adapter
             */
            async _generateOpenRouter(prompt, options) {
                const globalSettings = StateManager.data.globalSettings;
                const key = globalSettings.imageGenOpenRouterKey;

                if (!key) throw new Error("OpenRouter API Key is missing.");

                // Default to Flux 1 Schnell as it is widely supported and fast on OpenRouter
                const model = globalSettings.imageGenOpenRouterModel || "black-forest-labs/flux-1-schnell";

                // OpenRouter uses the Chat Completions endpoint for Image Generation models
                // We send a user message with the prompt.
                // We add a System Prompt to force the model to behave like a generator and not a chatbot.
                const payload = {
                    model: model,
                    messages: [
                        {
                            role: "system",
                            content: "You are an image generation tool. Generate the image requested by the user and output ONLY the image URL. Do not add any conversational text, pleasantries, or explanations. Just the URL."
                        },
                        { role: "user", content: prompt }
                    ],
                    // NEW: Required by OpenRouter for image models
                    extra_body: {
                        modalities: ["image", "text"]
                    }
                };

                console.log("OpenRouter Image Req:", payload);

                try {
                    const response = await fetch("https://openrouter.ai/api/v1/chat/completions", {
                        method: 'POST',
                        headers: {
                            "Authorization": `Bearer ${key}`,
                            "Content-Type": "application/json",
                            "HTTP-Referer": window.location.href,
                            "X-Title": "Ellipsis LM"
                        },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        const errText = await response.text();
                        throw new Error(`OpenRouter Error (${response.status}): ${errText}`);
                    }

                    const data = await response.json();
                    console.log("OpenRouter Image Res:", data);

                    if (data.choices && data.choices.length > 0) {
                        const message = data.choices[0].message;

                        // 0. Priority Check: OpenRouter/OpenAI 'images' array (Standard for GenAI)
                        if (message.images && message.images.length > 0) {
                            const imgData = message.images[0];
                            const url = (imgData.image_url && imgData.image_url.url) ? imgData.image_url.url : imgData.url;
                            if (url) {
                                console.log("OpenRouter: Found structured image URL/DataURI");
                                return await (await fetch(url)).blob();
                            }
                        }

                        const content = message.content || "";

                        // 1. Check for Markdown Image Syntax: ![alt](url)
                        const mdMatch = content.match(/!\[.*?\]\((.*?)\)/);
                        if (mdMatch) {
                            return await (await fetch(mdMatch[1])).blob();
                        }

                        // 2. Check for raw URL
                        // Improvement: Robust Regex to capture http/https URLs, excluding trailing punctuation/brackets
                        const urlRegex = /https?:\/\/[^\s<>)\]}]+/;
                        const urlMatch = content.match(urlRegex);

                        if (urlMatch) {
                            let url = urlMatch[0];
                            // Clean trailing punctuation if regex was too greedy (e.g. terminating dot or comma)
                            url = url.replace(/[.,;!?]$/, '');

                            console.log("OpenRouter: Extracting URL:", url);

                            try {
                                const imgRes = await fetch(url);
                                const blob = await imgRes.blob();
                                if (blob.type.startsWith('image/')) return blob;
                            } catch (e) {
                                console.warn("Failed to fetch extracted URL:", url);
                            }
                        }

                        // 3. Check for Base64 Data URL or Raw Base64
                        const trimmedContent = content.trim();
                        if (trimmedContent.startsWith('data:image')) {
                            return await (await fetch(trimmedContent)).blob();
                        }

                        // 4. Check for Raw Base64 (common in some Flux/SD integrations via OR)
                        // A simple heuristic: long string, no spaces, likely base64 chars
                        if (trimmedContent.length > 100 && !trimmedContent.includes(' ') && /^[A-Za-z0-9+/=]+$/.test(trimmedContent)) {
                            console.log("OpenRouter: Detected Raw Base64");
                            return await (await fetch(`data:image/png;base64,${trimmedContent}`)).blob();
                        }

                        // 5. Special Case: Some APIs return `b64_json` in the message content (incorrectly) or as a separate field we missed
                        if (data.choices[0].message.b64_json) {
                            return await (await fetch(`data:image/png;base64,${data.choices[0].message.b64_json}`)).blob();
                        }

                        // Debug: Log the full content to help the user identify why it failed
                        console.warn("OpenRouter Content (No Image Found):", content);
                        throw new Error(`OpenRouter response content did not contain a recognizable image. Content start: "${content.substring(0, 100)}..." (See Console for full output)`);
                    }

                    throw new Error("OpenRouter response was empty (no choices).");

                } catch (e) {
                    console.error("OpenRouter Image Gen Failed:", e);
                    throw e;
                }
            },
        };


        /**
         * StoryService Module (Data Abstraction Layer)
         */
        /**
         * StoryService Module
         * Data Abstraction Layer for managing Stories, Narratives, and their persistence.
         * Handles complex operations like saving state, importing/exporting, and context building.
         */
        const StoryService = {
            /**
             * Loads the initial application data (stories, active story/narrative).
             * @returns {Promise<{storyStubs: Array, activeStory: Object|null, activeNarrative: Object|null}>}
             */
            async loadApplicationData() {
                const storyStubs = await DBService.getAllStories();

                // Robust local storage retrieval
                let activeStoryId = localStorage.getItem('active_story_id');
                let activeNarrativeId = localStorage.getItem('active_narrative_id');

                // Clean "null" strings
                if (activeStoryId === 'null') activeStoryId = null;
                if (activeNarrativeId === 'null') activeNarrativeId = null;

                let activeStory = null;
                let activeNarrative = null;

                if (activeStoryId && activeNarrativeId) {
                    try {
                        const [story, narrative] = await Promise.all([
                            DBService.getStory(activeStoryId),
                            DBService.getNarrative(activeNarrativeId)
                        ]);

                        if (story && narrative) {
                            activeStory = story;
                            activeNarrative = narrative;
                        } else {
                            // Silent Fail-Safe: Data is missing, clear IDs but don't error out
                            console.warn("StoryService: Session data not found in DB. Resetting.");
                            localStorage.removeItem('active_story_id');
                            localStorage.removeItem('active_narrative_id');
                        }
                    } catch (e) {
                        console.error("StoryService: DB Load Error", e);
                        localStorage.removeItem('active_story_id');
                        localStorage.removeItem('active_narrative_id');
                    }
                }
                return { storyStubs, activeStory, activeNarrative };
            },

            /**
             * Exports the current narrative's chat history as an HTML file.
             * @param {Object} narrative - The narrative object to export.
             * @param {Object} activeStory - The active story object, needed for character details.
             * @returns {Promise<void>}
             */
            async exportNarrativeHTML() {
                console.log("Export initiated...");
                const state = StateManager.getState();
                if (!state || !state.chat_history || state.chat_history.length === 0) {
                    alert('Error: No chat history to export.');
                    return;
                }

                // 1. Capture Current Style Settings
                const defaults = UTILITY.getDefaultUiSettings();
                const s = state; // shorthand

                const font = s.font || defaults.font;
                const textSize = s.textSize || defaults.textSize;
                const bubbleOpacity = s.bubbleOpacity !== undefined ? s.bubbleOpacity : 1.0;

                // Markdown Colors
                const mdH1 = s.md_h1_color || defaults.md_h1_color;
                const mdH2 = s.md_h2_color || defaults.md_h2_color;
                const mdH3 = s.md_h3_color || defaults.md_h3_color;
                const mdBold = s.md_bold_color || defaults.md_bold_color;
                const mdItalic = s.md_italic_color || defaults.md_italic_color;
                const mdQuote = s.md_quote_color || defaults.md_quote_color;

                // Support function for opacity
                const hexToRgba = (hex, alpha) => {
                    if (!hex) return hex;
                    // Handle shorthand hex
                    if (/^#([A-Fa-f0-9]{3}){1,2}$/.test(hex)) {
                        let c = hex.substring(1).split('');
                        if (c.length === 3) {
                            c = [c[0], c[0], c[1], c[1], c[2], c[2]];
                        }
                        c = '0x' + c.join('');
                        return 'rgba(' + [(c >> 16) & 255, (c >> 8) & 255, c & 255].join(',') + ',' + alpha + ')';
                    }
                    return hex;
                };

                // Generate static HTML for chat history
                let chatHTML = '';
                state.chat_history.forEach(msg => {
                    const charId = msg.character_id;
                    const char = (state.characters || []).find(c => c.id === charId);
                    const isUser = (char && char.is_user) || msg.character_id === 'user';
                    const name = char ? char.name : (isUser ? (StateManager.data.globalSettings.userPersona?.name || 'You') : 'Unknown');

                    // Character Colors
                    const defaultColor = isUser ? { base: '#4b5563', bold: '#e5e7eb' } : { base: '#334155', bold: '#94a3b8' };
                    const charColor = (char && char.color) ? char.color : defaultColor;
                    const nameColor = charColor.bold;

                    // Bubble Colors: Respect stored characteristic and opacity
                    const bubbleBg = hexToRgba(charColor.base, bubbleOpacity);

                    // Apply Smart Quotes
                    const smartContent = (msg.content || '').replace(/(["][^"]*["])/g, '<span class="dialogue-quote">$1</span>');

                    chatHTML += `
            <div class="message ${isUser ? 'user-message' : 'ai-message'}" style="background-color: ${bubbleBg};">
                <div class="message-header" style="color: ${nameColor};">${name}</div>
                <div class="message-content">${marked.parse(smartContent)}</div>
            </div>
        `;
                });

                if (!state.name) {
                    console.warn("Export: Narrative name missing, using default.");
                }
                const title = state.name || "Narrative Export";
                const fullHTML = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>${title}</title>
    <style>
        :root {
            --font-primary: ${font};
            --text-size: ${textSize}px;
            --md-h1-color: ${mdH1};
            --md-h2-color: ${mdH2};
            --md-h3-color: ${mdH3};
            --md-bold-color: ${mdBold};
            --md-italic-color: ${mdItalic};
            --md-quote-color: ${mdQuote};
            --chat-text-color: ${s.chatTextColor || '#e5e7eb'};
        }

        body {
            background-color: #0f172a;
            font-family: var(--font-primary);
            font-size: var(--text-size);
            padding: 2rem;
            max-width: 900px;
            margin: 0 auto;
            color: #cbd5e1;
        }

        h1.title {
            color: white;
            border-bottom: 1px solid #334155;
            padding-bottom: 1rem;
            margin-bottom: 2rem;
        }

        /* Smart Quotation Styling */
        .dialogue-quote {
            color: inherit;
            filter: saturate(175%) opacity(75%) drop-shadow(1px 1px 5px black);
            font-weight: 500;
        }

        .message {
            margin-bottom: 1rem;
            padding: 1rem;
            border-radius: 0.5rem;
            color: var(--chat-text-color);
        }

        .message-header {
            font-weight: bold;
            margin-bottom: 0.5rem;
            font-size: 0.9em;
        }

        /* Markdown Styling - Mirroring App Logic */
        .message-content {
            white-space: pre-wrap;
            line-height: 1.5;
        }

        .message-content h1 { color: var(--md-h1-color); font-size: 1.5em; font-weight: 700; margin: 0.5em 0; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 0.3em; }
        .message-content h2 { color: var(--md-h2-color); font-size: 1.3em; font-weight: 600; margin: 0.4em 0; }
        .message-content h3 { color: var(--md-h3-color); font-size: 1.1em; font-weight: 600; margin: 0.3em 0; }
        .message-content strong { color: var(--md-bold-color); font-weight: 700; }
        .message-content em { color: var(--md-italic-color); font-style: italic; }

        .message-content blockquote {
            border-left: 3px solid #6366f1;
            padding-left: 1rem;
            color: var(--md-quote-color);
            font-style: italic;
            margin: 0.5em 0;
            background: rgba(0,0,0,0.2);
            padding: 0.5rem 1rem;
            border-radius: 0.25rem;
        }

        .message-content code {
            background-color: rgba(0,0,0,0.3);
            padding: 0.1em 0.3em;
            border-radius: 0.2rem;
            font-family: monospace;
            font-size: 0.9em;
            color: #e2e8f0;
        }

        .message-content pre {
            background-color: #1e1e1e;
            padding: 1rem;
            border-radius: 0.5rem;
            overflow-x: auto;
            margin: 0.5em 0;
        }

        .message-content pre code {
            background-color: transparent;
            padding: 0;
            color: #d4d4d4;
        }

        .message-content ul, .message-content ol { margin-left: 1.5rem; margin-bottom: 0.5rem; }
        .message-content p { margin-bottom: 0.5rem; }
    </style>
</head>
<body>
    <h1 class="title">${title}</h1>
    <div id="chat-container">
        ${chatHTML}
    </div>
</body>
</html>`;

                try {
                    const blob = new Blob([fullHTML], { type: 'text/html' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${title.replace(/[^a-z0-9]/gi, '_').toLowerCase()}_export.html`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    alert('Export started.');
                } catch (e) {
                    console.error("Export failed:", e);
                    alert("Export failed: " + e.message);
                }
            },



            /**
             * Saves the current active state (narrative and story) to the database.
             * @param {Object} currentState - The current state object.
             * @param {Array} narrativeStubs - The list of narrative stubs.
             * @returns {Promise<void>}
             */
            async saveActiveState(currentState, narrativeStubs) {
                if (!currentState || !currentState.id || !currentState.narrativeId) return;

                // 1. Prepare Data
                // Clone objects to break references (Sanitization)
                const rawCharacters = JSON.parse(JSON.stringify(currentState.characters || []));
                const safeChatHistory = JSON.parse(JSON.stringify(currentState.chat_history || []));
                const safeStaticEntries = JSON.parse(JSON.stringify(currentState.static_entries || []));
                const safeWorldMap = JSON.parse(JSON.stringify(currentState.worldMap || {}));
                const safeDynamicEntries = JSON.parse(JSON.stringify(currentState.dynamic_entries || []));

                // Image Sanitization
                const sanitizedCharacters = rawCharacters.map(c => {
                    let safeImage = c.image_url;
                    if (safeImage && safeImage.length > 500 && !safeImage.startsWith('http') && !safeImage.startsWith('local_')) {
                        safeImage = '';
                    }
                    c.image_url = safeImage;
                    return c;
                });

                const narrativeData = {
                    id: currentState.narrativeId,
                    name: currentState.narrativeName,
                    last_modified: new Date().toISOString(),
                    active_character_ids: sanitizedCharacters.filter(c => c.is_active).map(c => c.id),
                    state: {
                        chat_history: safeChatHistory,
                        messageCounter: currentState.messageCounter,
                        static_entries: safeStaticEntries,
                        worldMap: safeWorldMap
                    }
                };

                // 2. Perform Transactional Story Update
                const storyId = currentState.id;
                const currentNarrativeId = currentState.narrativeId;

                try {
                    // A. Save Narrative
                    await DBService.saveNarrative(narrativeData);

                    // B. Sync Story
                    const freshStory = await DBService.getStory(storyId);

                    if (freshStory) {
                        freshStory.last_modified = new Date().toISOString();


                        // Sync Structures
                        freshStory.characters = sanitizedCharacters;
                        freshStory.dynamic_entries = safeDynamicEntries;
                        freshStory.static_entries = safeStaticEntries; // Sync Knowledge

                        if (currentState.tags) freshStory.tags = currentState.tags;
                        if (currentState.creator_notes) freshStory.creator_notes = currentState.creator_notes;

                        // Sync all relevant settings keys to ensure the story stub matches the active state.
                        const settingsKeys = [
                            // Appearance
                            'font', 'backgroundImageURL', 'bubbleOpacity', 'chatTextColor',
                            'backgroundBlur', 'textSize', 'bubbleImageSize', 'characterImageMode',

                            // Markdown Colors
                            'md_h1_color', 'md_h2_color', 'md_h3_color',
                            'md_bold_color', 'md_italic_color', 'md_quote_color',

                            // Markdown Fonts
                            'md_h1_font', 'md_h2_font', 'md_h3_font',
                            'md_bold_font', 'md_italic_font', 'md_quote_font',

                            // Core Prompts
                            'system_prompt', 'responseLength',

                            // Event Master
                            'event_master_base_prompt', 'event_master_prompt', 'event_master_probability',
                            'visual_master_probability', // Visual Master Probability

                            // Generation Prompts
                            'prompt_persona_gen', 'prompt_world_map_gen', 'prompt_location_gen',
                            'prompt_entry_gen', 'prompt_location_memory_gen', 'prompt_story_notes_gen', 'prompt_story_tags_gen'
                        ];

                        settingsKeys.forEach(key => {
                            // Only overwrite if the current state actually has a value (even if it's an empty string)
                            if (currentState[key] !== undefined) {
                                freshStory[key] = currentState[key];
                            }
                        });

                        // C. Update Stub
                        if (!freshStory.narratives) freshStory.narratives = [];
                        const stubIndex = freshStory.narratives.findIndex(n => n.id === currentNarrativeId);
                        if (stubIndex !== -1) {
                            freshStory.narratives[stubIndex].name = currentState.narrativeName;
                            freshStory.narratives[stubIndex].last_modified = narrativeData.last_modified;
                        } else {
                            freshStory.narratives.push({
                                id: narrativeData.id,
                                name: narrativeData.name,
                                last_modified: narrativeData.last_modified
                            });
                        }

                        // D. Commit
                        await DBService.saveStory(freshStory);
                        console.log("Story saved successfully with settings.");
                    }
                } catch (err) {
                    console.error("StoryService: Save Transaction Failed", err);
                }
            },

            /**
             * Creates a default story and narrative for a fresh start.
             * @returns {Promise<{newStory: Object, newNarrative: Object}>}
             */
            async createDefaultStoryAndNarrative() {
                const newStory = {
                    id: UTILITY.uuid(), name: "My First Story", last_modified: new Date().toISOString(), created_date: new Date().toISOString(),
                    ...UTILITY.getDefaultApiSettings(), ...UTILITY.getDefaultUiSettings(), ...UTILITY.getDefaultSystemPrompts(), ...UTILITY.getDefaultStorySettings(),
                    characters: [
                        { id: UTILITY.uuid(), name: "You", description: "The protagonist.", short_description: "The main character.", model_instructions: "Write a response for {character} in a creative and descriptive style.", is_user: true, is_active: true, image_url: '', extra_portraits: [], tags: [], is_narrator: false },
                        { id: UTILITY.uuid(), name: "Narrator", description: "Describes the world.", short_description: "The storyteller.", model_instructions: "Act as a world-class storyteller.", is_user: false, is_active: true, image_url: '', extra_portraits: [], tags: [], color: { base: '#334155', bold: '#94a3b8' }, is_narrator: true }
                    ],
                    dynamic_entries: [{ id: UTILITY.uuid(), title: "Example Lorebook Entry", triggers: "example, .01%", content_fields: ["This is a sample dynamic lore entry."], current_index: 0, triggered_at_turn: null }],
                    scenarios: [{ id: UTILITY.uuid(), name: "Default Start", message: "The story begins..." }],
                    narratives: []
                };

                const defaultScenario = newStory.scenarios[0];
                const newNarrative = {
                    id: UTILITY.uuid(), name: `${defaultScenario.name} - Chat`, last_modified: new Date().toISOString(),
                    state: {
                        chat_history: [], messageCounter: 0,
                        static_entries: [{ id: UTILITY.uuid(), title: "World Overview", content: "A high-fantasy world." }],
                        worldMap: { grid: UTILITY.createDefaultMapGrid(), currentLocation: { x: 4, y: 4 }, destination: { x: null, y: null }, path: [] }
                    }
                };

                const firstSpeaker = newStory.characters.find(c => !c.is_user);
                newNarrative.state.chat_history.push({
                    character_id: firstSpeaker.id, content: defaultScenario.message, type: 'chat', emotion: 'neutral', timestamp: new Date().toISOString(),
                });
                newNarrative.state.messageCounter = 1;

                newStory.narratives.push({ id: newNarrative.id, name: newNarrative.name });

                await DBService.saveStory(newStory);
                await DBService.saveNarrative(newNarrative);

                return { newStory, newNarrative };
            },

            /**
             * Creates a new empty story.
             * @returns {Promise<Object>} - The new story object.
             */
            async createNewStory() {
                const newStory = {
                    id: UTILITY.uuid(), name: "New Story", last_modified: new Date().toISOString(), created_date: new Date().toISOString(),
                    ...UTILITY.getDefaultApiSettings(), ...UTILITY.getDefaultUiSettings(), ...UTILITY.getDefaultSystemPrompts(), ...UTILITY.getDefaultStorySettings(),
                    search_index: "new story",
                    characters: [
                        { id: UTILITY.uuid(), name: "You", description: "The protagonist.", short_description: "The main character.", model_instructions: "Write a response for {character} in a creative and descriptive style.", is_user: true, is_active: true, image_url: '', extra_portraits: [], tags: [], is_narrator: false },
                        { id: UTILITY.uuid(), name: "Narrator", description: "Describes the world.", short_description: "The storyteller.", model_instructions: "Act as a world-class storyteller.", is_user: false, is_active: true, image_url: '', extra_portraits: [], tags: [], color: { base: '#334155', bold: '#94a3b8' }, is_narrator: true }
                    ],
                    dynamic_entries: [{ id: UTILITY.uuid(), title: "Example Lorebook Entry", triggers: "example, 100%", content_fields: ["This is a sample dynamic lore entry."], current_index: 0, triggered_at_turn: null }],
                    scenarios: [{ id: UTILITY.uuid(), name: "Default Start", message: "The story begins..." }],
                    narratives: []
                };

                await DBService.saveStory(newStory);
                return newStory;
            },

            /**
             * Deletes a story and all its associated data (narratives, images).
             * @param {string} storyId - The ID of the story to delete.
             * @returns {Promise<void>}
             */
            async deleteStory(storyId) {
                const story = await DBService.getStory(storyId);
                if (!story) return;

                const deleteNarrativePromises = (story.narratives || []).map(n_stub =>
                    DBService.deleteNarrative(n_stub.id)
                );

                const deleteImagePromises = (story.characters || []).map(c => {
                    const baseDelete = DBService.deleteImage(c.id);
                    const emotionDeletes = (c.extra_portraits || []).map(p => {
                        const emoKey = `${c.id}::emotion::${p.emotion}`;
                        return DBService.deleteImage(emoKey);
                    });
                    return Promise.all([baseDelete, ...emotionDeletes]);
                });

                await Promise.all([...deleteNarrativePromises, ...deleteImagePromises]);
                await DBService.deleteStory(storyId);
            },

            /**
             * Deletes a specific narrative from a story.
             * @param {string} storyId - The ID of the parent story.
             * @param {string} narrativeId - The ID of the narrative to delete.
             * @returns {Promise<Object>} - The updated story object.
             */
            async deleteNarrative(storyId, narrativeId) {
                const story = await DBService.getStory(storyId);
                if (!story) throw new Error("Parent story not found.");

                await DBService.deleteNarrative(narrativeId);
                story.narratives = story.narratives.filter(n => n.id !== narrativeId);
                await DBService.saveStory(story);
                return story;
            },

            /**
             * Creates a new narrative based on a scenario.
             * @param {string} storyId - The ID of the story.
             * @param {string} scenarioId - The ID of the scenario.
             * @returns {Promise<Object>} - The new narrative object.
             */
            async createNarrativeFromScenario(storyId, scenarioId) {
                const story = await DBService.getStory(storyId);
                if (!story) throw new Error("Story not found");

                const scenario = story.scenarios.find(sc => sc.id === scenarioId);
                if (!scenario) throw new Error("Scenario not found");

                if (scenario.dynamic_entries) story.dynamic_entries = JSON.parse(JSON.stringify(scenario.dynamic_entries));
                if (scenario.prompts) Object.assign(story, scenario.prompts);

                const activeIDs = scenario.active_character_ids || story.characters.map(c => c.id);

                const newNarrative = {
                    id: UTILITY.uuid(),
                    name: `${scenario.name} - Chat`,
                    last_modified: new Date().toISOString(),
                    active_character_ids: activeIDs,
                    state: {
                        chat_history: [],
                        messageCounter: 0,
                        static_entries: scenario.static_entries ? JSON.parse(JSON.stringify(scenario.static_entries)) : [{ id: UTILITY.uuid(), title: "World Overview", content: "A high-fantasy world." }],
                        worldMap: scenario.worldMap ? JSON.parse(JSON.stringify(scenario.worldMap)) : { grid: UTILITY.createDefaultMapGrid(), currentLocation: { x: 4, y: 4 }, destination: { x: null, y: null }, path: [] }
                    }
                };

                if (scenario.example_dialogue && Array.isArray(scenario.example_dialogue)) {
                    newNarrative.state.chat_history.push(...JSON.parse(JSON.stringify(scenario.example_dialogue)));
                }

                const firstMessage = scenario.message;
                if (firstMessage) {
                    const firstSpeaker = story.characters.find(c => !c.is_user && c.is_active);
                    if (firstSpeaker) {
                        newNarrative.state.chat_history.push({
                            character_id: firstSpeaker.id, content: firstMessage, type: 'chat',
                            emotion: 'neutral', timestamp: new Date().toISOString(), isNew: true
                        });
                        newNarrative.state.messageCounter = 1;
                    }
                }

                // 1. Save the Narrative
                await DBService.saveNarrative(newNarrative);

                // 2. Update the Story with the new Narrative Stub
                // Explicitly include last_modified to ensure DB consistency
                story.narratives.push({
                    id: newNarrative.id,
                    name: newNarrative.name,
                    last_modified: newNarrative.last_modified
                });

                // 3. Save the Story
                await DBService.saveStory(story);

                return newNarrative;
            },

            /**
             * Updates a specific field of a story.
             * @param {string} storyId - The ID of the story.
             * @param {string} field - The field name to update.
             * @param {*} value - The new value.
             * @returns {Promise<Object>} - The updated story object.
             */
            async updateStoryField(storyId, field, value) {
                const story = await DBService.getStory(storyId);
                if (!story) throw new Error("Story not found.");

                story[field] = value;
                story.last_modified = new Date().toISOString();
                await DBService.saveStory(story);
                return story;
            },

            /**
             * Exports the entire library as a ZIP file.
             * @returns {Promise<Blob>} - The ZIP file blob.
             */
            async exportLibraryAsZip() {
                console.log("StoryService: Starting library export...");

                // 1. Force a save of the current state before exporting
                if (typeof ReactiveStore !== 'undefined') {
                    await ReactiveStore.forceSave();
                }

                const zip = new JSZip();
                const dataFolder = zip.folder("data");
                const imageFolder = zip.folder("images");

                // 2. Export Stories
                const stories = await DBService.getAllStories();
                dataFolder.file("stories.json", JSON.stringify(stories, null, 2));

                // 3. Export Narratives
                const narratives = await DBService.getAllNarratives();
                dataFolder.file("narratives.json", JSON.stringify(narratives, null, 2));

                // 4. Export Images Iteratively (Memory Safe)
                // Capture the report from iterateStore
                const report = await DBService.iterateStore("characterImages", (key, blob) => {
                    if (blob) {
                        imageFolder.file(key, blob);
                    } else {
                        throw new Error("Blob was null in DB");
                    }
                });

                const blob = await zip.generateAsync({
                    type: "blob",
                    compression: "DEFLATE",
                    compressionOptions: { level: 6 }
                });

                return { blob, report };
            },

            /**
             * Imports a library from a ZIP file, replacing existing data.
             * @param {File} file - The ZIP file to import.
             * @returns {Promise<void>}
             */
            async importLibraryFromZip(file) {
                console.log("StoryService: Starting library import...");
                const zip = await JSZip.loadAsync(file);

                // 0. Pre-Flight Validation (Memory-Safe)
                let stories = [];
                let narratives = [];

                const storiesFile = zip.file("data/stories.json");
                if (storiesFile) {
                    try {
                        const str = await storiesFile.async("string");
                        stories = JSON.parse(str);
                    } catch (e) { throw new Error("Invalid 'stories.json' in backup file."); }
                }

                const narrativesFile = zip.file("data/narratives.json");
                if (narrativesFile) {
                    try {
                        const str = await narrativesFile.async("string");
                        narratives = JSON.parse(str);
                    } catch (e) { throw new Error("Invalid 'narratives.json' in backup file."); }
                }

                // 1. Clear existing data (Only after validation passes)
                await Promise.all([
                    DBService.clearStore("stories"),
                    DBService.clearStore("narratives"),
                    DBService.clearStore("characterImages")
                ]);

                // 2. Import Stories
                for (const story of stories) {
                    const success = await DBService.saveStory(story);
                    if (!success) throw new Error(`Failed to save story "${story.name || 'Unknown'}". Storage may be full.`);
                }

                // 3. Import Narratives
                for (const narrative of narratives) {
                    const success = await DBService.saveNarrative(narrative);
                    if (!success) throw new Error(`Failed to save narrative "${narrative.name || 'Unknown'}". Storage may be full.`);
                }

                // 4. Import Images
                const imageFolder = zip.folder("images");
                if (imageFolder) {
                    const imageFiles = [];
                    imageFolder.forEach((relativePath, file) => {
                        imageFiles.push({ key: relativePath, file: file });
                    });

                    // Process images sequentially
                    for (const img of imageFiles) {
                        const blob = await img.file.async("blob");
                        const success = await DBService.saveImage(img.key, blob);
                        if (!success) throw new Error(`Failed to save image "${img.key}". Storage Quota Exceeded?`);
                    }
                }
            },

            /**
             * Builds a context string for a story, including characters and lore.
             * @param {string} storyId - The ID of the story.
             * @returns {Promise<string>} - The context string.
             */
            async buildStoryContext(storyId) {
                const story = await DBService.getStory(storyId);
                if (!story) return "No story found.";

                let context = `Story Name: ${story.name}\n`;
                context += `Creator's Note: ${story.creator_notes || 'N/A'}\n`;
                context += "Characters:\n";
                (story.characters || []).forEach(c => {
                    context += `- ${c.name}: ${c.short_description}\n`;
                });

                if (story.narratives && story.narratives.length > 0) {
                    const firstNarrative = await DBService.getNarrative(story.narratives[0].id);
                    if (firstNarrative && firstNarrative.state) {
                        context += "\nWorld Lore (Sample):\n";
                        (firstNarrative.state.static_entries || []).slice(0, 5).forEach(e => {
                            context += `- ${e.title}: ${e.content.substring(0, 100)}...\n`;
                        });
                    }
                }

                if (story.dynamic_entries && story.dynamic_entries.length > 0) {
                    context += "\nDynamic Lore (Sample):\n";
                    story.dynamic_entries.slice(0, 5).forEach(e => {
                        context += `- ${e.title} (Triggers: ${e.triggers})\n`;
                    });
                }
                return context;
            },
        };

        /**
         * StateManager Module
         */
        /**
         * StateManager Module
         * Centralizes application state management, including the library, global settings, and active narrative.
         * Handles persistence to localStorage and synchronization with DBService.
         */
        const StateManager = {
            data: {
                library: { active_story_id: null, active_narrative_id: null, stories: [], tag_cache: [] },
                globalSettings: {},
                activeNarrativeState: {},
            },

            CONSTANTS: {
                GLOBAL_SETTINGS_KEY: 'aiStorytellerGlobalSettings',
                ACTIVE_STORY_ID_KEY: 'active_story_id',
                ACTIVE_NARRATIVE_ID_KEY: 'active_narrative_id',
            },

            /**
             * Loads global settings from localStorage.
             */
            loadGlobalSettings() {
                let parsedSettings = {};
                const defaults = UTILITY.getDefaultApiSettings();
                try {
                    const savedSettingsJSON = localStorage.getItem(this.CONSTANTS.GLOBAL_SETTINGS_KEY);
                    if (savedSettingsJSON) parsedSettings = JSON.parse(savedSettingsJSON);
                } catch (error) { parsedSettings = {}; }
                this.data.globalSettings = { ...defaults, ...parsedSettings };
                // Cleanup legacy keys that are now story-specific
                delete this.data.globalSettings.responseLength;
            },

            /**
             * Saves global settings to localStorage.
             */
            saveGlobalSettings() {
                localStorage.setItem(this.CONSTANTS.GLOBAL_SETTINGS_KEY, JSON.stringify(this.data.globalSettings));
            },

            /**
             * Returns the active narrative state.
             * @returns {Object}
             */
            getState() { return this.data.activeNarrativeState; },
            /**
             * Returns the library data.
             * @returns {Object}
             */
            getLibrary() { return this.data.library; },

            /**
             * Loads the library and hydrates the active narrative state.
             * @returns {Promise<void>}
             */
            async loadLibrary() {
                this.loadGlobalSettings();
                try {
                    const { storyStubs, activeStory, activeNarrative } = await StoryService.loadApplicationData();
                    this.data.library.stories = storyStubs || [];
                    this.data.library.active_story_id = activeStory ? activeStory.id : null;
                    this.data.library.active_narrative_id = activeNarrative ? activeNarrative.id : null;

                    if (activeStory && activeNarrative) {
                        const idList = activeNarrative.active_character_ids;
                        const activeIDs = (idList === null || idList === undefined)
                            ? new Set((activeStory.characters || []).map(c => c.id))
                            : new Set(idList);

                        const hydratedCharacters = (activeStory.characters || []).map(char => ({
                            ...char,
                            is_active: char.is_user || activeIDs.has(char.id)
                        }));
                        this.data.activeNarrativeState = {
                            ...activeStory,
                            ...this.data.globalSettings,
                            ...activeNarrative.state,
                            characters: hydratedCharacters,
                            narrativeId: activeNarrative.id,
                            narrativeName: activeNarrative.name
                        };

                        if (!this.data.activeNarrativeState.worldMap || !this.data.activeNarrativeState.worldMap.grid || this.data.activeNarrativeState.worldMap.grid.length === 0) {
                            this.data.activeNarrativeState.worldMap = {
                                grid: UTILITY.createDefaultMapGrid(),
                                currentLocation: { x: 4, y: 4 },
                                destination: { x: null, y: null },
                                path: []
                            };
                        }
                    } else {
                        this.data.activeNarrativeState = {};
                    }
                } catch (error) {
                    this.data.library = { stories: [], tag_cache: [] };
                    this.data.activeNarrativeState = {};
                }
                this.updateTagCache();
            },

            /**
             * Persists the current active story and narrative IDs to localStorage.
             */
            saveLibrary() {
                try {
                    // Persistence: Only save if we have valid IDs, otherwise remove the keys to prevent stale state
                    if (this.data.library.active_story_id) {
                        localStorage.setItem(this.CONSTANTS.ACTIVE_STORY_ID_KEY, this.data.library.active_story_id);
                    } else {
                        localStorage.removeItem(this.CONSTANTS.ACTIVE_STORY_ID_KEY);
                    }

                    if (this.data.library.active_narrative_id) {
                        localStorage.setItem(this.CONSTANTS.ACTIVE_NARRATIVE_ID_KEY, this.data.library.active_narrative_id);
                    } else {
                        localStorage.removeItem(this.CONSTANTS.ACTIVE_NARRATIVE_ID_KEY);
                    }
                } catch (e) {
                    console.warn("LocalStorage save failed:", e);
                }
            },

            /**
             * Updates localStorage with the currently active story and narrative IDs.
             */
            loadActiveNarrative() {
                const { active_story_id, active_narrative_id } = this.data.library;
                if (!active_story_id || !active_narrative_id) {
                    this.data.activeNarrativeState = {};
                    return;
                }
                localStorage.setItem(this.CONSTANTS.ACTIVE_STORY_ID_KEY, active_story_id);
                localStorage.setItem(this.CONSTANTS.ACTIVE_NARRATIVE_ID_KEY, active_narrative_id);
            },

            /**
             * Saves the full application state to the database.
             * @returns {Promise<void>}
             */
            async saveState() {
                // Destructure active_narrative_id to identify the correct stub to update.
                const { active_story_id, active_narrative_id, stories } = this.data.library;
                const currentState = this.data.activeNarrativeState;

                if (!active_story_id || !currentState) return;

                try {
                    const storyInLibrary = stories.find(s => s.id === active_story_id);
                    const storyStubs = (storyInLibrary || {}).narratives || [];

                    // Find the specific narrative stub and update its timestamp.
                    if (active_narrative_id) {
                        const currentStub = storyStubs.find(n => n.id === active_narrative_id);
                        if (currentStub) {
                            currentStub.last_modified = new Date().toISOString();
                        }
                    }

                    // Now save the story (with the updated narrative list) and the narrative itself
                    await StoryService.saveActiveState(currentState, storyStubs);

                    if (storyInLibrary) {
                        storyInLibrary.last_modified = new Date().toISOString();
                    }
                } catch (e) { console.error("Failed to save state:", e); }
            },

            /**
             * Updates the cache of all unique tags used in the library.
             */
            updateTagCache() {
                const allTags = new Set();
                this.data.library.stories.forEach(story => {
                    if (story.tags) story.tags.forEach(tag => allTags.add(tag.toLowerCase()));
                    if (story.characters) {
                        story.characters.forEach(char => {
                            if (char.tags) char.tags.forEach(tag => allTags.add(tag.toLowerCase()));
                        });
                    }
                });
                this.data.library.tag_cache = Array.from(allTags).sort();
            },
        };

        /**
         * APIService Module
         */
        /**
         * APIService Module
         * Handles interactions with various AI providers (Gemini, OpenRouter, KoboldCPP, LM Studio).
         * Manages API keys, request formatting, and error handling.
         */
        const APIService = {
            async callAI(prompt, isJson = false, signal = null) {
                const state = StateManager.getState();
                let text = "";
                try {
                    if (state.apiProvider === 'gemini') {
                        text = await this.callGemini(prompt, signal);
                    } else if (state.apiProvider === 'openrouter') {
                        text = await this.callOpenRouter(prompt, signal);
                    } else if (state.apiProvider === 'koboldcpp') {
                        text = await this.callKoboldCPP(prompt, signal);
                    } else if (state.apiProvider === 'lmstudio') {
                        text = await this.callLMStudio(prompt, signal);
                    }

                    if (isJson) {
                        const jsonMatch = text.match(/\{[\s\S]*\}/);
                        if (jsonMatch && jsonMatch[0]) return jsonMatch[0];
                        throw new Error("AI response was not in the expected JSON format.");
                    }
                    return text.trim();
                } catch (error) {
                    if (error.name === 'AbortError') throw error;
                    console.error(`AI call failed (${state.apiProvider}):`, error);
                    throw error;
                }
            },

            /**
             * Fetches available models from the Gemini API.
             */
            async getGeminiModels() {
                // Check Global Settings first, then State
                const globalKey = StateManager.data.globalSettings.geminiApiKey;
                const stateKey = StateManager.getState().geminiApiKey;
                const apiKey = globalKey || stateKey;

                if (!apiKey) {
                    console.warn("getGeminiModels: No API key found.");
                    return [];
                }

                try {
                    const res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models?key=${apiKey}`);
                    if (!res.ok) {
                        console.error("Gemini List Models Failed:", res.status, res.statusText);
                        return [];
                    }
                    const data = await res.json();

                    // Filter for models that support generating content
                    return (data.models || []).filter(m =>
                        m.supportedGenerationMethods &&
                        m.supportedGenerationMethods.includes('generateContent')
                    );
                } catch (e) {
                    console.error("Failed to fetch Gemini models:", e);
                    return [];
                }
            },

            /**
             * Calls the Gemini API.
             * @param {string} prompt - The prompt.
             * @param {AbortSignal} signal - AbortSignal.
             * @returns {Promise<string>}
             */
            async callGemini(prompt, signal) {
                const state = StateManager.getState();
                const global = StateManager.data.globalSettings;
                const apiKey = global.geminiApiKey || state.geminiApiKey;

                if (!apiKey) throw new Error("Gemini API key not set.");

                // 1. Resolve Model Name
                // State might hold "gemini-1.5-flash" OR "models/gemini-1.5-flash".
                // Global setting might hold the fallback.
                let rawModel = state.geminiModel || global.geminiModel || 'gemini-1.5-flash';

                // Strip "models/" prefix if present to ensure clean base ID
                if (rawModel.startsWith('models/')) {
                    rawModel = rawModel.replace('models/', '');
                }

                // 2. Construct Endpoint
                // The correct format is: models/{model_id}:generateContent
                const url = `https://generativelanguage.googleapis.com/v1beta/models/${rawModel}:generateContent?key=${apiKey}`;

                const res = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] }),
                    signal
                });

                if (!res.ok) {
                    let errorMsg = `Status ${res.status}`;
                    try {
                        const errData = await res.json();
                        errorMsg += `: ${errData.error.message}`;
                    } catch (e) {
                        errorMsg += `: ${await res.text()}`;
                    }
                    throw new Error(`Gemini API Error: ${errorMsg}`);
                }

                const data = await res.json();
                return data.candidates?.[0]?.content?.parts?.[0]?.text || "";
            },

            /**
             * Calls the OpenRouter API.
             * @param {string} prompt - The prompt.
             * @param {AbortSignal} signal - AbortSignal.
             * @returns {Promise<string>}
             */
            async callOpenRouter(prompt, signal) {
                const state = StateManager.getState();
                const global = StateManager.data.globalSettings;
                const apiKey = global.openRouterKey || state.openRouterKey;
                const model = state.openRouterModel || global.openRouterModel;
                if (!apiKey || !model) throw new Error("OpenRouter API key or model not set.");
                const res = await fetch('https://openrouter.ai/api/v1/chat/completions', { method: 'POST', headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` }, body: JSON.stringify({ model: model, messages: [{ role: 'user', content: prompt }] }), signal });
                if (!res.ok) { let errorDetails = `Status: ${res.status} ${res.statusText}.`; try { const errorJson = await res.json(); errorDetails += ` Message: ${errorJson.error.message || JSON.stringify(errorJson.error)}`; } catch (e) { errorDetails += ` Response body: ${await res.text()}`; } throw new Error(`API Error: ${errorDetails}`); }
                const data = await res.json();
                return data.choices[0].message.content;
            },
            /**
             * Fetches available models from OpenRouter API.
             * @returns {Promise<Array>} Array of model objects with id, name, pricing, context_length, etc.
             */
            async fetchOpenRouterModels() {
                const state = StateManager.getState();
                const global = StateManager.data.globalSettings;
                const apiKey = global.openRouterKey || state.openRouterKey;
                const headers = { 'Content-Type': 'application/json' };
                if (apiKey) {
                    headers['Authorization'] = `Bearer ${apiKey}`;
                }
                const res = await fetch('https://openrouter.ai/api/v1/models', { method: 'GET', headers });
                if (!res.ok) {
                    let errorDetails = `Status: ${res.status} ${res.statusText}.`;
                    try {
                        const errorJson = await res.json();
                        errorDetails += ` Message: ${errorJson.error?.message || JSON.stringify(errorJson.error)}`;
                    } catch (e) {
                        errorDetails += ` Response body: ${await res.text()}`;
                    }
                    throw new Error(`Failed to fetch OpenRouter models: ${errorDetails}`);
                }
                const data = await res.json();
                return data.data || [];
            },
            /**
             * Calls the KoboldCPP API.
             * @param {string} prompt - The prompt.
             * @param {AbortSignal} signal - AbortSignal.
             * @returns {Promise<string>}
             */
            async callKoboldCPP(prompt, signal) {
                const state = StateManager.getState();

                const payload = {
                    prompt: prompt,
                    use_story: false, use_memory: false, use_authors_note: false, use_world_info: false,
                    max_context_length: 16384,
                    max_length: 512, // Updated to 512 as per your snippet
                    quiet: true,

                    // Sampling Settings
                    temperature: 1.0,
                    min_p: state.koboldcpp_min_p,
                    top_p: 1.0, // Disabled when using Min-P/DRY for pure results, or keep 0.92 if preferred
                    top_k: 0,
                    tfs: 1,
                    typical: 1,

                    // Disable Legacy Repetition Penalty (Conflict avoidance)
                    rep_pen: 1.0,
                    rep_pen_range: 2048,
                    rep_pen_slope: 0.7,

                    // Disable Mirostat to prevent interference with other samplers.
                    mirostat: 0,
                    mirostat_tau: 4,
                    mirostat_eta: 0.1,

                    // Configure DRY (Don't Repeat Yourself) sampler.
                    dry_multiplier: state.koboldcpp_dry,
                    dry_base: 1.75,
                    dry_allowed_length: 2,
                    dry_penalty_last_n: -1, // Scan entire context

                    sampler_order: [6, 0, 1, 2, 3, 4, 5]
                };

                const res = await fetch(`${state.koboldcpp_url}/api/v1/generate`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload),
                    signal
                });

                if (!res.ok) {
                    let errorDetails = `Status: ${res.status} ${res.statusText}.`;
                    try { errorDetails += ` Message: ${(await res.json()).error.message}`; } catch (e) { errorDetails += ` Response body: ${await res.text()}`; }
                    throw new Error(`KoboldCPP API Error: ${errorDetails}`);
                }

                const data = await res.json();
                return data.results[0].text.trim();
            },

            /**
             * Streams a response from KoboldCPP using polling.
             * @param {string} prompt - The prompt.
             * @param {Function} onChunk - Callback for each text chunk.
             * @param {AbortSignal} signal - AbortSignal.
             */
            async streamKoboldPolled(prompt, onChunk, signal) {
                const state = StateManager.getState();

                // Identical Payload to callKoboldCPP to ensure consistency
                const payload = {
                    prompt: prompt,
                    use_story: false, use_memory: false, use_authors_note: false, use_world_info: false,
                    max_context_length: 16384,
                    max_length: 512, // Updated to 512 as per your snippet
                    quiet: true,

                    // Sampling Settings
                    temperature: 1.0,
                    min_p: state.koboldcpp_min_p,
                    top_p: 1.0, // Disabled when using Min-P/DRY for pure results, or keep 0.92 if preferred
                    top_k: 0,
                    tfs: 1,
                    typical: 1,

                    // Disable Legacy Repetition Penalty (Conflict avoidance)
                    rep_pen: 1.0,
                    rep_pen_range: 2048,
                    rep_pen_slope: 0.7,

                    // Disable Mirostat.
                    mirostat: 0,
                    mirostat_tau: 4,
                    mirostat_eta: 0.1,

                    // Configure DRY sampler.
                    dry_multiplier: state.koboldcpp_dry,
                    dry_base: 1.75,
                    dry_allowed_length: 2,
                    dry_penalty_last_n: -1, // Scan entire context

                    sampler_order: [6, 0, 1, 2, 3, 4, 5]
                };

                // 1. Start Generation
                await fetch(`${state.koboldcpp_url}/api/v1/generate`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload),
                    signal
                });

                let finished = false;

                // 2. Poll for Tokens
                while (!finished) {
                    if (signal.aborted) break;

                    try {
                        const check = await fetch(`${state.koboldcpp_url}/api/extra/generate/check`, { signal });
                        const data = await check.json();

                        if (data.results && data.results[0]) {
                            onChunk(data.results[0].text);
                        }

                        if (data.done) finished = true;
                    } catch (e) {
                        if (e.name !== 'AbortError') console.warn("Polling error:", e);
                        // Don't break loop on transient network error, wait and retry
                    }

                    if (!finished) await new Promise(r => setTimeout(r, 100));
                }
            },

            /**
             * Calls the LM Studio API.
             * @param {string} prompt - The prompt.
             * @param {AbortSignal} signal - AbortSignal.
             * @returns {Promise<string>}
             */
            async callLMStudio(prompt, signal) {
                const state = StateManager.getState();
                if (!state.lmstudio_url) throw new Error("LM Studio URL not set.");
                const endpoint = `${state.lmstudio_url}/v1/chat/completions`;
                const res = await fetch(endpoint, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        messages: [{ role: 'user', content: prompt }],
                        temperature: 0.7,
                        stream: false
                    }),
                    signal
                });

                if (!res.ok) {
                    let errorDetails = `Status: ${res.status} ${res.statusText}.`;
                    try {
                        const errorJson = await res.json();
                        errorDetails += ` Message: ${errorJson.error?.message || JSON.stringify(errorJson)}`;
                    } catch (e) {
                        errorDetails += ` Response body: ${await res.text()}`;
                    }
                    throw new Error(`LM Studio API Error: ${errorDetails}`);
                }
                const data = await res.json();
                return data.choices[0].message.content;
            },
        };

        /**
         * ModalManager Module
         */
        /**
         * ModalManager Module
         * Controls the visibility and lifecycle of UI modals.
         * Handles opening, closing, and cleanup (e.g., clearing intervals).
         */
        const ModalManager = {
            RUNTIME: { carousel_interval: null },
            /**
             * Opens a modal by ID.
             * @param {string} modalId - The ID of the modal element.
             */
            open(modalId) {
                const modal = document.getElementById(modalId);
                if (modal) modal.style.display = 'flex';
            },
            /**
             * Closes a modal by ID and cleans up any intervals.
             * @param {string} modalId - The ID of the modal element.
             */
            close(modalId) {
                if (this.RUNTIME.carousel_interval) {
                    clearInterval(this.RUNTIME.carousel_interval);
                    this.RUNTIME.carousel_interval = null;
                }
                const modal = document.getElementById(modalId);
                if (modal) modal.style.display = 'none';
            }
        };


        /**
         * UTILITY Module
         * Provides general-purpose helper functions for the application.
         * Includes UUID generation, HTML escaping, color manipulation, and default settings.
         */
        const UTILITY = {
            /**
             * Converts a base64 string to a Blob.
             * @param {string} base64 - The base64 string.
             * @param {string} mimeType - The mime type (e.g., 'image/png').
             * @returns {Blob}
             */
            base64ToBlob(base64, mimeType = 'image/png') {
                const byteCharacters = atob(base64);
                const byteNumbers = new Array(byteCharacters.length);
                for (let i = 0; i < byteCharacters.length; i++) {
                    byteNumbers[i] = byteCharacters.charCodeAt(i);
                }
                const byteArray = new Uint8Array(byteNumbers);
                return new Blob([byteArray], { type: mimeType });
            },
            /**
             * Generates a UUID v4.
             * @returns {string}
             */
            uuid() {
                return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c => (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16));
            },
            /**
             * Escapes HTML characters to prevent XSS.
             * @param {string} str - The string to escape.
             * @returns {string}
             */
            escapeHTML(str) {
                if (typeof str !== 'string') return '';
                const p = document.createElement("p");
                p.textContent = str;
                return p.innerHTML;
            },

            /**
             * Safely extracts and parses JSON from a string, handling markdown code blocks.
             * @param {string} str - The string containing JSON.
             * @returns {Object|null} - The parsed object or null.
             */
            extractAndParseJSON(str) {
                if (!str) return null;
                // Remove markdown
                let clean = str.replace(/```json\s*/g, '').replace(/```/g, '').trim();
                try {
                    return JSON.parse(clean);
                } catch (e) {
                    // Regex fallback
                    const match = str.match(/\{[\s\S]*\}/);
                    if (match) {
                        try { return JSON.parse(match[0]); } catch (e2) { return null; }
                    }
                    return null;
                }
            },

            /**
             * Converts a hex color to RGBA.
             * @param {string} hex - The hex color string.
             * @param {number} alpha - The alpha value (0-1).
             * @returns {string}
             */
            hexToRgba(hex, alpha) {
                let r = 0, g = 0, b = 0;
                if (hex.length == 4) { r = "0x" + hex[1] + hex[1]; g = "0x" + hex[2] + hex[2]; b = "0x" + hex[3] + hex[3]; }
                else if (hex.length == 7) { r = "0x" + hex[1] + hex[2]; g = "0x" + hex[3] + hex[4]; b = "0x" + hex[5] + hex[6]; }
                return `rgba(${+r},${+g},${+b},${alpha})`;
            },
            /**
             * Darkens a hex color by a percentage.
             * @param {string} hex - The hex color string.
             * @param {number} percent - The percentage to darken (0-100).
             * @returns {string}
             */
            darkenHex(hex, percent) {
                const num = parseInt(hex.replace("#", ""), 16);
                const amt = Math.round(2.55 * percent);
                const R = (num >> 16) - amt;
                const G = (num >> 8 & 0x00FF) - amt;
                const B = (num & 0x0000FF) - amt;
                return "#" + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 + (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 + (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);
            },
            /**
             * Returns default API settings.
             * @returns {Object}
             */
            getDefaultApiSettings() {
                return {
                    apiProvider: 'gemini',
                    geminiApiKey: '',
                    geminiModel: 'gemini-1.5-flash',
                    openRouterKey: '',
                    openRouterModel: 'google/gemini-flash-1.5',
                    koboldcpp_url: 'http://localhost:5001',
                    koboldcpp_template: 'none',
                    koboldcpp_min_p: 0.1,
                    koboldcpp_dry: 0.25,
                    lmstudio_url: 'http://localhost:1234',
                    userPersonas: [],
                    savedOpenRouterModels: []
                };
            },
            /**
             * Returns default UI settings.
             * @returns {Object}
             */
            getDefaultUiSettings() {
                return {
                    font: "'Inter', sans-serif", backgroundImageURL: '', bubbleOpacity: 0.85,
                    chatTextColor: '#e5e7eb', characterImageMode: 'none',
                    backgroundBlur: 5, textSize: 16, bubbleImageSize: 100,
                    showPortraitPanel: true,
                    // ... markdown colors ...
                    md_h1_color: '#818cf8', md_h2_color: '#a5b4fc', md_h3_color: '#c7d2fe',
                    md_bold_color: '#ffffff', md_italic_color: '#9ca3af', md_quote_color: '#9ca3af',
                    md_h1_font: '', md_h2_font: '', md_h3_font: '', md_bold_font: '', md_italic_font: '', md_quote_font: ''
                };
            },
            /**
             * Returns default story settings.
             * @returns {Object}
             */
            getDefaultStorySettings() {
                return {
                    creator_notes: "",
                    tags: [],
                    event_master_probability: 0,
                    enableAnalysis: false,
                    responseLength: 'normal'
                };
            },
            /**
             * Returns default system prompts.
             * @returns {Object}
             */
            getDefaultSystemPrompts() {
                return {
                    system_prompt: 'You are a master storyteller. Follow instructions precisely.',
                    event_master_base_prompt: 'You are a secret Event Master. Read the chat. Generate a brief, secret instruction for AI characters to introduce a logical but unexpected event.',
                    event_master_prompt: 'You are a secret Event Master. Read the chat. Generate a brief, secret instruction for AI characters to introduce a logical but unexpected event.',
                    prompt_persona_gen: "Embellish this character concept into a rich, detailed, and compelling persona description, focusing on detailed appearance, personality, goals, relationships, and backstory. CONCEPT: \"{concept}\"",
                    prompt_world_map_gen: "Based on the following story context, generate a genre-appropriate 8x8 grid of interconnected fantasy locations. The central location (4,4) should be a neutral starting point. Attempt to include locations mentioned in the context.\nCONTEXT:\nCHARACTERS:\n{characters}\n\nSTATIC LORE:\n{static}\n\nRECENT EVENTS:\n{recent}\n\nRespond with a valid JSON object: { \"grid\": [ { \"coords\": {\"x\":int, \"y\":int}, \"name\": \"string\", \"description\": \"string (one-line summary)\", \"prompt\": \"string (a rich, detailed paragraph for the AI)\", \"imageUrl\": \"\" } ] }. The grid must contain exactly 64 locations.",
                    prompt_location_gen: "Generate a rich, detailed, and evocative paragraph-long prompt for a fantasy location named '{name}' which is briefly described as '{description}'. This prompt will be given to an AI storyteller to describe the scene.",
                    prompt_entry_gen: "Generate a detailed and informative encyclopedia-style entry for a lore topic titled '{title}'. If relevant, use the following triggers as context: '{triggers}'.",
                    prompt_location_memory_gen: "You are an archivist. Read the following chat transcript that occurred at a specific location. Summarize the key events, character developments, and important facts into a concise, single paragraph. This will serve as a memory for what happened at that location.\n\nTRANSCRIPT:\n{transcript}",
                    prompt_story_notes_gen: "Based on the following story context (characters, lore), generate a brief, 1-2 sentence creator's note or 'blurb' for this story to show in a library.\n\nCONTEXT:\n{context}",
                    prompt_story_tags_gen: "Based on the following story context (characters, lore), generate 3-5 relevant, one-word, comma-separated tags for this story (e.g., fantasy, sci-fi, mystery, horror, romance).\n\nCONTEXT:\n{context}",
                    visual_master_base_prompt: "You are a visual director. Based on the provided chat history, characters, and location, generate a high-quality, vivid, and detailed image generation prompt that captures the current scene. Focus on atmosphere, lighting, and key subjects. Output ONLY the visual description.",
                    prompt_auto_static_knowledge: "You are an automated archivist. Analyze the recent conversation transcript. Identify all significant new facts, rules, or lore details established in this text that should be permanently recorded in the static knowledge base. Ignore trivial actions or movements. If a valid fact is found, respond with a JSON object: { \"title\": \"Topic\", \"content\": \"Concise summary of the fact.\" }. If nothing important occurred, return { \"title\": null }.\n\nTRANSCRIPT:\n{transcript}"
                };
            },
            /**
             * Creates a default 8x8 map grid.
             * @returns {Array<Object>}
             */
            createDefaultMapGrid() {
                const grid = [];
                for (let y = 0; y < 8; y++) {
                    for (let x = 0; x < 8; x++) {
                        grid.push({
                            coords: { x, y },
                            name: "",
                            description: "",
                            prompt: "",
                            imageUrl: "",
                            local_static_entries: []
                        });
                    }
                }
                return grid;
            },
            /**
             * Finds a path between two coordinates on the grid using A*.
             * @param {Array<Object>} grid - The map grid.
             * @param {Object} startCoords - The starting coordinates.
             * @param {Object} endCoords - The ending coordinates.
             * @returns {Array<Object>} - The path coordinates.
             */
            findPath(grid, startCoords, endCoords) {
                const toKey = ({ x, y }) => `${x},${y}`;
                const nodes = grid.map(loc => ({
                    ...loc,
                    g: Infinity,
                    h: Infinity,
                    f: Infinity,
                    parent: null,
                }));

                const startNode = nodes.find(n => n.coords.x === startCoords.x && n.coords.y === startCoords.y);
                const endNode = nodes.find(n => n.coords.x === endCoords.x && n.coords.y === endCoords.y);
                if (!startNode || !endNode) return [];

                const heuristic = (a, b) => Math.abs(a.coords.x - b.coords.x) + Math.abs(a.coords.y - b.coords.y);

                let openSet = [startNode];
                let closedSet = new Set();

                startNode.g = 0;
                startNode.h = heuristic(startNode, endNode);
                startNode.f = startNode.h;

                while (openSet.length > 0) {
                    openSet.sort((a, b) => a.f - b.f);
                    let currentNode = openSet.shift();

                    if (currentNode === endNode) {
                        let path = [];
                        let temp = currentNode;
                        while (temp) {
                            path.push(temp.coords);
                            temp = temp.parent;
                        }
                        return path.reverse();
                    }

                    closedSet.add(toKey(currentNode.coords));

                    const neighbors = nodes.filter(n => {
                        const dx = Math.abs(n.coords.x - currentNode.coords.x);
                        const dy = Math.abs(n.coords.y - currentNode.coords.y);
                        return (dx === 1 && dy === 0) || (dx === 0 && dy === 1);
                    });

                    for (let neighbor of neighbors) {
                        if (closedSet.has(toKey(neighbor.coords))) continue;
                        let tentativeG = currentNode.g + 1;
                        if (tentativeG < neighbor.g) {
                            neighbor.parent = currentNode;
                            neighbor.g = tentativeG;
                            neighbor.h = heuristic(neighbor, endNode);
                            neighbor.f = neighbor.g + neighbor.h;
                            if (!openSet.includes(neighbor)) openSet.push(neighbor);
                        }
                    }
                }
                return [];
            },
            /**
             * Selects an item from a list based on weights.
             * @param {Array} characters - The items to choose from.
             * @param {Array<number>} weights - The weights for each item.
             * @returns {*} - The selected item.
             */
            weightedChoice(characters, weights) {
                if (characters.length !== weights.length || characters.length === 0) return null;
                const totalWeight = weights.reduce((sum, weight) => sum + weight, 0);
                if (totalWeight <= 0) return characters[Math.floor(Math.random() * characters.length)];
                let random = Math.random() * totalWeight;
                for (let i = 0; i < characters.length; i++) {
                    random -= weights[i];
                    if (random <= 0) return characters[i];
                }
                return characters[characters.length - 1];
            },
            /**
             * Checks if there is enough localStorage quota.
             * @param {number} estimatedSize - The estimated size of data to save.
             * @returns {boolean} - True if quota is sufficient.
             */
            checkLocalStorageQuota(estimatedSize) {
                try {
                    const testKey = 'quota-check';
                    const existingDataSize = JSON.stringify(localStorage).length;
                    const availableSpace = (5 * 1024 * 1024) - existingDataSize;
                    if (estimatedSize > availableSpace) return false;
                    localStorage.setItem(testKey, '1');
                    localStorage.removeItem(testKey);
                    return true;
                } catch (e) { return false; }
            }
        };

        /**
             * PromptBuilder Module
             * Updated with Null-Safety Checks
             */
        /**
         * PromptBuilder Module
         * Constructs the context and prompts sent to the AI.
         * Handles template formatting (Llama 3, Gemma, etc.) and context assembly (history, lore, world map).
         */
        const PromptBuilder = {
            /**
             * Creates a replacement function for template strings.
             * @param {Object} contextCharacter - The character context.
             * @returns {Function} - The replacer function.
             * @private
             */
            _getReplacer(contextCharacter) {
                const state = StateManager.getState();
                const userChar = state.characters.find(c => c.is_user);
                const characterName = contextCharacter ? contextCharacter.name : '';
                const userName = userChar ? userChar.name : 'You';
                return (text) => {
                    if (typeof text !== 'string') return '';
                    let processedText = text.replace(/{character}/g, characterName);
                    processedText = processedText.replace(/{user}/g, userName);
                    return processedText;
                };
            },

            /**
             * Retrieves a slice of chat history, filtering out hidden messages.
             * @param {Array} history - The chat history.
             * @param {number} chatMessageCount - The number of messages to retrieve.
             * @returns {Array} - The history slice.
             * @private
             */
            _getSmartHistorySlice(history, chatMessageCount) {
                if (!Array.isArray(history)) return [];

                let chatCount = 0;
                let startIndex = history.length;

                // Loop backwards
                for (let i = history.length - 1; i >= 0; i--) {
                    const msg = history[i];

                    // Safety check for undefined/null messages
                    if (!msg) continue;

                    startIndex = i;
                    if (msg.type === 'chat' && !msg.isHidden) chatCount++;
                    if (chatCount >= chatMessageCount) break;
                }
                return history.slice(startIndex);
            },

            /**
             * Builds the main prompt for the AI.
             * @param {string} charToActId - The ID of the character acting.
             * @param {boolean} [isForUser=false] - Whether the prompt is for the user.
             * @returns {string} - The constructed prompt.
             */
            buildPrompt(charToActId, isForUser = false) {
                const state = StateManager.getState();
                const charToAct = state.characters.find(c => c.id === charToActId);
                if (!charToAct) return "";

                const replacer = this._getReplacer(charToAct);
                const modelInstructions = charToAct.model_instructions || state.system_prompt;

                let locationContext = '';
                if (state.worldMap && state.worldMap.grid.length > 0) {
                    const { grid, currentLocation, path } = state.worldMap;
                    const currentLoc = grid.find(l => l.coords.x === currentLocation.x && l.coords.y === currentLocation.y);

                    if (currentLoc && currentLoc.name) {
                        locationContext += `CURRENT LOCATION: ${currentLoc.name}\n`;
                        if (currentLoc.prompt) locationContext += `${currentLoc.prompt}\n\n`;
                        else locationContext += `(No detailed description available.)\n\n`;

                        if (currentLoc.local_static_entries && currentLoc.local_static_entries.length > 0) {
                            locationContext += "--- LOCATION-SPECIFIC KNOWLEDGE ---\n";
                            locationContext += currentLoc.local_static_entries
                                .map(l => `Title: ${l.title}\nContent: ${replacer(l.content)}`)
                                .join('\n\n') + "\n\n";
                        }
                    }

                    if (currentLoc) {
                        const directions = [
                            { dir: 'North', x: 0, y: -1 }, { dir: 'South', x: 0, y: 1 },
                            { dir: 'East', x: 1, y: 0 }, { dir: 'West', x: -1, y: 0 },
                            { dir: 'Northeast', x: 1, y: -1 }, { dir: 'Northwest', x: -1, y: -1 },
                            { dir: 'Southeast', x: 1, y: 1 }, { dir: 'Southwest', x: -1, y: 1 }
                        ];
                        const validAdjacentLocations = directions
                            .map(({ dir, x, y }) => {
                                const adjLoc = grid.find(l => l.coords.x === currentLocation.x + x && l.coords.y === currentLocation.y + y);
                                if (adjLoc && adjLoc.name && adjLoc.description) {
                                    return `- (${dir}): ${adjLoc.name} - ${adjLoc.description}`;
                                }
                                return null;
                            })
                            .filter(Boolean);
                        if (validAdjacentLocations.length > 0) {
                            locationContext += 'ADJACENT LOCATIONS:\n' + validAdjacentLocations.join('\n') + '\n\n';
                        }
                    }

                    if (path && path.length > 0) {
                        const pathNames = path.map(p => grid.find(l => l.coords.x === p.x && l.coords.y === p.y)?.name).filter(Boolean).join(' -> ');
                        if (pathNames) locationContext += `TRAVEL PATH TO DESTINATION: ${pathNames}\n`;
                    }
                }

                const components = {
                    system_prompt: replacer(modelInstructions),
                    event_master_prompt: replacer(state.event_master_prompt),
                    static_entries: (state.static_entries || []).map(l => `### ${l.title}\n${replacer(l.content)}`).join('\n\n'),
                    // Only include Narrator description if THAT Narrator is the one acting.
                    // Standard characters are always included if active.
                    characters: (state.characters || [])
                        .filter(c => c.is_active)
                        .filter(c => {
                            if (c.is_narrator) {
                                return c.id === charToActId;
                            }
                            return true;
                        })
                        .map(c => `### Character: ${c.name}\n\n${replacer(c.description)}`)
                        .join('\n\n'), history: this._getSmartHistorySlice(state.chat_history || [], 10),
                    charToAct: charToAct,
                    isForUser: isForUser,
                    location_context: locationContext,
                    dynamic_entries: '' // If needed, pull from state logic or remove if handled elsewhere
                };

                // Simple auto-consume logic for event master
                if (state.event_master_prompt) {
                    state.event_master_prompt = '';
                    StateManager.saveState();
                }

                if (state.apiProvider === 'koboldcpp') {
                    return this.buildKoboldTemplatedPrompt(components, replacer);
                }
                return this.buildDefaultPrompt(components, replacer);
            },

            /**
             * Builds the default prompt format.
             * @param {Object} components - The prompt components.
             * @param {Function} replacer - The replacer function.
             * @returns {string}
             */
            buildDefaultPrompt(components, replacer) {
                const state = StateManager.getState();
                let p = components.system_prompt + "\n\n";
                if (components.event_master_prompt) p += "--- SECRET EVENT MASTER INSTRUCTION ---\n" + components.event_master_prompt + "\n\n";
                if (components.location_context) p += "## LOCATION CONTEXT\n" + components.location_context + "\n\n";
                p += "## WORLD KNOWLEDGE\n" + components.static_entries + "\n\n";
                // Note: Dynamic entries usually injected into chat history as 'lore_reveal', but can be added here if architectural preference changes.
                p += "## CHARACTERS\n" + components.characters + "\n\n";

                const exampleDialogue = (state.chat_history || []).filter(m => m && m.isHidden);
                if (exampleDialogue.length > 0) {
                    p += "## EXAMPLE DIALOGUE\n";
                    exampleDialogue.forEach(msg => {
                        // Safety Check
                        if (!msg) return;
                        const char = state.characters.find(c => c.id === msg.character_id);
                        if (char) p += `${char.name}: ${replacer(msg.content)}\n`;
                    });
                    p += "\n";
                }

                p += "## RECENT CONVERSATION & EVENTS\n";
                components.history.forEach(msg => {
                    // Safety Checks
                    if (!msg) return;
                    if (msg.type === 'chat' && msg.isHidden) return;

                    if (msg.type === 'chat') {
                        const char = state.characters.find(c => c.id === msg.character_id);
                        if (char) p += `[${char.name}:]\n${replacer(msg.content)}\n\n`;
                    } else if (msg.type === 'lore_reveal') {
                        p += `[System Note:\n${replacer(msg.content)}]\n\n`;
                    } else if (msg.type === 'system_event') {
                        p += `[System Event: ${replacer(msg.content)}]\n\n`;
                    }
                });
                p += "\n### INSTRUCTION\n";
                p += components.isForUser ? `Generate the next creative response for the user's character, ${components.charToAct.name}.` : `Generate the next response for ${components.charToAct.name}. Stay in character.`;

                // Response Length Instruction
                const responseLength = state.responseLength || 'normal';
                if (!components.charToAct.is_narrator) {
                    if (responseLength === 'short') p += " Keep the response concise and under two sentences.";
                    else if (responseLength === 'medium') p += " Keep the response between two to four sentences.";
                    else if (responseLength === 'long') p += " Be descriptive, verbose, and detailed in your response.";
                    else if (responseLength === 'novel') p += " Continue writing a long-form addition to the text that builds on the current actions, describes the scene, and contributes to world-building.";
                }

                p += " Do not repeat the character's name in the response itself.\n[CHARACTER_TO_ACT]: " + components.charToAct.name;
                return p;
            },

            /**
             * Builds a prompt formatted for KoboldCPP templates.
             * @param {Object} components - The prompt components.
             * @param {Function} replacer - The replacer function.
             * @returns {string}
             */
            buildKoboldTemplatedPrompt(components, replacer) {
                const state = StateManager.getState();
                const template = state.koboldcpp_template || 'none';

                // 1. Construct System/Context Block
                let system = [components.system_prompt];
                if (components.event_master_prompt) system.push("SECRET EVENT INSTRUCTION:\n" + components.event_master_prompt);
                if (components.location_context) system.push("LOCATION CONTEXT:\n" + components.location_context);
                system.push("STATIC KNOWLEDGE:\n" + components.static_entries);
                system.push("CHARACTERS:\n" + components.characters);
                const system_prompt_str = system.join('\n\n');

                let instruction = components.isForUser
                    ? `Write the next chat message for the user's character, ${components.charToAct.name}.`
                    : `Write the next chat message for ${components.charToAct.name}. Stay in character.`;
                instruction += " Do not write any prefix like 'Character Name:'.";

                // Response Length Instruction
                const responseLength = state.responseLength || 'normal';
                if (!components.charToAct.is_narrator) {
                    if (responseLength === 'short') instruction += " Your response should be concise and under two sentences.";
                    else if (responseLength === 'medium') instruction += " Keep the response between two to four sentences.";
                    else if (responseLength === 'long') instruction += " Be descriptive, verbose, and detailed in your response.";
                    else if (responseLength === 'novel') instruction += " Continue writing a long-form addition to the text that builds on the current actions, describes the scene, and contributes to world-building.";
                }
                if (template === 'none') return this.buildDefaultPrompt(components, replacer);

                // --- LLAMA 3 ---
                if (template === 'llama3') {
                    const history_llama3 = components.history.map(msg => {
                        if (!msg || (msg.type === 'chat' && msg.isHidden)) return null;
                        let role = 'user';
                        let content = '';
                        if (msg.type === 'chat') {
                            const char = state.characters.find(c => c.id === msg.character_id);
                            if (!char) return null;
                            role = char.is_user ? 'user' : 'assistant';
                            content = `${char.name}:\n${replacer(msg.content)}`;
                        } else if (msg.type === 'lore_reveal') {
                            role = 'system';
                            content = `[Dynamic Entry Revealed - ${msg.title}]\n${replacer(msg.content)}`;
                        } else if (msg.type === 'system_event') {
                            role = 'system';
                            content = `[System Event: ${replacer(msg.content)}]`;
                        } else { return null; }
                        return `<|start_header_id|>${role}<|end_header_id|>\n\n${content}<|eot_id|>`;
                    }).filter(Boolean).join('\n');

                    return `<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\n${system_prompt_str}<|eot_id|>\n${history_llama3}\n<|start_header_id|>user<|end_header_id|>\n\n${instruction}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\n${components.charToAct.name}:\n`;
                }

                // --- GEMMA (Google) ---
                if (template === 'gemma') {
                    // Gemma often prefers system prompts to be part of the first user turn or a distinct user turn
                    // We will format the system prompt as a user turn for maximum compatibility
                    const history_gemma = components.history.map(msg => {
                        if (!msg || (msg.type === 'chat' && msg.isHidden)) return null;

                        let role = 'user';
                        let content = '';

                        if (msg.type === 'chat') {
                            const char = state.characters.find(c => c.id === msg.character_id);
                            if (!char) return null;
                            role = char.is_user ? 'user' : 'model'; // Gemma uses 'model', not 'assistant'
                            content = `${char.name}:\n${replacer(msg.content)}`;
                        } else if (msg.type === 'lore_reveal' || msg.type === 'system_event') {
                            // System events injected as user context
                            return `<start_of_turn>user\n[System Note: ${replacer(msg.content)}]<end_of_turn>`;
                        } else { return null; }

                        return `<start_of_turn>${role}\n${content}<end_of_turn>`;
                    }).filter(Boolean).join('\n');

                    return `<start_of_turn>user\n${system_prompt_str}<end_of_turn>\n${history_gemma}\n<start_of_turn>user\n${instruction}<end_of_turn>\n<start_of_turn>model\n${components.charToAct.name}:\n`;
                }

                // --- PHI-3 (Microsoft) ---
                if (template === 'phi3') {
                    const history_phi = components.history.map(msg => {
                        if (!msg || (msg.type === 'chat' && msg.isHidden)) return null;

                        let role = 'user';
                        let content = '';
                        if (msg.type === 'chat') {
                            const char = state.characters.find(c => c.id === msg.character_id);
                            if (!char) return null;
                            role = char.is_user ? 'user' : 'assistant';
                            content = `${char.name}:\n${replacer(msg.content)}`;
                        } else if (msg.type === 'lore_reveal') {
                            return `<|system|>\n[Dynamic Entry: ${replacer(msg.content)}]<|end|>`;
                        } else if (msg.type === 'system_event') {
                            return `<|system|>\n${replacer(msg.content)}<|end|>`;
                        } else { return null; }

                        return `<|${role}|>\n${content}<|end|>`;
                    }).filter(Boolean).join('\n');

                    return `<|system|>\n${system_prompt_str}<|end|>\n${history_phi}\n<|user|>\n${instruction}<|end|>\n<|assistant|>\n${components.charToAct.name}:\n`;
                }

                // --- MISTRAL ---
                if (template === 'mistral') {
                    const history_str = components.history.map(msg => {
                        if (!msg || (msg.type === 'chat' && msg.isHidden)) return null;
                        if (msg.type === 'chat') {
                            const char = state.characters.find(c => c.id === msg.character_id);
                            if (char) return `${char.is_user ? 'user' : 'assistant'}:${char.name}:\n${replacer(msg.content)}`;
                        } else if (msg.type === 'lore_reveal') {
                            return `system:Dynamic Entry Revealed - ${msg.title}:\n${replacer(msg.content)}`;
                        } else if (msg.type === 'system_event') {
                            return `system:System Event:\n${replacer(msg.content)}`;
                        }
                        return null;
                    }).filter(Boolean).join('\n');
                    return `<s>[INST] ${system_prompt_str}\n\n${history_str}\n\n${instruction} [/INST]`;
                }

                // --- CHATML ---
                if (template === 'chatml') {
                    const history_chatml = components.history.map(msg => {
                        if (!msg || (msg.type === 'chat' && msg.isHidden)) return null;
                        let role = 'system';
                        let content = '';
                        if (msg.type === 'chat') {
                            const char = state.characters.find(c => c.id === msg.character_id);
                            if (!char) return null;
                            role = char.is_user ? 'user' : 'assistant';
                            content = `${char.name}:\n${replacer(msg.content)}`;
                        } else if (msg.type === 'lore_reveal') {
                            content = `[Dynamic Entry Revealed - ${msg.title}]\n${replacer(msg.content)}`;
                        } else if (msg.type === 'system_event') {
                            content = `[System Event: ${replacer(msg.content)}]`;
                        } else { return null; }
                        return `<|im_start|>${role}\n${content}<|im_end|>`;
                    }).filter(Boolean).join('\n');
                    return `<|im_start|>system\n${system_prompt_str}<|im_end|>\n${history_chatml}\n<|im_start|>user\n${instruction}<|im_end|>\n<|im_start|>assistant\n${components.charToAct.name}:\n`;
                }

                // --- ALPACA ---
                if (template === 'alpaca') {
                    const history_str = components.history.map(msg => {
                        if (!msg || (msg.type === 'chat' && msg.isHidden)) return null;
                        const char = state.characters.find(c => c.id === msg.character_id);
                        return char ? `${char.name}: ${replacer(msg.content)}` : null;
                    }).filter(Boolean).join('\n');
                    return `### Instruction:\n${system_prompt_str}\n\n${history_str}\n\n${instruction}\n\n### Response:\n`;
                }

                return this.buildDefaultPrompt(components, replacer);
            }
        };

        /**
         * ImageProcessor Module
         */
        /**
         * ImageProcessor Module
         * Handles image manipulation tasks such as resizing, cropping, and format conversion.
         * Essential for optimizing images before storage or export.
         */
        const ImageProcessor = {
            /**
             * Processes an image file, resizing it if necessary, and returns a Blob.
             * @param {File|Blob} imageFile - The image file to process.
             * @returns {Promise<Blob>} - The processed image blob.
             */
            async processImageAsBlob(imageFile) {
                return new Promise((resolve, reject) => {
                    const MAX_HEIGHT = 2000;
                    const QUALITY = 0.85;
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const img = new Image();
                        img.onload = () => {
                            let { width, height } = img;
                            if (height > MAX_HEIGHT) {
                                const ratio = MAX_HEIGHT / height;
                                height = MAX_HEIGHT;
                                width *= ratio;
                            }
                            const canvas = document.createElement('canvas');
                            canvas.width = width;
                            canvas.height = height;
                            const ctx = canvas.getContext('2d');
                            ctx.drawImage(img, 0, 0, width, height);

                            canvas.toBlob((blob) => {
                                if (blob) {
                                    resolve(blob);
                                } else {
                                    reject(new Error('Canvas to Blob conversion failed.'));
                                }
                            }, 'image/jpeg', QUALITY);
                        };
                        img.onerror = (err) => reject(new Error('Failed to load image for processing.'));
                        img.src = e.target.result;
                    };
                    reader.onerror = (err) => reject(new Error('Failed to read image file.'));
                    reader.readAsDataURL(imageFile);
                });
            },

            /**
             * Converts an image blob to a PNG blob.
             * @param {Blob} imageBlob - The source image blob.
             * @returns {Promise<Blob>} - The PNG blob.
             */
            async convertBlobToPNGBlob(imageBlob) {
                return new Promise((resolve, reject) => {
                    const imageUrl = URL.createObjectURL(imageBlob);
                    const img = new Image();
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        canvas.width = img.naturalWidth;
                        canvas.height = img.naturalHeight;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0);
                        URL.revokeObjectURL(imageUrl);
                        canvas.toBlob((pngBlob) => {
                            if (pngBlob) {
                                resolve(pngBlob);
                            } else {
                                reject(new Error('Canvas to PNG Blob conversion failed.'));
                            }
                        }, 'image/png');
                    };
                    img.onerror = (err) => {
                        URL.revokeObjectURL(imageUrl);
                        reject(new Error('Failed to load image blob for PNG conversion.'));
                    };
                    img.src = imageUrl;
                });
            }
        };

        /**
         * ImportExportService Module
         */
        /**
         * ImportExportService Module
         * Manages the import and export of stories, characters, and libraries.
         * Supports multiple formats including Ellipsis JSON, V2 Cards, and BYAF.
         */
        const ImportExportService = {
            /**
             * Parses an uploaded file based on its extension.
             * @param {File} file - The uploaded file.
             * @param {boolean} [skipImages=false] - Whether to skip image processing.
             * @returns {Promise<Object>} - The parsed story object and optional image blob.
             */
            async parseUploadedFile(file, skipImages = false) {
                const lowerCaseName = file.name.toLowerCase();
                if (lowerCaseName.endsWith('.png')) {
                    return this._parseV2Card(file, skipImages);
                } else if (lowerCaseName.endsWith('.zip') || lowerCaseName.endsWith('.byaf')) {
                    // Peek inside ZIP to distinguish between BYAF and Ellipsis ZIP
                    const zip = await JSZip.loadAsync(file);
                    if (zip.file('narrative.json')) {
                        return this._parseStoryZip(zip, file, skipImages);
                    }
                    return this._parseBYAF(file, skipImages);
                } else if (lowerCaseName.endsWith('.json')) {
                    return this._parseEllipsisJSON(file);
                } else {
                    throw new Error("Unsupported file type. Please use .png, .byaf, .zip, or .json.");
                }
            },

            /**
             * Exports a story as a JSON blob.
             * @param {Object} story - The story object.
             * @returns {Blob} - The JSON blob.
             */
            exportStoryAsJSON(story) {
                const storyExport = JSON.parse(JSON.stringify(story));
                return new Blob([JSON.stringify(storyExport, null, 2)], { type: 'application/json' });
            },

            /**
             * Ensures all characters in the chat history exist in the story.
             * @param {Object} story - The story object.
             * @param {Array} chatHistory - The chat history.
             * @returns {Array<string>} - The list of active character IDs.
             * @private
             */
            _ensureCharactersExist(story, chatHistory) {
                const registeredIds = new Set(story.characters.map(c => c.id));
                const activeIds = new Set(story.characters.filter(c => c.is_active).map(c => c.id));

                // Map names to IDs for existing chars to avoid duplicates if ID is missing but name matches
                const nameToId = {};
                story.characters.forEach(c => nameToId[c.name] = c.id);

                chatHistory.forEach(msg => {
                    if (msg.type === 'chat' && !registeredIds.has(msg.character_id)) {
                        // We found a message with an ID that isn't in the roster.
                        // This is a "Ghost". We must manifest a body for it.

                        // 1. Check if we can recover it by name (common in V2 imports)
                        // (Assuming content might have name prefix, or we just create a generic one)
                        // Since V2/BYAF often don't give us the ID in the message, we might have generated a random UUID 
                        // for the message that has no matching char. 

                        // Actually, for V2/BYAF, the previous logic often maps names to IDs. 
                        // If the mapping failed, we need a fallback.

                        const ghostChar = {
                            id: msg.character_id, // Use the ID the message is already pointing to
                            name: msg.name || "Unknown Speaker", // Fallback name
                            description: "Imported from group chat history.",
                            short_description: "Imported.",
                            model_instructions: "Act as this character.",
                            tags: ["imported"],
                            image_url: "",
                            extra_portraits: [],
                            is_user: false,
                            is_active: true, // Keep active so they show up
                            is_narrator: false,
                            color: { base: '#475569', bold: '#94a3b8' } // Slate
                        };

                        story.characters.push(ghostChar);
                        registeredIds.add(ghostChar.id);
                        activeIds.add(ghostChar.id);
                    }
                });

                return Array.from(activeIds);
            },

            /**
             * Exports a story as a V2 Character Card (PNG).
             * @param {Object} story - The story object.
             * @param {Object} narrative - The narrative object.
             * @param {string} primaryCharId - The ID of the primary character.
             * @returns {Promise<Uint8Array>} - The PNG buffer with embedded data.
             */
            async exportStoryAsV2(story, narrative, primaryCharId) {
                const primaryChar = story.characters.find(c => c.id === primaryCharId);
                if (!primaryChar) throw new Error("V2 export requires a selected primary character.");
                let originalImageBlob = null;
                try { originalImageBlob = await DBService.getImage(primaryChar.id); } catch (dbError) { }
                if (!originalImageBlob && primaryChar.image_url && !primaryChar.image_url.startsWith('local_idb_')) {
                    try {
                        const response = await fetch(primaryChar.image_url);
                        if (response.ok) originalImageBlob = await response.blob();
                    } catch (fetchError) { }
                }
                if (!originalImageBlob) throw new Error("V2 export requires the primary character to have a valid image.");

                let pngBlob;
                try {
                    if (originalImageBlob.type === 'image/png') pngBlob = originalImageBlob;
                    else pngBlob = await ImageProcessor.convertBlobToPNGBlob(originalImageBlob);
                } catch (conversionError) { throw new Error("Failed to convert character image to PNG format for export."); }

                const v2Object = this._convertEllipsistoV2(story, narrative, primaryCharId);
                const pngImageBuffer = await pngBlob.arrayBuffer();
                return this._injectDataIntoPng(pngImageBuffer, v2Object);
            },

            /**
             * Exports a story as a BYAF (Backyard AI Format) ZIP.
             * @param {Object} story - The story object.
             * @param {Object} narrative - The narrative object.
             * @param {string} primaryCharId - The ID of the primary character.
             * @returns {Promise<Blob>} - The ZIP blob.
             */
            async exportStoryAsBYAF(story, narrative, primaryCharId) {
                const primaryChar = story.characters.find(c => c.id === primaryCharId);
                if (!primaryChar) throw new Error("BYAF export requires a selected primary character.");
                let imageBlob = null;
                let imageExtension = 'png';
                let imageFilename = null;
                try {
                    const blob = await DBService.getImage(primaryChar.id);
                    if (blob) {
                        imageBlob = blob;
                        const typeParts = blob.type.split('/');
                        if (typeParts.length === 2 && ['png', 'jpeg', 'jpg', 'webp'].includes(typeParts[1])) {
                            imageExtension = typeParts[1] === 'jpeg' ? 'jpg' : typeParts[1];
                        }
                    }
                } catch (dbError) { }
                if (!imageBlob && primaryChar.image_url && !primaryChar.image_url.startsWith('local_idb_')) {
                    try {
                        const response = await fetch(primaryChar.image_url);
                        if (response.ok) {
                            imageBlob = await response.blob();
                            const contentType = response.headers.get('content-type');
                            if (contentType) {
                                const typeParts = contentType.split('/');
                                if (typeParts.length === 2 && ['png', 'jpeg', 'jpg', 'webp'].includes(typeParts[1])) {
                                    imageExtension = typeParts[1] === 'jpeg' ? 'jpg' : typeParts[1];
                                }
                            } else {
                                const urlParts = primaryChar.image_url.split('.').pop()?.toLowerCase();
                                if (urlParts && ['png', 'jpg', 'jpeg', 'webp'].includes(urlParts)) imageExtension = urlParts === 'jpeg' ? 'jpg' : urlParts;
                            }
                        }
                    } catch (fetchError) { }
                }
                if (imageBlob) imageFilename = `${primaryChar.id}.${imageExtension}`;
                const byafArchiveData = this._convertEllipsistoBYAF(story, narrative, primaryCharId, imageFilename);
                if (!byafArchiveData || !byafArchiveData.manifest) throw new Error("Failed to generate BYAF data structure.");
                const zip = new JSZip();
                zip.file("manifest.json", JSON.stringify(byafArchiveData.manifest, null, 2));
                const charFolder = zip.folder(`characters/${primaryChar.id}`);
                charFolder.file("character.json", JSON.stringify(byafArchiveData.character, null, 2));
                if (imageBlob && imageFilename) charFolder.file(`images/${imageFilename}`, imageBlob);
                zip.file(`scenarios/scenario1.json`, JSON.stringify(byafArchiveData.scenario, null, 2));
                // Background Image: Include in ZIP for BYAF format compatibility
                if (story.backgroundImageURL === 'local_idb_background') {
                    try {
                        const bgBlob = await DBService.getImage(`bg_${story.id}`);
                        if (bgBlob) {
                            zip.file("images/story_background.png", bgBlob);
                        }
                    } catch (e) { console.warn("Failed to add background to BYAF:", e); }
                }

                return zip.generateAsync({ type: "blob" });
            },

            /**
             * Exports a story as a comprehensive ZIP archive.
             * Includes narrative.html (viewable), narrative.json (data), and an images folder.
             * @param {Object} story - The story object.
             * @param {Object} narrative - The narrative object.
             * @returns {Promise<Blob>} - The ZIP blob.
             */
            async exportStoryAsZip(story, narrative) {
                const zip = new JSZip();
                const imagesFolder = zip.folder("images");
                const imageMap = new Map(); // key -> filename
                const log = []; // Debug log
                const logMsg = (msg) => { console.log(msg); log.push(msg); };

                logMsg(`Exporting ZIP for story: ${story.name} (${story.id})`);
                logMsg(`Characters: ${story.characters.length}`);

                // Pre-fetch all image keys for fuzzy matching
                const allImageKeys = await DBService.getAllKeys("characterImages");
                logMsg(`Total DB Image Keys: ${allImageKeys.length}`);

                // Helper to add image to ZIP and track filename
                const addImage = async (key, filenamePrefix) => {
                    if (!key) return;
                    // Since we might try multiple keys for the same conceptual image, verify we haven't already exported this KEY.
                    if (imageMap.has(key)) return;

                    // Check if we already have this blob under a DIFFERENT key? 
                    // Hard to check blob equality without fetching. Let's rely on key uniqueness.

                    let blob = null;
                    let successKey = key;

                    // Strategy 1: Direct Lookup
                    try {
                        blob = await DBService.getImage(key);
                    } catch (e) { }

                    // Strategy 2: Prefix/Suffix Variations
                    if (!blob && !key.startsWith('http')) {
                        const candidates = [
                            `local_idb_${key}`,
                            key.replace('local_idb_', ''),
                            // Try finding key in allImageKeys that ENDS with the ID (uuid)
                            // This covers 'local_idb_UUID' matching 'UUID'
                            ...allImageKeys.filter(k => typeof k === 'string' && (k.includes(key) || key.includes(k)))
                        ];

                        // Deduplicate and filter candidates
                        const uniqueCandidates = [...new Set(candidates)].filter(c => c !== key);

                        for (const cand of uniqueCandidates) {
                            if (blob) break;
                            logMsg(`  > Trying fallback key: ${cand} for ${key}`);
                            blob = await DBService.getImage(cand);
                            if (blob) successKey = cand;
                        }
                    }

                    if (blob) {
                        const ext = blob.type.split('/')[1] || 'png';
                        const safeExt = ext === 'jpeg' ? 'jpg' : ext;

                        // Sanitize filename
                        const safePrefix = filenamePrefix.replace(/[^a-z0-9_-]/gi, '_');
                        // Use the ORIGINAL key for suffix to keep file name consistent with expectation, 
                        // unless it's way too long, then use hash or slice.
                        const safeKeySuffix = key.replace(/[^a-z0-9]/gi, '').substring(0, 12);
                        const filename = `${safePrefix}_${safeKeySuffix}.${safeExt}`;

                        imagesFolder.file(filename, blob);
                        imageMap.set(key, `images/${filename}`); // Map the ORIGINAL key request to this file

                        // If we found it via a fallback key, ALSO map the fallback key just in case
                        if (successKey !== key) {
                            imageMap.set(successKey, `images/${filename}`);
                        }

                        logMsg(`  [OK] Added: ${filename} (Size: ${blob.size}, Key: ${key}, FoundAt: ${successKey})`);
                    } else {
                        if (!key.startsWith('http')) {
                            logMsg(`  [FAIL] Could not find image for key: ${key}`);
                        }
                    }
                };

                // 1. Export Character Images
                for (const char of story.characters) {
                    logMsg(`Processing Character: ${char.name} (${char.id})`);
                    if (char.image_url) await addImage(char.image_url, `char_${char.name}`);
                    // ALWAYS try the ID as a fallback / primary for local images
                    await addImage(char.id, `char_${char.name}`);

                    if (char.extra_portraits) {
                        for (const p of char.extra_portraits) {
                            const emoKey = `${char.id}::emotion::${p.emotion}`;
                            await addImage(emoKey, `char_${char.name}_${p.emotion}`);
                        }
                    }
                }

                // 2. Export Location Images (if any) and Story Background
                if (story.backgroundImageURL && !story.backgroundImageURL.startsWith('http')) {
                    await addImage(story.backgroundImageURL, 'background');
                    // Also try bg_${story.id} just in case
                    await addImage(`bg_${story.id}`, 'background_legacy');
                }

                // Scan World Map for location images (assuming they are keys)
                if (narrative.state.worldMap && narrative.state.worldMap.grid) {
                    for (const loc of narrative.state.worldMap.grid) {
                        const locKey = `location::${loc.coords.x},${loc.coords.y}`;
                        // Try explicit key
                        await addImage(locKey, `loc_${loc.coords.x}_${loc.coords.y}`);
                        // Try URL if present
                        if (loc.imageUrl && !loc.imageUrl.startsWith('http')) {
                            await addImage(loc.imageUrl, `loc_${loc.coords.x}_${loc.coords.y}_ref`);
                        }
                    }
                }

                // 3. Export Visual Event Images from Chat History
                if (narrative.state.chat_history) {
                    for (const msg of narrative.state.chat_history) {
                        if (msg.type === 'visual_event' && msg.image_key) {
                            await addImage(msg.image_key, 'visual');
                        }
                    }
                }

                // 4. Generate JSON Data
                // Hydrate full narratives like in JSON export
                // We need to fetch ALL narratives associated with the story to make it a complete backup
                // But the user might only strictly care about the active one + context?
                // The task says "Export ZIP Archive" (singular narrative implicitly?) -> No, typically "Export Story" implies the whole thing.
                // The original code tried fetching all.
                const fullNarratives = await Promise.all((story.narratives || []).map(n => DBService.getNarrative(n.id)));
                const exportObj = JSON.parse(JSON.stringify(story));
                exportObj.narratives = fullNarratives.filter(n => n);

                zip.file("narrative.json", JSON.stringify(exportObj, null, 2));

                // 5. Generate HTML
                const htmlContent = this._generateNarrativeHTML(story, narrative, imageMap);
                zip.file("narrative.html", htmlContent);
                zip.file("image_manifest.json", JSON.stringify(Object.fromEntries(imageMap), null, 2));

                // 6. Debug Log
                zip.file("_debug_export_log.txt", log.join('\n'));

                return zip.generateAsync({ type: "blob" });
            },

            /**
             * Generates a standalone HTML string for the narrative.
             * @param {Object} story - The story object.
             * @param {Object} narrative - The narrative object.
             * @param {Map} imageMap - Map of DB keys to ZIP relative paths.
             * @returns {string} - The HTML string.
             */
            _generateNarrativeHTML(story, narrative, imageMap) {
                const state = narrative.state;
                const title = story.name + " - " + narrative.name;
                const defaults = UTILITY.getDefaultUiSettings();
                const settings = { ...defaults, ...story }; // Merge defaults with story settings

                // CSS Variables Extraction
                const cssVars = `
            :root {
                --font-primary: ${settings.font || 'Inter, sans-serif'};
                --text-size: ${settings.textSize || 16}px;
                --md-h1-color: ${settings.md_h1_color || defaults.md_h1_color};
                --md-h2-color: ${settings.md_h2_color || defaults.md_h2_color};
                --md-h3-color: ${settings.md_h3_color || defaults.md_h3_color};
                --md-bold-color: ${settings.md_bold_color || defaults.md_bold_color};
                --md-italic-color: ${settings.md_italic_color || defaults.md_italic_color};
                --md-quote-color: ${settings.md_quote_color || defaults.md_quote_color};
                --chat-text-color: ${settings.chatTextColor || '#e5e7eb'};
                --brand-color: #6366f1;
            }
                `;

                // Render Chat History
                let chatHTML = '';
                (state.chat_history || []).forEach(msg => {
                    if (msg.isHidden || msg.type === 'lore_reveal') return;

                    // Handle Visual Events
                    if (msg.type === 'visual_event') {
                        const imgPath = imageMap.get(msg.image_key);
                        if (imgPath) {
                            chatHTML += `
                            <div class="message visual-event" style="text-align: center; margin: 2rem 0;">
                                <img src="${imgPath}" alt="Visual Event" style="max-width: 100%; border-radius: 0.75rem; box-shadow: 0 4px 6px rgba(0,0,0,0.3);">
                            </div>`;
                        }
                        return;
                    }

                    // Handle Chat Messages
                    const charId = msg.character_id;
                    const char = story.characters.find(c => c.id === charId);
                    const isUser = (char && char.is_user) || msg.character_id === 'user';
                    const name = char ? char.name : (isUser ? 'You' : 'Unknown');

                    // Colors & Styles
                    const charColor = (char && char.color) ? char.color : (isUser ? { base: '#4b5563', bold: '#e5e7eb' } : { base: '#334155', bold: '#94a3b8' });
                    const bubbleOpacity = settings.bubbleOpacity !== undefined ? settings.bubbleOpacity : 1.0;
                    // Hex to RGBA helper
                    const hexToRgba = (hex, alpha) => {
                        if (!hex) return hex;
                        if (/^#([A-Fa-f0-9]{3}){1,2}$/.test(hex)) {
                            let c = hex.substring(1).split('');
                            if (c.length === 3) c = [c[0], c[0], c[1], c[1], c[2], c[2]];
                            c = '0x' + c.join('');
                            return 'rgba(' + [(c >> 16) & 255, (c >> 8) & 255, c & 255].join(',') + ',' + alpha + ')';
                        }
                        return hex;
                    };
                    const bubbleBg = hexToRgba(charColor.base, bubbleOpacity);

                    // Avatar (if valid)
                    let avatarHTML = '';
                    let avatarKey = char?.image_url;
                    if (!avatarKey && char?.id) avatarKey = char.id; // Fallback for local images

                    if (avatarKey && imageMap.has(avatarKey)) {
                        avatarHTML = `<img src="${imageMap.get(avatarKey)}" class="avatar" style="float: left; width: 50px; height: 50px; border-radius: 50%; margin-right: 1rem; object-fit: cover;">`;
                    } else if (char?.image_url && char.image_url.startsWith('http')) {
                        avatarHTML = `<img src="${char.image_url}" class="avatar" style="float: left; width: 50px; height: 50px; border-radius: 50%; margin-right: 1rem; object-fit: cover;">`;
                    }

                    // Smart Quotes
                    const smartContent = (msg.content || '').replace(/(["][^"]*["])/g, '<span class="dialogue-quote">$1</span>');

                    chatHTML += `
                    <div class="message ${isUser ? 'user-message' : 'ai-message'}" style="background-color: ${bubbleBg}; padding: 1rem; border-radius: 0.5rem; margin-bottom: 1rem; overflow: hidden; color: var(--chat-text-color);">
                        ${avatarHTML}
                        <div class="message-header" style="color: ${charColor.bold}; font-weight: bold; margin-bottom: 0.5rem;">${name}</div>
                        <div class="message-content" style="line-height: 1.5; white-space: pre-wrap;">${marked.parse(smartContent)}</div>
                    </div>`;
                });

                return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${title}</title>
    <style>
        ${cssVars}
        body { background-color: #0f172a; font-family: var(--font-primary); font-size: var(--text-size); padding: 2rem; max-width: 900px; margin: 0 auto; color: #cbd5e1; }
        a { color: var(--brand-color); }
        .dialogue-quote { color: inherit; filter: saturate(175%) opacity(75%) drop-shadow(1px 1px 5px black); font-weight: 500; }
        .message-content blockquote { border-left: 3px solid var(--brand-color); padding-left: 1rem; font-style: italic; background: rgba(0,0,0,0.2); padding: 0.5rem 1rem; border-radius: 0.25rem; }
        .message-content code { background-color: rgba(0,0,0,0.3); padding: 0.1em 0.3em; border-radius: 0.2rem; font-family: monospace; }
    </style>
</head>
<body>
    <h1 style="color: white; border-bottom: 1px solid #334155; padding-bottom: 1rem; margin-bottom: 2rem;">${title}</h1>
    <div id="chat-container">
        ${chatHTML}
    </div>
</body>
</html>`;
            },

            /**
             * Parses the new ZIP format (Import).
             * @param {JSZip} zip - The loaded ZIP object.
             * @param {File} file - The original file (unused but kept for signature).
             * @param {boolean} skipImages - Whether to skip importing images.
             * @returns {Promise<Object>} - The parsed story object.
             */
            async _parseStoryZip(zip, file, skipImages) {
                const jsonFile = zip.file("narrative.json");
                if (!jsonFile) throw new Error("ZIP does not contain 'narrative.json'.");
                const jsonStr = await jsonFile.async("string");
                const story = JSON.parse(jsonStr);

                // --- SAFE IMPORT: ID Remapping ---
                // We MUST generate new IDs for everything to prevent overwriting existing stories/characters
                // if the user imports a ZIP that originated from this same library.

                story.id = UTILITY.uuid();
                // Add timestamp to name to avoid confusion if same name exists
                // (Controller handles name dupe check too, but this helps)
                // story.name = `${story.name} (Imported)`; // Optional, let controller handle duplicate names

                const charIdMap = {};
                (story.characters || []).forEach(c => {
                    const oldId = c.id;
                    const newId = UTILITY.uuid();
                    c.id = newId;
                    charIdMap[oldId] = newId;
                });

                // Helper to remap IDs in history
                const remapHistory = (history) => {
                    if (!Array.isArray(history)) return;
                    history.forEach(msg => {
                        if (msg.character_id && charIdMap[msg.character_id]) {
                            msg.character_id = charIdMap[msg.character_id];
                        }
                    });
                };

                // Helper to remap active character IDs
                const remapActiveIds = (ids) => {
                    if (!Array.isArray(ids)) return ids;
                    return ids.map(id => charIdMap[id] || id);
                };

                // 1. Remap Scenarios
                (story.scenarios || []).forEach(s => {
                    s.id = UTILITY.uuid();
                    remapHistory(s.example_dialogue);
                    if (s.active_character_ids) {
                        s.active_character_ids = remapActiveIds(s.active_character_ids);
                    }
                });

                // 2. Remap Narratives (both stubs and full objects if present)
                // In ZIP export, 'narratives' are full objects.
                (story.narratives || []).forEach(n => {
                    n.id = UTILITY.uuid();
                    if (n.state) {
                        remapHistory(n.state.chat_history);
                        if (n.state.static_entries) {
                            n.state.static_entries.forEach(e => e.id = UTILITY.uuid());
                        }
                    }
                    if (n.active_character_ids) {
                        n.active_character_ids = remapActiveIds(n.active_character_ids);
                    }
                });

                // 3. Remap Dynamic Entries
                (story.dynamic_entries || []).forEach(e => e.id = UTILITY.uuid());

                // --- End ID Remapping ---

                // Process Images
                const manifestFile = zip.file("image_manifest.json");
                let imageManifest = {};
                if (manifestFile) {
                    try {
                        imageManifest = JSON.parse(await manifestFile.async("string"));
                    } catch (e) {
                        console.warn("Failed to parse image_manifest.json", e);
                    }
                }

                if (!skipImages) {
                    // We iterate sequentially to avoid memory spikes ("piecemeal" processing)
                    for (const [oldKey, path] of Object.entries(imageManifest)) {
                        const imgFile = zip.file(path);
                        if (imgFile) {
                            try {
                                const blob = await imgFile.async("blob");

                                // DETERMINE NEW KEY
                                let newKey = oldKey; // Default to old key (e.g. for non-ID keys)

                                // Check if oldKey contains a remapped Character ID
                                // key format: local_idb_UUID or just UUID
                                // We check against the keys of charIdMap
                                const matchingOldId = Object.keys(charIdMap).find(oid => oldKey.includes(oid));

                                if (matchingOldId) {
                                    // Replace the old ID part with the new ID
                                    newKey = oldKey.replace(matchingOldId, charIdMap[matchingOldId]);
                                } else if (oldKey === `bg_${story.id}` || oldKey.includes('bg_')) {
                                    // Handle background specific key logic if needed
                                    // But since we regenerated story.id at top, we just need to construct new key
                                    // Wait, we don't know the OLD story ID easily unless we parse it out.
                                    // If key is 'bg_OLDSTORYID', we want 'bg_NEWSTORYID'.
                                    // Heuristic: if it looks like a background key, assign it to current story
                                    if (oldKey.startsWith('bg_')) {
                                        newKey = `bg_${story.id}`;
                                    }
                                }

                                // Update the Story/Character reference to point to this new key
                                // Characters:
                                const relatedChar = story.characters.find(c => c.image_url === oldKey);
                                if (relatedChar) {
                                    relatedChar.image_url = newKey;
                                }

                                // Extra Portraits:
                                story.characters.forEach(c => {
                                    if (c.extra_portraits) {
                                        c.extra_portraits.forEach(p => {
                                            // emotion key: CHARID::emotion::EMOTION
                                            // Since we remapped c.id already, and matchingOldId logic above handles the key replacement...
                                            // The key in manifest is OLD key. 
                                            // The key in c.extra_portraits (if any) ? extra_portraits doesn't store keys usually, 
                                            // the logic constructs them dynamically: ID::emotion::Name.
                                            // So we just need to ensure the IMAGE is saved under the NEW ID-based key.
                                            // If newKey was correctly transformed using charIdMap replacement, we are good.
                                        });
                                    }
                                });

                                // Story Background:
                                if (story.backgroundImageURL === oldKey) {
                                    story.backgroundImageURL = newKey;
                                }

                                await DBService.saveImage(newKey, blob);

                            } catch (e) {
                                console.warn(`Failed to import image ${oldKey} from ${path}`, e);
                            }
                        }
                    }
                }

                return { story, imageBlob: null };
            },




            /**
             * Parses an Ellipsis JSON file.
             * @param {File} file - The JSON file.
             * @returns {Promise<Object>} - The parsed story object.
             * @private
             */
            async _parseEllipsisJSON(file) {
                const jsonString = await file.text();
                const story = JSON.parse(jsonString);
                if (!story.id || !story.name || !story.characters) throw new Error("Invalid Ellipsis JSON file.");

                story.id = UTILITY.uuid();

                // ID Remapping: Ensure unique IDs for imported characters to prevent collisions
                const charIdMap = {};
                (story.characters || []).forEach(c => {
                    const oldId = c.id;
                    const newId = UTILITY.uuid();
                    c.id = newId;
                    charIdMap[oldId] = newId;
                });

                // Helper to remap IDs in history
                const remapHistory = (history) => {
                    if (!Array.isArray(history)) return;
                    history.forEach(msg => {
                        if (msg.character_id && charIdMap[msg.character_id]) {
                            msg.character_id = charIdMap[msg.character_id];
                        }
                    });
                };

                // Scenario Updates: Update example dialogue references to match new character IDs
                (story.scenarios || []).forEach(s => {
                    s.id = UTILITY.uuid();
                    remapHistory(s.example_dialogue);
                    if (s.active_character_ids) {
                        s.active_character_ids = (s.active_character_ids || []).map(id => charIdMap[id] || id);
                    }
                });

                // Narrative Handling: Process both legacy stubs and full narrative objects for DB storage
                // We need to prepare them for the DB
                story.narratives.forEach(n => {
                    // Ensure ID is unique/remapped (already handled by ID remapping logic previously applied)
                    // We generate a new ID to ensure this imported narrative doesn't overwrite an existing one
                    n.id = UTILITY.uuid();

                    // If this is a FULL narrative (has state), we must allow it to be passed 
                    // back to the controller to be saved to the 'narratives' store.
                    // However, LibraryController.handleFileUpload expects the story object 
                    // to contain the full narratives in the .narratives array so it can loop and save them.

                    // 1. Remap Active Character IDs
                    if (n.active_character_ids) {
                        n.active_character_ids = (n.active_character_ids || []).map(id => charIdMap[id] || id);
                    }

                    // 2. Remap Chat History Character IDs
                    if (n.state?.chat_history) {
                        remapHistory(n.state.chat_history);
                    }

                    // Ensure IDs are consistent
                    if (n.state?.static_entries) {
                        n.state.static_entries.forEach(e => e.id = UTILITY.uuid());
                    }
                });

                (story.dynamic_entries || []).forEach(e => e.id = UTILITY.uuid());

                return { story, imageBlob: null };
            },

            /**
             * Parses a V2 Character Card (PNG).
             * @param {File} file - The PNG file.
             * @param {boolean} skipImages - Whether to skip image processing.
             * @returns {Promise<Object>} - The parsed story object.
             * @private
             */
            async _parseV2Card(file, skipImages) {
                const arrayBuffer = await file.arrayBuffer();
                const v2DataString = await this._extractV2Data(arrayBuffer);
                if (!v2DataString) throw new Error("No character data found in PNG file.");
                const v2RawData = JSON.parse(this._b64_to_utf8(v2DataString));
                const v2Data = v2RawData.data || v2RawData;
                let imageBlob = null;
                if (!skipImages) imageBlob = await ImageProcessor.processImageAsBlob(file);
                return { story: this._convertV2toEllipsis(v2Data), imageBlob };
            },

            /**
             * Parses a BYAF ZIP file.
             * @param {File} file - The ZIP file.
             * @param {boolean} skipImages - Whether to skip image processing.
             * @returns {Promise<Object>} - The parsed story object.
             * @private
             */
            async _parseBYAF(file, skipImages) {
                const zip = await JSZip.loadAsync(file);
                const characterFile = zip.file(/character\.json$/i)[0];
                const scenarioFile = zip.file(/scenario\d*\.json$/i)[0];
                const imageFile = zip.file(/\.png$/i)[0];
                if (!characterFile || !scenarioFile) throw new Error("Archive is missing character.json or scenario.json.");
                const byafData = {
                    character: JSON.parse(await characterFile.async('string')),
                    scenario: JSON.parse(await scenarioFile.async('string')),
                };
                let imageBlob = null;
                if (!skipImages && imageFile) {
                    const imageFileBlob = await imageFile.async('blob');
                    imageBlob = await ImageProcessor.processImageAsBlob(imageFileBlob);
                }
                // Check for Background Image (BYAF Only)
                let backgroundImageBlob = null;
                const bgFile = zip.file("images/story_background.png");
                if (bgFile) {
                    try {
                        const bgData = await bgFile.async('blob');
                        backgroundImageBlob = await ImageProcessor.processImageAsBlob(bgData);
                    } catch (e) { console.warn("Failed to extract BYAF background:", e); }
                }

                return { story: this._convertBYAFtoEllipsis(byafData), imageBlob };
            },

            /**
             * Converts BYAF data to Ellipsis format.
             * @param {Object} byafData - The BYAF data.
             * @returns {Object} - The Ellipsis story object.
             * @private
             */
            _convertBYAFtoEllipsis(byafData) {
                const { character, scenario } = byafData;
                const story = this._createEmptyEllipsisStory();
                story.name = character.displayName || character.name || "Imported Character";
                story.tags = character.tags || [];

                const userChar = { id: UTILITY.uuid(), name: "You", description: "The protagonist.", short_description: "User.", model_instructions: "Act as User.", is_user: true, is_active: true, image_url: '', tags: [], is_narrator: false };
                const aiChar = {
                    id: UTILITY.uuid(),
                    name: character.displayName || character.name,
                    description: character.persona || "",
                    short_description: (character.persona || "").split('.')[0] + '.',
                    model_instructions: scenario.formattingInstructions || "Act as {character}.",
                    image_url: '',
                    extra_portraits: [],
                    tags: character.tags || [],
                    is_user: false,
                    is_active: true,
                    is_narrator: false
                };

                story.characters = [userChar, aiChar];
                const nameToId = {
                    'user': userChar.id,
                    'character': aiChar.id,
                    [userChar.name.toLowerCase()]: userChar.id,
                    [aiChar.name.toLowerCase()]: aiChar.id
                };

                // Helper to get or create character ID for a name
                const resolveCharacter = (name) => {
                    const lower = name.toLowerCase();
                    if (nameToId[lower]) return nameToId[lower];

                    // Create Ghost
                    const newId = UTILITY.uuid();
                    const newChar = {
                        id: newId, name: name, description: "Imported character.", short_description: "Imported.",
                        model_instructions: `Act as ${name}.`, image_url: '', tags: [], is_user: false, is_active: true, is_narrator: false
                    };
                    story.characters.push(newChar);
                    nameToId[lower] = newId;
                    return newId;
                };

                // Parse Chat History / Examples
                const parseMessages = (msgs, isHidden) => {
                    const output = [];
                    if (!msgs) return output;

                    // BYAF/SillyTavern text format often is "Name: Message" or just Message
                    // If it's structured data (BYAF), it might have characterID or name fields?
                    // Standard BYAF scenario.exampleMessages is array of { text: "..." }

                    msgs.forEach(msg => {
                        let content = msg.text || "";
                        let charId = aiChar.id; // Default to main char

                        // Regex for "Name: Content" patterns common in logs
                        // We look for the start of the string
                        const match = content.match(/^(.+?):/);
                        if (match) {
                            const name = match[1].trim();
                            // Special BYAF placeholders
                            if (name === '#{user}' || name === '{{user}}') charId = userChar.id;
                            else if (name === '#{character}' || name === '{{char}}') charId = aiChar.id;
                            else {
                                // It's a named speaker (e.g. "Alice: Hello")
                                charId = resolveCharacter(name);
                            }
                            // Strip the prefix for clean display
                            content = content.substring(match[0].length).trim();
                        }

                        output.push({
                            character_id: charId,
                            content: content,
                            type: 'chat',
                            emotion: 'neutral',
                            timestamp: new Date().toISOString(),
                            isHidden: isHidden
                        });
                    });
                    return output;
                };

                const exampleDialogue = parseMessages(scenario.exampleMessages, true);

                // Static Entries
                const staticEntries = [];
                if (scenario.narrative) {
                    staticEntries.push({ id: UTILITY.uuid(), title: "Starting Scenario", content: scenario.narrative });
                }

                // Scenarios
                const activeIDs = story.characters.map(c => c.id);
                const firstMes = (scenario.firstMessages && scenario.firstMessages[0]?.text) || `The story of ${aiChar.name} begins.`;

                story.scenarios.push({
                    id: UTILITY.uuid(),
                    name: "Imported Start",
                    message: firstMes,
                    active_character_ids: activeIDs,
                    dynamic_entries: [], // (Populate from loreItems if present)
                    example_dialogue: exampleDialogue,
                    static_entries: staticEntries,
                    worldMap: { grid: UTILITY.createDefaultMapGrid(), currentLocation: { x: 4, y: 4 }, destination: { x: null, y: null }, path: [] },
                    prompts: UTILITY.getDefaultSystemPrompts()
                });

                // Narrative
                const narrative = this._createEmptyEllipsisNarrative("Imported Chat");
                narrative.active_character_ids = activeIDs;
                narrative.state.static_entries = JSON.parse(JSON.stringify(staticEntries));
                narrative.state.chat_history.push(...exampleDialogue);

                if (firstMes) {
                    narrative.state.chat_history.push({
                        character_id: aiChar.id,
                        content: firstMes,
                        type: 'chat',
                        emotion: 'neutral',
                        timestamp: new Date().toISOString(),
                        isHidden: false
                    });
                    narrative.state.messageCounter = 1;
                }

                // Lore Items (Dynamic Entries)
                if (character.loreItems) {
                    story.dynamic_entries = character.loreItems.map(item => ({
                        id: UTILITY.uuid(),
                        title: item.key || "Lore",
                        triggers: item.key || "",
                        content_fields: [item.value || ""],
                        current_index: 0,
                        triggered_at_turn: null
                    }));
                }

                story.narratives.push(narrative);
                return story;
            },

            /**
             * Converts V2 data to Ellipsis format.
             * @param {Object} v2Data - The V2 data.
             * @returns {Object} - The Ellipsis story object.
             * @private
             */
            _convertV2toEllipsis(v2Data) {
                const story = this._createEmptyEllipsisStory();
                story.name = v2Data.name || "Imported Character";
                story.tags = v2Data.tags || [];
                const userChar = { id: UTILITY.uuid(), name: "You", description: "The protagonist.", short_description: "The main character.", model_instructions: "Write a response for {user} in a creative and descriptive style.", is_user: true, is_active: true, image_url: '', tags: [], is_narrator: false };
                const aiChar = {
                    id: UTILITY.uuid(),
                    name: v2Data.name || "Imported Character",
                    ...UTILITY.getDefaultStorySettings(),
                    description: (v2Data.description || "").replace(/{{char}}/g, v2Data.name || "Imported Character").replace(/{{user}}/g, "{user}"),
                    short_description: (v2Data.description || "").split('.')[0] + '.',
                    model_instructions: (v2Data.system_prompt || "Act as {character}. Be descriptive and engaging.").replace(/{{char}}/g, "{character}").replace(/{{user}}/g, "{user}"),
                    image_url: '',
                    extra_portraits: [],
                    tags: v2Data.tags || [],
                    is_user: false,
                    is_active: true,
                    is_narrator: false
                };
                story.characters = [userChar, aiChar];
                const activeIDs = [userChar.id, aiChar.id];
                if (v2Data.character_book && v2Data.character_book.entries) {
                    story.dynamic_entries = v2Data.character_book.entries.map(entry => ({
                        id: UTILITY.uuid(),
                        title: (entry.keys || []).join(', ') || "Imported Lore",
                        triggers: (entry.keys || []).join(', '),
                        content_fields: [entry.content || ""],
                        current_index: 0,
                        triggered_at_turn: null
                    }));
                }
                const promptSnapshot = {
                    system_prompt: story.system_prompt,
                    event_master_base_prompt: story.event_master_base_prompt,
                    prompt_persona_gen: story.prompt_persona_gen,
                    prompt_world_map_gen: story.prompt_world_map_gen,
                    prompt_location_gen: story.prompt_location_gen,
                    prompt_entry_gen: story.prompt_entry_gen,
                    prompt_location_memory_gen: story.prompt_location_memory_gen,
                    font: story.font,
                    bubbleOpacity: story.bubbleOpacity,
                    chatTextColor: story.chatTextColor
                };
                const exampleDialogue = [];
                if (v2Data.mes_example) {
                    const charNameIdMap = { '{{user}}': userChar.id, '{{char}}': aiChar.id };
                    const regex = /({{user}}|{{char}}):([\s\S]*?)(?={{user}}:|{{char}}:|$)/g;
                    let cleanedText = v2Data.mes_example.replace(/<START>/g).trim();
                    for (const match of cleanedText.matchAll(regex)) {
                        const speakerPrefix = match[1];
                        const messageContent = match[2].trim().replace(/{{char}}/g, aiChar.name).replace(/{{user}}/g, "{user}");
                        const speakerId = charNameIdMap[speakerPrefix];
                        if (speakerId && messageContent) {
                            exampleDialogue.push({
                                character_id: speakerId,
                                content: messageContent,
                                type: 'chat',
                                isHidden: true,
                                timestamp: new Date().toISOString()
                            });
                        }
                    }
                }
                const allGreetings = [v2Data.first_mes || `The story of ${aiChar.name} begins.`];
                if (Array.isArray(v2Data.alternate_greetings)) allGreetings.push(...v2Data.alternate_greetings);

                // NEW: Parse V2 Scenario into Static Entry
                const staticEntries = [];
                if (v2Data.scenario) {
                    staticEntries.push({
                        id: UTILITY.uuid(),
                        title: "Imported Scenario",
                        content: v2Data.scenario.replace(/{{char}}/g, aiChar.name).replace(/{{user}}/g, "{user}")
                    });
                }

                story.scenarios = [];
                allGreetings.forEach((greeting, index) => {
                    const scenarioName = index === 0 ? "Imported Start" : `Alternate Start ${index}`;
                    const messageContent = (greeting || "").replace(/{{char}}/g, aiChar.name).replace(/{{user}}/g, "{user}");
                    story.scenarios.push({
                        id: UTILITY.uuid(),
                        name: scenarioName,
                        message: messageContent,
                        active_character_ids: activeIDs,
                        dynamic_entries: JSON.parse(JSON.stringify(story.dynamic_entries)),
                        prompts: JSON.parse(JSON.stringify(promptSnapshot)),
                        example_dialogue: JSON.parse(JSON.stringify(exampleDialogue)),
                        static_entries: JSON.parse(JSON.stringify(staticEntries)),
                        worldMap: { grid: UTILITY.createDefaultMapGrid(), currentLocation: { x: 4, y: 4 }, destination: { x: null, y: null }, path: [] }
                    });
                });
                const narrative = this._createEmptyEllipsisNarrative("Imported Chat");
                narrative.active_character_ids = activeIDs;
                narrative.state.static_entries = JSON.parse(JSON.stringify(staticEntries));
                if (exampleDialogue.length > 0) narrative.state.chat_history.push(...JSON.parse(JSON.stringify(exampleDialogue)));
                const firstScenario = story.scenarios[0];
                if (firstScenario && firstScenario.message) {
                    narrative.state.chat_history.push({
                        character_id: aiChar.id,
                        content: firstScenario.message,
                        type: 'chat',
                        isHidden: false,
                        timestamp: new Date().toISOString()
                    });
                    narrative.state.messageCounter = 1;
                }
                story.narratives.push(narrative);
                return story;
            },

            /**
             * Converts Ellipsis format to V2 data.
             * @param {Object} story - The story object.
             * @param {Object} narrative - The narrative object.
             * @param {string} primaryCharId - The ID of the primary character.
             * @returns {Object} - The V2 data object.
             * @private
             */
            _convertEllipsistoV2(story, narrative, primaryCharId) {
                const primaryChar = story.characters.find(c => c.id === primaryCharId);
                const activeIDs = narrative.active_character_ids || story.characters.map(c => c.id);
                const otherAiChars = story.characters.filter(c => !c.is_user && c.id !== primaryCharId && activeIDs.includes(c.id));
                if (!primaryChar) throw new Error("Primary character not found.");
                let fullDescription = primaryChar.description || "";
                if (otherAiChars.length > 0) {
                    fullDescription += "\n\n--- Other Characters ---\n";
                    otherAiChars.forEach(char => {
                        fullDescription += `\nName: ${char.name || 'Unnamed Character'}\nDescription: ${char.description || '(No description)'}\n`;
                    });
                }
                const bookEntries = [];
                let insertionCounter = 0;
                (story.dynamic_entries || []).forEach(entry => {
                    bookEntries.push({
                        keys: (entry.triggers || entry.title || "").split(',').map(t => t.trim()).filter(Boolean),
                        content: entry.content || "",
                        enabled: true, insertion_order: insertionCounter++, extensions: {}, case_sensitive: false,
                    });
                });
                (narrative.state.worldMap?.grid || []).filter(loc => loc.name).forEach(loc => {
                    bookEntries.push({
                        keys: [loc.name],
                        content: `Location Description: ${loc.description || '(No description)'}\n\nLocation Prompt: ${loc.prompt || '(No prompt)'}`,
                        enabled: true, insertion_order: insertionCounter++, extensions: {}, case_sensitive: false,
                    });
                });
                const currentLocCoords = narrative.state.worldMap?.currentLocation;
                if (currentLocCoords) {
                    const currentLocData = narrative.state.worldMap.grid.find(l => l.coords.x === currentLocCoords.x && l.coords.y === currentLocCoords.y);
                    if (currentLocData && currentLocData.local_static_entries) {
                        currentLocData.local_static_entries.forEach(entry => {
                            bookEntries.push({
                                keys: [(entry.title || "Local Lore").toLowerCase()],
                                content: entry.content || "",
                                enabled: true, insertion_order: insertionCounter++, extensions: {}, case_sensitive: false,
                            });
                        });
                    }
                }
                const replacePlaceholdersV2 = (text) => {
                    if (typeof text !== 'string') return '';
                    let processed = text.replace(/{character}/gi, '{{char}}');
                    processed = processed.replace(/{user}/gi, '{{user}}');
                    processed = processed.replace(/\{\{char\}\}/gi, '{{char}}');
                    processed = processed.replace(/\{\{user\}\}/gi, '{{user}}');
                    return processed;
                }
                const mesExample = (narrative.state.chat_history || []).filter(m => m.isHidden && m.type === 'chat').map(m => {
                    const speaker = story.characters.find(c => c.id === m.character_id);
                    if (speaker) {
                        const prefix = speaker.is_user ? '{{user}}:' : '{{char}}:';
                        return `${prefix}\n${replacePlaceholdersV2(m.content)}`;
                    }
                    return replacePlaceholdersV2(m.content);
                }).join('\n');
                const firstMessageEntry = (narrative.state.chat_history || []).find(m => !m.isHidden && m.type === 'chat');
                const firstMes = firstMessageEntry ? replacePlaceholdersV2(firstMessageEntry.content) : replacePlaceholdersV2(`The story of ${primaryChar.name} begins.`);
                const scenarioText = (narrative.state.static_entries || []).map(entry => `[${entry.title || 'Untitled Entry'}]\n${entry.content || '(No content)'}`).join('\n\n---\n\n');
                const v2Data = {
                    name: primaryChar.name || "",
                    description: replacePlaceholdersV2(fullDescription),
                    personality: "",
                    scenario: replacePlaceholdersV2(scenarioText),
                    first_mes: firstMes,
                    mes_example: mesExample,
                    creator_notes: "",
                    system_prompt: replacePlaceholdersV2(primaryChar.model_instructions || ""),
                    post_history_instructions: "",
                    alternate_greetings: [],
                    character_book: {
                        name: "", description: "", scan_depth: 100, token_budget: 2048, recursive_scanning: false, extensions: {}, entries: bookEntries
                    },
                    tags: primaryChar.tags || [],
                    creator: "", character_version: "", extensions: {}
                };
                return { spec: 'chara_card_v2', spec_version: '2.0', data: v2Data };
            },

            /**
             * Converts Ellipsis format to BYAF data.
             * @param {Object} story - The story object.
             * @param {Object} narrative - The narrative object.
             * @param {string} primaryCharId - The ID of the primary character.
             * @param {string} [imageFilename=null] - The filename of the character image.
             * @returns {Object} - The BYAF data object.
             * @private
             */
            /**
             * Converts Ellipsis format to BYAF data.
             * @param {Object} story - The story object.
             * @param {Object} narrative - The narrative object.
             * @param {string} primaryCharId - The ID of the primary character.
             * @param {string} [imageFilename=null] - The filename of the character image.
             * @returns {Object} - The BYAF data object.
             * @private
             */
            /**
             * Converts an Ellipsis story object to the BYAF (Backyard AI Format) structure.
             * @param {Object} story - The story object.
             * @param {Object} narrative - The narrative object.
             * @param {string} primaryCharId - The ID of the primary character.
             * @param {string|null} [imageFilename=null] - Optional filename for the character image.
             * @returns {Object} The BYAF manifest, character, and scenario objects.
             * @private
             */
            _convertEllipsistoBYAF(story, narrative, primaryCharId, imageFilename = null) {
                const primaryChar = story.characters.find(c => c.id === primaryCharId);
                if (!primaryChar) return { manifest: {}, character: {}, scenario: {} };
                const now = new Date().toISOString();
                const loreItems = [
                    ...(story.dynamic_entries || []),
                    ...(narrative.state.worldMap?.grid || []).filter(loc => loc.name).map(loc => ({
                        id: UTILITY.uuid(), title: loc.name, triggers: loc.name, content: `Description: ${loc.description || '(no description)'}\n\nPrompt: ${loc.prompt || '(no prompt)'}`
                    }))
                ].map((entry, index) => ({
                    id: entry.id || UTILITY.uuid(),
                    order: Math.random().toString(36).substring(2, 12),
                    key: entry.triggers || entry.title || `Imported Lore ${index + 1}`,
                    value: entry.content || "",
                    createdAt: entry.created_date || now,
                    updatedAt: entry.last_modified || now
                }));
                const character = {
                    schemaVersion: 1, name: primaryChar.name || "", displayName: primaryChar.name || "",
                    images: imageFilename ? [{ path: `images/${imageFilename}`, label: "" }] : [],
                    createdAt: primaryChar.created_date || now, updatedAt: primaryChar.last_modified || now,
                    id: primaryChar.id, isNSFW: false, persona: primaryChar.description || "", loreItems: loreItems, tags: primaryChar.tags || []
                };
                const firstMessageEntry = (narrative.state.chat_history || []).find(m => !m.isHidden && m.type === 'chat');
                const firstMessageText = firstMessageEntry ? firstMessageEntry.content : `The story of ${primaryChar.name} begins.`;
                const exampleMessages = (narrative.state.chat_history || []).filter(m => m.isHidden && m.type === 'chat').map(m => {
                    const speaker = story.characters.find(c => c.id === m.character_id);
                    let byafFormattedText = m.content || "";
                    let msgCharId = null;
                    if (speaker) {
                        if (speaker.is_user) {
                            byafFormattedText = `#{user}:\n${byafFormattedText}`;
                        } else if (speaker.id === primaryChar.id) {
                            byafFormattedText = `#{character}:\n${byafFormattedText}`;
                            msgCharId = primaryChar.id;
                        }
                    }
                    return { text: byafFormattedText, characterID: msgCharId };
                });
                const scenario = {
                    schemaVersion: 1, title: narrative.name || "Exported Scenario", canDeleteExampleMessages: true, exampleMessages: exampleMessages,
                    model: "", temperature: 1.0, topP: 0.9, minP: 0.1,
                    firstMessages: [{ text: firstMessageText, characterID: primaryChar.id }],
                    formattingInstructions: primaryChar.model_instructions || "", grammar: "", repeatPenalty: 1.05, repeatLastN: 256, topK: 30, minPEnabled: false,
                    narrative: (narrative.state.static_entries || []).map(e => e.content).join('\n\n'),
                    promptTemplate: null, messages: []
                };
                const manifest = {
                    schemaVersion: 1, createdAt: now, characters: [`characters/${primaryChar.id}/character.json`], scenarios: [`scenarios/scenario1.json`]
                };
                return { manifest, character, scenario };
            },

            /**
             * Creates an empty Ellipsis story object.
             * @returns {Object}
             * @private
             */
            _createEmptyEllipsisStory() {
                return {
                    id: UTILITY.uuid(), name: "New Imported Story", last_modified: new Date().toISOString(), created_date: new Date().toISOString(),
                    ...UTILITY.getDefaultApiSettings(), ...UTILITY.getDefaultUiSettings(), ...UTILITY.getDefaultSystemPrompts(),
                    characters: [], dynamic_entries: [], scenarios: [], narratives: []
                };
            },

            /**
             * Creates an empty Ellipsis narrative object.
             * @param {string} name - The narrative name.
             * @returns {Object}
             * @private
             */
            _createEmptyEllipsisNarrative(name) {
                return {
                    id: UTILITY.uuid(), name: name, last_modified: new Date().toISOString(),
                    state: {
                        chat_history: [], messageCounter: 0, static_entries: [],
                        worldMap: { grid: UTILITY.createDefaultMapGrid(), currentLocation: { x: 4, y: 4 }, destination: { x: null, y: null }, path: [] }
                    }
                };
            },

            _b64_to_utf8(str) { return decodeURIComponent(escape(atob(str))); },
            _utf8_to_b64(str) { return btoa(unescape(encodeURIComponent(str))); },

            /**
             * Extracts V2 data from a PNG buffer.
             * @param {ArrayBuffer} arrayBuffer - The PNG buffer.
             * @returns {Promise<string|null>} - The extracted data string or null.
             * @private
             */
            async _extractV2Data(arrayBuffer) {
                const dataView = new DataView(arrayBuffer);
                const PNG_SIGNATURE = [0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A];
                for (let i = 0; i < PNG_SIGNATURE.length; i++) { if (dataView.getUint8(i) !== PNG_SIGNATURE[i]) throw new Error("Invalid PNG signature."); }
                let offset = 8;
                while (offset < arrayBuffer.byteLength) {
                    const length = dataView.getUint32(offset);
                    const type = String.fromCharCode.apply(null, new Uint8Array(arrayBuffer, offset + 4, 4));
                    if (['tEXt', 'zTXt'].includes(type)) {
                        let keywordEnd = -1;
                        for (let i = 0; i < length; i++) { if (dataView.getUint8(offset + 8 + i) === 0) { keywordEnd = i; break; } }
                        if (keywordEnd !== -1) {
                            const keyword = new TextDecoder().decode(new Uint8Array(arrayBuffer, offset + 8, keywordEnd));
                            if (keyword === 'chara') {
                                if (type === 'tEXt') return new TextDecoder().decode(new Uint8Array(arrayBuffer, offset + 8 + keywordEnd + 1, length - keywordEnd - 1));
                                if (type === 'zTXt') return new TextDecoder().decode(pako.inflate(new Uint8Array(arrayBuffer, offset + 8 + keywordEnd + 2, length - keywordEnd - 2)));
                            }
                        }
                    }
                    if (type === 'IEND') break;
                    offset += 12 + length;
                }
                return null;
            },

            /**
             * Injects V2 data into a PNG buffer.
             * @param {ArrayBuffer} imageBuffer - The source PNG buffer.
             * @param {Object} v2Object - The V2 data object.
             * @returns {Promise<Uint8Array>} - The new PNG buffer.
             * @private
             */
            async _injectDataIntoPng(imageBuffer, v2Object) {
                const _CRC_TABLE = Array.from({ length: 256 }, (_, n) => { let c = n; for (let k = 0; k < 8; k++) c = (c & 1) ? (0xedb88320 ^ (c >>> 1)) : (c >>> 1); return c; });
                const _crc32 = (bytes) => { let crc = -1; for (const byte of bytes) crc = (crc >>> 8) ^ _CRC_TABLE[(crc ^ byte) & 0xff]; return (crc ^ -1) >>> 0; };
                const jsonDataString = JSON.stringify(v2Object);
                const base64Data = this._utf8_to_b64(jsonDataString);
                const base64Bytes = new TextEncoder().encode(base64Data);
                const compressedData = pako.deflate(base64Bytes);
                const keyword = 'chara';
                const keywordBytes = new TextEncoder().encode(keyword);
                const chunkData = new Uint8Array(keywordBytes.length + 1 + 1 + compressedData.length);
                chunkData.set(keywordBytes);
                chunkData[keywordBytes.length] = 0;
                chunkData[keywordBytes.length + 1] = 0;
                chunkData.set(compressedData, keywordBytes.length + 2);
                const chunkType = new TextEncoder().encode('zTXt');
                const dataForCrc = new Uint8Array(chunkType.length + chunkData.length);
                dataForCrc.set(chunkType);
                dataForCrc.set(chunkData, chunkType.length);
                const crc = _crc32(dataForCrc);
                const originalPng = new Uint8Array(imageBuffer);
                const dataView = new DataView(originalPng.buffer);
                let iendOffset = -1;
                let offset = 8;
                while (offset < originalPng.length) {
                    const length = dataView.getUint32(offset);
                    const type = String.fromCharCode.apply(null, originalPng.slice(offset + 4, offset + 8));
                    if (type === 'IEND') {
                        iendOffset = offset;
                        break;
                    }
                    offset += 12 + length;
                }
                if (iendOffset === -1) throw new Error('Could not find IEND chunk.');
                const newChunkLength = chunkData.length;
                const newPngSize = iendOffset + (12 + newChunkLength) + 12;
                const newPng = new Uint8Array(newPngSize);
                const newPngView = new DataView(newPng.buffer);
                newPng.set(originalPng.slice(0, iendOffset));
                let writeOffset = iendOffset;
                newPngView.setUint32(writeOffset, newChunkLength);
                writeOffset += 4;
                newPng.set(chunkType, writeOffset);
                writeOffset += chunkType.length;
                newPng.set(chunkData, writeOffset);
                writeOffset += chunkData.length;
                newPngView.setUint32(writeOffset, crc);
                writeOffset += 4;
                newPng.set(originalPng.slice(iendOffset, iendOffset + 12), writeOffset);
                return new Blob([newPng], { type: 'image/png' });
            }
        };

        /**
             * =================================================================================================
             * Reactive State Store
             * Wraps the application state in a Proxy to handle auto-saving and UI updates.
             * =================================================================================================
             */

        /**
         * ReactiveStore Module
         * Wraps the application state in a Proxy to enable reactive UI updates and auto-saving.
         * Intercepts property changes to trigger listeners and persistence logic.
         */
        const ReactiveStore = {
            state: null,
            _target: null,
            _listeners: new Map(),
            _proxyCache: new WeakMap(),
            _saveTimeout: null,
            _isSaving: false,
            _blockAutoSave: false, // New flag to prevent race conditions on reload

            /**
             * Initializes the reactive store with the given initial state.
             * Sets up auto-save triggers on visibility change and page unload.
             * @param {Object} initialState - The initial state object.
             */
            init(initialState) {
                this._target = initialState;
                this._listeners.clear();
                this._proxyCache = new WeakMap();
                this.state = this._createProxy(initialState);

                const saveNow = () => {
                    // Check if auto-save is blocked (e.g., during critical DB migrations or reloads)
                    if (this._blockAutoSave) return;

                    // If we are closing, trigger an immediate save without debounce
                    this.forceSave();
                };

                document.addEventListener('visibilitychange', () => {
                    if (document.visibilityState === 'hidden') saveNow();
                });
                window.addEventListener('pagehide', saveNow);
                window.addEventListener('beforeunload', saveNow);

                console.log("ReactiveStore: Initialized with Safety Nets.");
            },

            // New method to explicitly stop the auto-save mechanism
            blockAutoSave() {
                this._blockAutoSave = true;
                if (this._saveTimeout) {
                    clearTimeout(this._saveTimeout);
                    this._saveTimeout = null;
                }
            },

            /**
             * Subscribes a callback to changes in a specific state property.
             * @param {string} key - The state property key to observe.
             * @param {Function} callback - The callback function to execute on change.
             */
            subscribe(key, callback) {
                if (!this._listeners.has(key)) {
                    this._listeners.set(key, new Set());
                }
                this._listeners.get(key).add(callback);
            },

            /**
             * Creates a recursive proxy for the given target object.
             * @param {Object} target - The target object to proxy.
             * @param {string|null} [rootKey=null] - The root key for nested properties.
             * @returns {Proxy} - The reactive proxy.
             * @private
             */
            _createProxy(target, rootKey = null) {
                if (typeof target !== 'object' || target === null) return target;
                if (this._proxyCache.has(target)) return this._proxyCache.get(target);

                const handler = {
                    get: (obj, prop) => {
                        const value = obj[prop];
                        const nextRootKey = rootKey || (typeof prop === 'string' ? prop : null);
                        if (typeof value === 'object' && value !== null) {
                            return this._createProxy(value, nextRootKey);
                        }
                        return value;
                    },
                    set: (obj, prop, value) => {
                        if (obj[prop] === value) return true;
                        obj[prop] = value;
                        const notificationKey = rootKey || prop;
                        this._notify(notificationKey);
                        this._scheduleSave();
                        return true;
                    },
                    deleteProperty: (obj, prop) => {
                        delete obj[prop];
                        const notificationKey = rootKey || prop;
                        this._notify(notificationKey);
                        this._scheduleSave();
                        return true;
                    }
                };

                const proxy = new Proxy(target, handler);
                this._proxyCache.set(target, proxy);
                return proxy;
            },

            /**
             * Notifies listeners of a change in a state property.
             * @param {string} key - The key of the changed property.
             * @private
             */
            _notify(key) {
                if (this._listeners.has(key)) {
                    this._listeners.get(key).forEach(cb => cb(this.state[key]));
                }
            },

            /**
             * Pauses the auto-save mechanism (e.g., during streaming).
             */
            pauseSaving() {
                this._isSavingPaused = true;
                if (this._saveTimeout) {
                    clearTimeout(this._saveTimeout);
                    this._saveTimeout = null;
                }
            },

            /**
             * Resumes the auto-save mechanism and triggers an immediate save.
             */
            resumeSaving() {
                this._isSavingPaused = false;
                // Trigger one final save to catch up
                this.forceSave();
            },

            /**
             * Schedules a debounced save operation.
             * @private
             */
            _scheduleSave() {
                // If paused (streaming), DO NOT schedule a DB write
                if (this._isSavingPaused) return;
                if (this._blockAutoSave) return; // Respect block

                if (this._saveTimeout) clearTimeout(this._saveTimeout);
                this._saveTimeout = setTimeout(() => {
                    this.forceSave();
                }, 2000);
            },

            /**
             * Forces an immediate save of the current state to the database.
             * Resets any pending save timers.
             * @returns {Promise<void>}
             */
            async forceSave() {
                if (this._saveTimeout) {
                    clearTimeout(this._saveTimeout);
                    this._saveTimeout = null;
                }

                if (this._isSaving) return;
                // Even forceSave should respect the explicit block during critical transitions
                if (this._blockAutoSave) return;

                this._isSaving = true;

                try {
                    await StateManager.saveState();
                    console.log("ReactiveStore: State saved successfully.");
                } catch (err) {
                    console.error("ReactiveStore: Save failed", err);
                } finally {
                    this._isSaving = false;
                }
            },

            // Legacy compatibility
            persist() {
                this.forceSave();
            }
        };















        /**
     * =================================================================================================
     * UI Components (Pure Functions)
     * Reusable, sanitized HTML generators.
     * =================================================================================================
     */
        /**
         * UIComponents Module
         * A collection of pure functions that generate sanitized HTML for various UI elements.
         * Includes components for character tiles, message bubbles, story items, and more.
         */
        const UIComponents = {
            /**
             * Renders a single character card for the roster.
             */
            CharacterTile(char) {
                const tagsHTML = (char.tags || []).map(tag => DOM.html`<span class="bg-indigo-500/50 text-indigo-200 text-xs font-semibold mr-2 px-2.5 py-0.5 rounded">${tag}</span>`);
                const visualStyle = char.is_active ? "" : "opacity: 0.5; filter: grayscale(80%);";

                // FIX: Role-based Border Logic
                let roleBorderClass = 'border-gray-600'; // Default NPC (Subtle)
                let roleBadge = '';

                if (char.is_user) {
                    roleBorderClass = 'border-indigo-500 shadow-[0_0_10px_rgba(99,102,241,0.3)]';
                    roleBadge = DOM.unsafe('<div class="absolute top-2 left-2 bg-indigo-600/90 text-white text-[10px] font-bold px-2 py-0.5 rounded uppercase tracking-wider">User</div>');
                } else if (char.is_narrator) {
                    roleBorderClass = 'border-teal-500 shadow-[0_0_10px_rgba(20,184,166,0.3)]';
                    roleBadge = DOM.unsafe('<div class="absolute top-2 left-2 bg-teal-600/90 text-white text-[10px] font-bold px-2 py-0.5 rounded uppercase tracking-wider">Narrator</div>');
                }

                const activeBadge = char.is_active ? "" : DOM.unsafe('<div class="absolute top-2 right-2 bg-black/60 text-gray-300 text-xs px-2 py-1 rounded">Inactive</div>');

                // Standard gray silhouette icon (URL-Encoded SVG)
                const placeholder = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%234b5563' opacity='0.25'%3E%3Cpath d='M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z'/%3E%3C/svg%3E";

                const hasImage = UIManager.RUNTIME.characterImageCache[char.id] || (char.image_url && !char.image_url.startsWith('local_'));

                let rawUrl = hasImage ? (UIManager.RUNTIME.characterImageCache[char.id] || char.image_url) : placeholder;
                if (rawUrl) rawUrl = rawUrl.replace(/'/g, "%27");

                const bgImage = `url('${rawUrl}')`;
                const bgSize = 'cover';
                const bgRepeat = 'no-repeat';

                return DOM.html`
            <div data-action="open-character-detail" data-id="${char.id}" 
                 class="char-roster-btn bg-gray-800 ${roleBorderClass}" 
                 style="background-image: ${DOM.unsafe(bgImage)}; background-size: ${bgSize}; background-repeat: ${bgRepeat}; ${DOM.unsafe(visualStyle)}; border-width: 2px;">
                ${roleBadge}
                ${activeBadge}
                <div class="char-roster-content text-white">
                    <h3 class="font-bold text-lg truncate">${char.name}</h3>
                    <p class="text-sm text-gray-300 italic truncate">${char.short_description}</p>
                    <div class="mt-2 h-6 overflow-hidden">${tagsHTML}</div>
                </div>
            </div>
        `;
            },

            /**
             * Renders a single chat message bubble.
             * Handles Markdown parsing, newline preservation, and image embedding.
             */
            MessageBubble(msg, index, state) {
                if (msg.type === 'lore_reveal' || msg.isHidden) return '';

                if (msg.type === 'visual_event') {
                    const timestamp = msg.timestamp ? new Date(msg.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) : '';
                    return DOM.html`
                        <div class="chat-bubble-container w-full my-6 flex flex-col items-center animate-fade-in" data-message-index="${index}">
                            <div class="visual-event-card bg-gray-900 border border-gray-700 rounded-xl overflow-hidden max-w-lg w-full shadow-2xl relative group transform hover:scale-[1.01] transition-all duration-300">
                                <div class="absolute top-2 right-2 z-10 opacity-0 group-hover:opacity-100 transition-opacity flex space-x-2">
                                     <button onclick="NarrativeController.handleVisualAction('save', '${msg.image_key}')" class="bg-black/50 hover:bg-indigo-600 p-2 rounded-full text-white backdrop-blur-md transition-colors" title="Save to Device">
                                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path></svg>
                                     </button>
                                     <button onclick="NarrativeController.handleVisualAction('background', '${msg.image_key}')" class="bg-black/50 hover:bg-emerald-600 p-2 rounded-full text-white backdrop-blur-md transition-colors" title="Set as Background">
                                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"></path></svg>
                                     </button>
                                     <button data-action="confirm-delete-message" data-index="${index}" class="bg-black/50 hover:bg-red-500/80 p-2 rounded-full text-white backdrop-blur-md transition-colors" title="Delete">
                                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                                     </button>
                                </div>
                                <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-visual-key="${msg.image_key}" class="w-full h-auto object-cover min-h-[256px] bg-gray-800" alt="Generated Scene" onload="UIManager.hydrateVisualImage(this)">
                                <div class="p-4 bg-gradient-to-t from-gray-900 via-gray-900/80 to-transparent absolute bottom-0 w-full pt-12">
                                    <div class="flex items-end justify-between">
                                        <p class="text-white/90 text-sm font-serif italic drop-shadow-md line-clamp-3 hover:line-clamp-none transition-all cursor-help" title="${UTILITY.escapeHTML(msg.content)}">${msg.content}</p>
                                    </div>
                                </div>
                            </div>
                        </div>`;
                }

                if (msg.type === 'system_event') {
                    return DOM.html`<div class="w-full text-center my-2"><p class="text-sm italic text-gray-400">${msg.content}</p></div>`;
                }

                const character = state.characters.find(c => c.id === msg.character_id);
                if (!character) return '';

                const userChar = state.characters.find(c => c.is_user);
                const characterName = character.name;
                const userName = userChar ? userChar.name : 'You';

                const replacer = (text) => text.replace(/{character}/g, characterName).replace(/{user}/g, userName);

                // 1. Trim source to prevent initial whitespace issues
                let processedContent = replacer(msg.content).trim();

                // 2. Preserve Arbitrary Newlines (3 or more)
                // Standard Markdown collapses \n\n\n into a single paragraph break.
                // We replace 3+ newlines with explicit <br> tags so they render visually.
                processedContent = processedContent.replace(/\n{3,}/g, (match) => '<br>'.repeat(match.length));

                const styledContent = processedContent.replace(/(["][^"]*["])/g, `<span class="dialogue-quote">$1</span>`);

                // 3. Trim output HTML to remove the trailing newline that 'marked' adds
                let contentHTML = DOM.unsafe(marked.parse(styledContent || '').trim());

                // Styling
                let bubbleStyle = '';
                let characterNameColor = '';
                const imgSrc = UIManager.getPortraitSrc(character, msg.emotion);

                if (state.characterImageMode === 'bubble' && imgSrc) {
                    contentHTML = DOM.html`<img src="${imgSrc}" class="bubble-char-image cursor-pointer hover:opacity-90 transition-opacity" data-action="view-chat-image" data-src="${imgSrc}" title="View Full Size">${contentHTML}`;
                }

                const defaultColor = character.is_user
                    ? { base: '#4b5563', bold: '#e5e7eb' }
                    : { base: '#334155', bold: '#94a3b8' };

                const charColor = character.color || defaultColor;
                const topColor = UTILITY.hexToRgba(charColor.base, state.bubbleOpacity);
                const bottomColor = UTILITY.hexToRgba(UTILITY.darkenHex(charColor.base, 10), state.bubbleOpacity);

                bubbleStyle = `background-image: linear-gradient(to bottom, ${topColor}, ${bottomColor});`;
                characterNameColor = `style="color: ${charColor.bold};"`;

                const timestamp = msg.timestamp ? new Date(msg.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) : '';

                let imageGenBtn = '';
                try {
                    // Safe check for image gen and proper HTML wrapping
                    const allowImageGen = (typeof StateManager !== 'undefined' && StateManager.data && StateManager.data.globalSettings && StateManager.data.globalSettings.imageGenBackend !== 'disabled');

                    if (allowImageGen) {
                        imageGenBtn = `<button onclick="VisualMaster.triggerVisualEvent(${index}, this)" class="text-gray-400 hover:text-indigo-400" title="Generate Image"><svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"></path></svg></button>`;
                    }
                } catch (e) { console.warn("Chat Render Error (Image Gen):", e); }

                // HTML Container (Single line to prevent pre-wrap issues)
                return DOM.html`
            <div class="chat-bubble-container ${msg.isNew ? 'new-message' : ''}" data-message-index="${index}">
                <div class="bubble-header">
                     <p class="font-bold text-sm cursor-pointer hover:underline decoration-dotted underline-offset-4" 
                        ${DOM.unsafe(characterNameColor)}
                        data-action="open-character-detail" 
                        data-id="${character.id}"
                        title="Open Character Details">
                        ${character.name}
                     </p>
                     <span class="timestamp text-xs text-gray-500">${timestamp}</span>
                     <div class="action-btn-group flex ml-2 space-x-4">
                        ${DOM.unsafe(imageGenBtn)}
                        <button data-action="create-static-from-message" data-index="${index}" class="text-gray-400 hover:text-emerald-300" title="Create Static Memory"><svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"></path></svg></button>
                        <button data-action="chat-edit" data-index="${index}" class="text-gray-400 hover:text-white" title="Edit"><svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z"></path></svg></button>
                        <button data-action="confirm-delete-message" data-index="${index}" class="text-gray-400 hover:text-red-400" title="Delete"><svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg></button>
                    </div>
                </div>
                <div class="bubble-body rounded-lg px-3 py-2" style="${DOM.unsafe(bubbleStyle)}"><div id="message-content-${index}" class="whitespace-pre-wrap" style="color: ${state.chatTextColor}; font-family: ${state.font};">${contentHTML}</div></div></div>`;
            },

            /**
             * Renders a story item in the library list.
             */
            StoryListItem(story, isActive, separator) {
                const activeBadge = isActive ? DOM.html`<span class="text-xs text-indigo-300 font-bold">ACTIVE</span>` : '';
                return DOM.html`
            ${separator}
            <div class="p-4 rounded-lg flex justify-between items-center cursor-pointer ${isActive ? 'bg-indigo-600/30' : 'bg-gray-700/50 hover:bg-gray-600/50'}" data-action="open-story" data-id="${story.id}">
                <div>
                    <h3 class="font-semibold text-lg">${story.name || 'Untitled Story'}</h3>
                    <p class="text-sm text-gray-400">Modified: ${new Date(story.last_modified).toLocaleString()}</p>
                </div>
                ${activeBadge}
            </div>
        `;
            },


            /**
             * Renders a collapsible Scenario item for Story Details.
             */
            ScenarioItem(scenario, storyId) {
                const messageHTML = DOM.unsafe(marked.parse(scenario.message || '*(No message)*'));
                return DOM.html`
            <details open class="bg-gray-700/30 rounded-lg overflow-hidden group">
                <summary class="p-3 cursor-pointer hover:bg-gray-700/50 flex justify-between items-center font-semibold select-none">
                    <span>${scenario.name}</span>
                    <span class="text-xs text-gray-400 group-open:hidden"></span>
                    <span class="text-xs text-gray-400 hidden group-open:block"></span>
                </summary>
                <div class="p-3 bg-black/20 border-t border-gray-600 space-y-3">
                    <div>
                        <p class="text-xs text-gray-400 font-bold mb-1">First Message:</p>
                        <div class="text-sm text-gray-300 prose prose-invert prose-sm max-w-none">
                            ${messageHTML}
                        </div>
                    </div>
                    <div class="flex gap-2 justify-end pt-2">
                        <button data-action="load-scenario" data-story-id="${storyId}" data-scenario-id="${scenario.id}" class="bg-indigo-600 hover:bg-indigo-500 text-white text-xs font-bold py-1 px-3 rounded" title="Load Scenario">Load</button>
                        <button data-action="rename-scenario" data-story-id="${storyId}" data-scenario-id="${scenario.id}" class="bg-gray-600 hover:bg-gray-500 text-white text-xs font-bold py-1 px-3 rounded" title="Rename">Rename</button>
                        <button data-action="delete-scenario" data-story-id="${storyId}" data-scenario-id="${scenario.id}" class="text-xs bg-red-900/50 hover:bg-red-700/80 text-red-200 font-semibold py-2 px-3 rounded"" title="Delete">Delete</button>
                    </div>
                </div>
            </details>
        `;
            },

            /**
             * Renders a Narrative list item for Story Details.
             */
            NarrativeItem(narrative, storyId, isActive) {
                const activeBadge = isActive ? DOM.html`<span class="text-xs text-sky-300 font-bold flex-shrink-0">ACTIVE</span>` : '';

                // FIX: defensive date parsing
                let dateDisplay = 'Date unknown';
                if (narrative.last_modified) {
                    const dateObj = new Date(narrative.last_modified);
                    // Check if date is valid
                    if (!isNaN(dateObj.getTime())) {
                        dateDisplay = dateObj.toLocaleString();
                    }
                }

                return DOM.html`
            <div class="bg-gray-700/60 p-3 rounded-lg flex justify-between items-center gap-2">
                <div class="flex-grow min-w-0">
                    <p class="font-semibold truncate">${narrative.name}</p>
                    <p class="text-xs text-gray-400">Modified: ${dateDisplay}</p>
                </div>
                ${activeBadge}
                <div class="flex-shrink-0 flex items-center gap-2">
                    <button data-action="delete-narrative" data-story-id="${storyId}" data-narrative-id="${narrative.id}" class="text-xs bg-red-900/50 hover:bg-red-700/80 text-red-200 font-semibold py-2 px-3 rounded" title="Delete"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg></button>
                    <button data-action="elevate-narrative" data-story-id="${storyId}" data-narrative-id="${narrative.id}" class="text-teal-400 hover:text-teal-300 p-1" title="Elevate to Scenario"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 11l3-3m0 0l3 3m-3-3v8m0-13a9 9 0 110 18 9 9 0 010-18z"></path></svg></button>
                    <button data-action="duplicate-narrative" data-story-id="${storyId}" data-narrative-id="${narrative.id}" class="text-gray-400 hover:text-gray-300 p-1" title="Duplicate"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path></svg></button>
                    <button data-action="load-narrative" data-story-id="${storyId}" data-narrative-id="${narrative.id}" class="text-green-400 hover:text-green-300 p-1" title="Load Narrative"><svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20"><path d="M6.3 2.841A1.5 1.5 0 0 0 4 4.11V15.89a1.5 1.5 0 0 0 2.3 1.269l9.344-5.89a1.5 1.5 0 0 0 0-2.538L6.3 2.84Z"/></svg></button>
                </div>
            </div>
        `;
            },

            /** * Renders a dynamic content field editor.
             */
            DynamicContentField(content, index, entryId, totalCount) {
                const isLastField = index === totalCount - 1;
                const stickyNote = isLastField ? DOM.unsafe(`<span class="text-xs text-gray-400 italic ml-4">This entry will be used for all future triggers.</span>`) : '';
                const separator = index > 0 ? DOM.unsafe('<hr class="border-gray-700/50 my-2">') : '';

                return DOM.html`
            ${separator}
            <div class="bg-black/20 p-3 rounded-lg">
                <label class="font-bold mb-2 flex justify-between items-center">
                    <span>Step ${index + 1}</span>
                    ${stickyNote}
                </label>
                <div class="relative">
                    <textarea 
                        placeholder="All empty content fields will be removed when the modal is closed."
                        oninput="WorldController.updateDynamicContentField('${entryId}', ${index}, this.value)" 
                        class="w-full h-24 bg-gray-900/80 border-gray-600 p-2 resize-y rounded-md text-sm"
                    >${content}</textarea>
                    <button 
                        data-action="gen-dynamic-ai" data-id="${entryId}" data-index="${index}" 
                        class="absolute top-2 right-2 text-gray-500 hover:text-indigo-400 transition-colors" 
                        title="Generate with AI"
                    >${UIManager.getAIGenIcon()}</button>
                </div>
            </div>
        `;
            }
        };

        /**
         * =================================================================================================
         * UIManager Module (Phase 1-5 Complete & Refactored)
         * =================================================================================================
         */
        /**
         * UIManager Module
         * Orchestrates the rendering and interaction logic for the entire application.
         * Manages the chat window, character roster, library interface, and dynamic content.
         */
        const UIManager = {
            RUNTIME: {
                streamingInterval: null,
                titleTimeout: null,
                lastCinematicImageUrl: null,
                activeCinematicBg: 1,
                globalBackgroundImageCache: null,
                characterImageCache: {},
                worldImageCache: {},
                viewingStoryId: null // FIX: Track currently viewed story for layout switching
            },

            /**
             * Switches the active tab in the Knowledge Modal.
             * @param {string} tabName - The name of the tab to switch to ('static' or 'dynamic').
             */
            switchKnowledgeTab(tabName) {
                // We can just call the render function, as it reads the active tab from the Controller/State
                if (typeof AppController !== 'undefined') AppController.activeKnowledgeTab = tabName;
                this.renderKnowledgeModalTabs();
            },

            /**
             * Switches the active tab in the World Map Modal.
             * @param {string} tabName - The name of the tab to switch to ('move' or 'worldmap').
             */
            switchWorldMapTab(tabName) {
                if (typeof WorldController !== 'undefined') WorldController.RUNTIME.activeWorldMapTab = tabName;
                this.renderWorldMapModal();
            },

            /**
             * Returns the SVG icon for AI generation buttons.
             * @returns {string} - The SVG HTML string.
             */
            getAIGenIcon() {
                return DOM.unsafe(`<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path></svg>`);
            },

            /**
             * Checks if image generation is enabled globally.
             * @returns {boolean}
             */
            isImageGenEnabled() {
                // Safe access to StateManager
                if (typeof StateManager === 'undefined' || !StateManager.data || !StateManager.data.globalSettings) return true;
                return StateManager.data.globalSettings.imageGenBackend !== 'disabled';
            },

            /**
             * Opens the lightbox modal to view a chat image in full size.
             * @param {string} src - The source URL of the image.
             */
            viewChatImage(src) {
                // Reuse the lightbox modal structure but override the navigation
                const imgEl = document.getElementById('lightbox-image');
                const modal = document.getElementById('lightbox-modal');
                const prevBtn = modal.querySelector('button[data-action="lightbox-prev"]');
                const nextBtn = modal.querySelector('button[data-action="lightbox-next"]');
                const capEl = document.getElementById('lightbox-caption');

                if (imgEl) imgEl.src = src;
                if (capEl) capEl.textContent = ""; // No caption for raw chat images

                // Hide nav buttons since this is a single image view
                if (prevBtn) prevBtn.style.display = 'none';
                if (nextBtn) nextBtn.style.display = 'none';

                modal.classList.remove('hidden');
                modal.classList.add('flex');

                // Reset specific lightbox state so closing it works cleanly
                UIManager.RUNTIME.currentLightboxImages = [];
            },

            /**
             * Shows the confirmation modal with options for deleting a message.
             * Allows deleting a single message or all subsequent messages (forward).
             * @param {number} index - The index of the message to delete.
             */
            showDeleteMessageOptions(index) {
                const modal = document.getElementById('confirmation-modal');
                const messageEl = document.getElementById('confirmation-modal-message');
                const footerEl = modal.querySelector('.border-t'); // The footer div containing buttons

                if (!modal || !messageEl || !footerEl) return;

                messageEl.textContent = "How would you like to delete this message?";

                // FIX: Inject 3-Button Layout
                // We use flex-between and spacing to separate the destructive "Delete Forward"
                footerEl.innerHTML = `
            <div class="flex justify-between w-full items-center">
                <button onclick="AppController.closeModal('confirmation-modal')" class="bg-gray-600 hover:bg-gray-700 font-bold py-2 px-4 rounded-lg text-sm">Cancel</button>
                
                <div class="flex space-x-4">
                    <button onclick="NarrativeController.executeDelete(${index}, 'single')" class="bg-red-700 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg text-sm">Delete This One</button>
                    <button onclick="NarrativeController.executeDelete(${index}, 'forward')" class="bg-red-900 hover:bg-red-800 text-red-100 font-bold py-2 px-4 rounded-lg text-sm border border-red-500">Delete Forward &rarr;</button>
                </div>
            </div>
        `;

                AppController.openModal('confirmation-modal');
            },

            /**
             * Renders all main UI components to reflect the current state.
             * Updates characters, static entries, dynamic entries, chat, and AI selector.
             */
            renderAll() {
                const state = StateManager.getState();
                if (state && state.narrativeName) {
                    document.getElementById('story-title-input').value = state.narrativeName;
                    const mobileTitle = document.getElementById('mobile-story-title-overlay');
                    if (mobileTitle) mobileTitle.value = state.narrativeName;
                }
                this.renderCharacters();
                this.renderStaticEntries();
                this.renderDynamicEntries();
                this.renderChat();
                this.updateAICharacterSelector();
            },

            /**
             * Renders the Story Library interface with filtering and sorting.
             * @param {Object} [filterState={}] - Optional filter state overrides.
             */
            renderLibraryInterface(filterState = {}) {
                const library = StateManager.getLibrary();
                const container = document.getElementById('library-content-container');

                const searchInput = document.getElementById('lib-search');
                const sortInput = document.getElementById('lib-sort');
                const tagInput = document.getElementById('lib-tag');
                const listContainer = document.getElementById('lib-list');

                // 1. Determine Layout & Filter Values
                let { searchTerm, sortBy, filterTag, layout } = filterState;

                // Logic: Use passed layout if available, otherwise detect
                const isTallScreen = layout ? (layout === 'mobile') : (window.innerHeight > window.innerWidth);

                if (searchTerm === undefined && searchInput) searchTerm = searchInput.value;
                if (sortBy === undefined && sortInput) sortBy = sortInput.value;
                if (filterTag === undefined && tagInput) filterTag = tagInput.value;

                searchTerm = searchTerm || '';
                sortBy = sortBy || 'last_modified';
                filterTag = filterTag || '';

                // 2. Filter & Sort Logic
                let stories = [...library.stories];
                if (searchTerm) {
                    const lowerCaseSearch = searchTerm.toLowerCase();
                    stories = stories.filter(s => s.search_index && s.search_index.includes(lowerCaseSearch));
                }
                if (filterTag) {
                    const lowerFilter = filterTag.toLowerCase();
                    stories = stories.filter(s => {
                        const storyTags = new Set();
                        (s.tags || []).forEach(t => storyTags.add(t.toLowerCase()));
                        (s.characters || []).forEach(c => (c.tags || []).forEach(t => storyTags.add(t.toLowerCase())));
                        return storyTags.has(lowerFilter);
                    });
                }
                stories.sort((a, b) => {
                    if (sortBy === 'name') return (a.name || '').localeCompare(b.name || '');
                    if (sortBy === 'created_date') return new Date(b.created_date) - new Date(a.created_date);
                    return new Date(b.last_modified) - new Date(a.last_modified);
                });

                // 3. Generate List HTML
                // This creates a standard string of HTML
                const storyListHTML = stories.map((story, index) => {
                    const isActive = story.id === library.active_story_id;
                    const separator = index > 0 ? DOM.unsafe('<hr class="border-gray-700 my-2">') : '';
                    return UIComponents.StoryListItem(story, isActive, separator);
                }).join('');

                // Update Existing Frame (No wrapping needed, direct innerHTML assignment is safe here)
                // FIX: Check if layout structure matches before reusing existing frame
                const desktopDetailsPanel = document.getElementById('story-details-content-desktop');
                const isCurrentLayoutMobile = !desktopDetailsPanel; // If desktop panel is missing, we are in mobile structure
                const layoutMatches = (isTallScreen === isCurrentLayoutMobile);

                if (listContainer && searchInput && layoutMatches) {
                    listContainer.innerHTML = storyListHTML;
                    return;
                }

                // 4. Generate Full Frame (First Render or Layout Switch)
                const tagOptions = library.tag_cache.map(tag => DOM.html`<option value="${tag}" ${filterTag === tag ? 'selected' : ''}>${tag}</option>`);

                const controlsHTML = DOM.html`
            <div class="p-6 border-b border-gray-700 space-y-4">
                <input id="lib-search" type="search" placeholder="Search stories..." value="${searchTerm}" 
                    oninput="UIManager.renderLibraryInterface()" 
                    class="w-full bg-black/30 p-2 rounded-lg border-gray-600">
                <div class="flex space-x-4">
                    <select id="lib-sort" onchange="UIManager.renderLibraryInterface()" class="w-1/2 bg-black/30 p-2 rounded-lg border-gray-600">
                        <option value="last_modified" ${sortBy === 'last_modified' ? 'selected' : ''}>Modified</option>
                        <option value="name" ${sortBy === 'name' ? 'selected' : ''}>Name</option>
                        <option value="created_date" ${sortBy === 'created_date' ? 'selected' : ''}>Created</option>
                    </select>
                    <select id="lib-tag" onchange="UIManager.renderLibraryInterface()" class="w-1/2 bg-black/30 p-2 rounded-lg border-gray-600">
                        <option value="">All Tags</option>
                        ${tagOptions}
                    </select>
                </div>
            </div>`;

                // Sanitization: Wrap storyListHTML in DOM.unsafe() so the sanitizer treats it as HTML, not text
                if (isTallScreen) {
                    container.innerHTML = DOM.html`<div class="flex flex-col flex-grow min-h-0">${controlsHTML}<div id="lib-list" class="p-6 overflow-y-auto">${DOM.unsafe(storyListHTML)}</div></div>`.toString();
                } else {
                    container.innerHTML = DOM.html`
                <div class="w-[450px] flex-shrink-0 border-r border-gray-700 flex flex-col">${controlsHTML}<div id="lib-list" class="p-6 overflow-y-auto flex-grow">${DOM.unsafe(storyListHTML)}</div></div>
                <div id="story-details-content-desktop" class="flex-grow p-6 flex text-gray-500"><div class="w-full h-full flex items-center justify-center">Select a story to see details...</div></div>
            `.toString();
                }
            },

            /**
             * Opens the Story Details modal for a specific story.
             * Populates the modal with scenarios, narratives, and character carousel.
             * @param {string} storyId - The ID of the story to open.
             */
            openStoryDetails(storyId) {
                const library = StateManager.getLibrary();
                const story = library.stories.find(s => s.id === storyId);
                if (!story) return;

                // Track for layout switching
                UIManager.RUNTIME.viewingStoryId = storyId;

                const desktopContainer = document.getElementById('story-details-content-desktop');
                // FIX: Fallback to mobile modal if the desktop container is missing (e.g. transitional layout state)
                const isMobile = (window.innerHeight > window.innerWidth) || !desktopContainer;
                const targetModal = isMobile ? 'story-details-modal' : 'story-library-modal';

                // Componentize Scenarios
                const scenariosHTML = (story.scenarios || []).map(scenario =>
                    UIComponents.ScenarioItem(scenario, story.id)
                );

                // Componentize Narratives
                const narrativesHTML = (story.narratives || []).sort((a, b) => new Date(b.last_modified) - new Date(a.last_modified)).map(narrative => {
                    const isActive = (narrative.id === library.active_narrative_id && story.id === library.active_story_id);
                    return UIComponents.NarrativeItem(narrative, story.id, isActive);
                });

                const hasImages = (story.characters || []).some(c => UIManager.getPortraitSrc(c));

                const carouselHTML = hasImages ? DOM.html`
            <div class="relative w-full aspect-square bg-black/50 group cursor-pointer hover:opacity-90 transition-opacity" title="Click to view full image">
                 <div id="details-carousel" class="w-full h-full object-cover"></div>
                 <div class="absolute inset-0 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity pointer-events-none">
                    <svg class="w-12 h-12 text-white drop-shadow-lg" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0zM10 7v3m0 0v3m0-3h3m-3 0H7"></path></svg>
                 </div>
            </div>` : '';

                // Added 'pt-24' (Padding Top) if there are no images, so content doesn't hide behind the absolute header
                const contentPaddingClass = hasImages ? '' : 'pt-24';

                const detailsHTML = DOM.html`
            <div class="absolute top-0 left-0 right-0 z-20 p-4 flex justify-between items-center bg-gradient-to-b from-black/80 to-transparent" style="padding-top: calc(1rem + env(safe-area-inset-top));">
                <input type="text" 
                   value="${story.name}" 
                   oninput="LibraryController.updateStoryField('${story.id}', 'name', this.value)" 
                   class="text-xl font-bold bg-transparent border border-transparent hover:border-gray-600 focus:border-indigo-500 rounded px-2 py-1 text-white w-2/3 transition-colors focus:outline-none focus:bg-black/30 story-details-title-input"
                   placeholder="Story Title">
                
                <div class="story-details-title-balancer"></div>

                <div class="flex items-center space-x-2">
                    <button data-action="duplicate-story" data-id="${story.id}" class="bg-gray-700/50 hover:bg-gray-600/80 text-gray-300 hover:text-white p-2 rounded-lg transition-colors" title="Duplicate Story">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path></svg>
                    </button>
                    <button data-action="delete-story" data-id="${story.id}" class="text-xs bg-red-900/50 hover:bg-red-700/80 text-red-200 font-semibold py-2 px-3 rounded" title="Delete Story">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
                    </button>
                    <div class="w-px h-6 bg-gray-600/50 mx-2"></div>
                    <button data-action="close-modal" data-id="${targetModal}" class="story-details-close-btn bg-gray-700 hover:bg-gray-600 text-gray-300 hover:text-white p-2 rounded-lg transition-colors" title="Close">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                    </button>
                </div>
            </div>

            <div class="flex-grow overflow-y-auto min-h-0 details-scroll-container">
                
                ${carouselHTML}

                <div class="p-6 space-y-8 ${contentPaddingClass}">
                    
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                        <div>
                            <label class="text-sm text-gray-400 font-bold mb-1 block">Creator's Note</label>
                            <div class="relative">
                                <textarea oninput="LibraryController.updateStoryField('${story.id}', 'creator_notes', this.value)" class="w-full bg-black/30 border-gray-600 p-3 rounded-lg resize-none h-24 text-sm focus:ring-1 focus:ring-indigo-500 transition-all">${story.creator_notes || ''}</textarea>
                                <button data-action="gen-story-notes" data-id="${story.id}" class="absolute top-2 right-2 text-gray-500 hover:text-indigo-400 transition-colors" title="Generate with AI">${this.getAIGenIcon()}</button>
                            </div>
                        </div>
                        <div>
                            <label class="text-sm text-gray-400 font-bold mb-1 block">Tags</label>
                            <div class="relative">
                                <input type="text" value="${(story.tags || []).join(', ')}" oninput="LibraryController.updateStoryTags('${story.id}', this.value)" class="w-full bg-black/30 border-gray-600 p-3 rounded-lg text-sm focus:ring-1 focus:ring-indigo-500 transition-all">
                                <button data-action="gen-story-tags" data-id="${story.id}" class="absolute top-1/2 right-2 -translate-y-1/2 text-gray-500 hover:text-indigo-400 transition-colors" title="Generate with AI">${this.getAIGenIcon()}</button>
                            </div>
                        </div>
                    </div>

                    <hr class="border-gray-700">

                    <div>
                        <h4 class="font-bold text-lg mb-4 text-indigo-300 flex items-center">
                            <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10"></path></svg>
                            Scenarios (Templates)
                        </h4>
                        <div class="space-y-3">${scenariosHTML.length ? scenariosHTML : DOM.unsafe('<p class="text-sm text-gray-500 italic">No scenarios available.</p>')}</div>
                    </div>

                    <hr class="border-gray-700">

                    <div>
                        <h4 class="font-bold text-lg mb-4 text-sky-300 flex items-center">
                            <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 10h.01M12 10h.01M16 10h.01M9 16H5a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v8a2 2 0 01-2 2h-5l-5 5v-5z"></path></svg>
                            Narratives (Chats)
                        </h4>
                        <div class="space-y-2">${narrativesHTML.length ? narrativesHTML : DOM.unsafe('<p class="text-sm text-gray-500 italic">No narratives started. Load a scenario to begin.</p>')}</div>
                    </div>
                </div>
            </div>
        `;

                if (isMobile) {
                    document.querySelector('#story-details-modal > div:not(.modal-overlay)').innerHTML = detailsHTML.toString();
                    AppController.openModal('story-details-modal');
                } else {
                    const detailsWrapperHTML = DOM.html`
                <div class="w-full h-full flex flex-col md:-m-6 bg-gray-900 relative">
                    ${detailsHTML}
                </div>
            `;
                    document.getElementById('story-details-content-desktop').innerHTML = detailsWrapperHTML.toString();
                }

                if (hasImages) {
                    this.startCarousel(story.characters, 'details-carousel', story.id);
                }
            },

            /**
             * Starts the character image carousel for the story details modal.
             * @param {Array} characters - The list of characters in the story.
             * @param {string} containerId - The ID of the container element.
             * @param {string} storyId - The ID of the story.
             */
            startCarousel(characters, containerId, storyId) {
                if (ModalManager.RUNTIME.carousel_interval) clearInterval(ModalManager.RUNTIME.carousel_interval);

                const container = document.getElementById(containerId);
                if (!container) return;

                // Map characters to a clean object for the lightbox
                const imageData = (characters || []).map(c => {
                    const src = UIManager.getPortraitSrc(c);
                    return src ? { src, name: c.name } : null;
                }).filter(Boolean);

                if (imageData.length === 0) {
                    container.innerHTML = `<div class="w-full h-full flex items-center justify-center bg-gray-900 text-gray-500">No character images</div>`;
                    return;
                }

                // Cache this list for the lightbox
                UIManager.RUNTIME.currentLightboxImages = imageData;

                // If only 1 image, render static and do NOT start interval
                if (imageData.length === 1) {
                    container.innerHTML = `
                <img src="${imageData[0].src}" 
                     data-action="open-lightbox" 
                     data-index="0"
                     class="absolute inset-0 w-full h-full object-cover object-top" 
                     style="opacity: 1;">
            `;
                    return;
                }

                // Multiple images: Render two for crossfading
                container.innerHTML = `
            <img id="${containerId}-img1" data-action="open-lightbox" data-index="0" class="absolute inset-0 w-full h-full object-cover object-top transition-opacity duration-1000" style="opacity: 1;">
            <img id="${containerId}-img2" data-action="open-lightbox" data-index="0" class="absolute inset-0 w-full h-full object-cover object-top transition-opacity duration-1000" style="opacity: 0;">
        `;

                let currentIndex = 0;
                let activeImg = 1;
                const img1 = document.getElementById(`${containerId}-img1`);
                const img2 = document.getElementById(`${containerId}-img2`);

                img1.src = imageData[currentIndex].src;

                ModalManager.RUNTIME.carousel_interval = setInterval(() => {
                    currentIndex = (currentIndex + 1) % imageData.length;
                    const nextSrc = imageData[currentIndex].src;

                    // Update the hidden image source, then fade it in
                    if (activeImg === 1) {
                        img2.src = nextSrc;
                        img2.dataset.index = currentIndex; // Update index for lightbox
                        img1.style.opacity = 0;
                        img2.style.opacity = 1;
                        activeImg = 2;
                    } else {
                        img1.src = nextSrc;
                        img1.dataset.index = currentIndex; // Update index for lightbox
                        img1.style.opacity = 1;
                        img2.style.opacity = 0;
                        activeImg = 1;
                    }
                }, 4000);
            },

            /**
             * Opens the lightbox modal for a specific image index.
             * @param {number|string} index - The index of the image to show.
             */
            openLightbox(index) {
                const images = UIManager.RUNTIME.currentLightboxImages || [];
                if (images.length === 0) return;

                UIManager.RUNTIME.lightboxIndex = parseInt(index) || 0;
                this.updateLightboxDisplay();

                const modal = document.getElementById('lightbox-modal');
                modal.classList.remove('hidden');
                modal.classList.add('flex');
            },

            /**
             * Updates the lightbox image and caption based on the current index.
             */
            updateLightboxDisplay() {
                const images = UIManager.RUNTIME.currentLightboxImages || [];
                const index = UIManager.RUNTIME.lightboxIndex;
                const data = images[index];

                const imgEl = document.getElementById('lightbox-image');
                const capEl = document.getElementById('lightbox-caption');

                if (imgEl && data) imgEl.src = data.src;
                if (capEl && data) capEl.textContent = data.name;
            },

            /**
             * Navigates the lightbox to the next or previous image.
             * @param {number} direction - The direction to move (1 or -1).
             */
            navigateLightbox(direction) {
                const images = UIManager.RUNTIME.currentLightboxImages || [];
                if (images.length === 0) return;

                let newIndex = UIManager.RUNTIME.lightboxIndex + direction;
                if (newIndex >= images.length) newIndex = 0;
                if (newIndex < 0) newIndex = images.length - 1;

                UIManager.RUNTIME.lightboxIndex = newIndex;
                this.updateLightboxDisplay();
            },

            /**
             * Closes the lightbox modal.
             */
            closeLightbox() {
                const modal = document.getElementById('lightbox-modal');
                modal.classList.add('hidden');
                modal.classList.remove('flex');
            },

            /**
             * Renders the character roster in the sidebar.
             * Sorts characters by User, Active status, then Alphabetical.
             */
            renderCharacters() {
                const state = StateManager.getState();
                const container = document.getElementById('characters-container');
                if (!state.characters) {
                    container.innerHTML = '';
                    return;
                }

                // Sorting Logic: Prioritize User, then Active, then Alphabetical
                // 1. User First
                // 2. Active Next (Alphabetical)
                // 3. Inactive Last (Alphabetical)
                const sortedChars = [...state.characters].sort((a, b) => {
                    // Priority 1: User Character
                    if (a.is_user && !b.is_user) return -1;
                    if (!a.is_user && b.is_user) return 1;

                    // Priority 2: Active Status
                    if (a.is_active && !b.is_active) return -1;
                    if (!a.is_active && b.is_active) return 1;

                    // Priority 3: Alphabetical Name
                    const nameA = a.name || "";
                    const nameB = b.name || "";
                    return nameA.localeCompare(nameB);
                });

                container.innerHTML = sortedChars.map(UIComponents.CharacterTile).join('');
            },

            /**
             * Renders the tabs for the Knowledge Modal (Static vs Dynamic).
             */
            renderKnowledgeModalTabs() {
                const tabName = (typeof AppController !== 'undefined' && AppController.activeKnowledgeTab) ? AppController.activeKnowledgeTab : 'static';

                const staticTab = document.getElementById('knowledge-tab-static');
                const dynamicTab = document.getElementById('knowledge-tab-dynamic');
                const staticContent = document.getElementById('knowledge-static-content');
                const dynamicContent = document.getElementById('knowledge-dynamic-content');

                if (tabName === 'static') {
                    staticContent.classList.remove('hidden');
                    dynamicContent.classList.add('hidden');
                    staticTab.classList.add('border-indigo-500', 'text-white');
                    staticTab.classList.remove('border-transparent', 'text-gray-400');
                    dynamicTab.classList.add('border-transparent', 'text-gray-400');
                    dynamicTab.classList.remove('border-indigo-500', 'text-white');
                    this.renderStaticEntries();
                } else {
                    dynamicContent.classList.remove('hidden');
                    staticContent.classList.add('hidden');
                    dynamicTab.classList.add('border-indigo-500', 'text-white');
                    dynamicTab.classList.remove('border-transparent', 'text-gray-400');
                    staticTab.classList.add('border-transparent', 'text-gray-400');
                    staticTab.classList.remove('border-indigo-500', 'text-white');
                    this.renderDynamicEntries();
                }
            },

            switchKnowledgeTab(tabName) {
                // Helper to switch tabs without calling Controller directly
                if (typeof AppController !== 'undefined') AppController.activeKnowledgeTab = tabName;
                this.renderKnowledgeModalTabs();
            },

            switchWorldMapTab(tabName) {
                // Helper for World Map
                if (typeof WorldController !== 'undefined') WorldController.RUNTIME.activeWorldMapTab = tabName;
                this.renderWorldMapModal();
            },

            /**
             * Renders the list of static lore entries.
             */
            renderStaticEntries() {
                const state = StateManager.getState();
                const listHtml = (state.static_entries || []).map(entry => DOM.html`<div data-action="select-static-entry" data-id="${entry.id}" class="p-3 rounded-lg cursor-pointer ${state.selectedStaticEntryId === entry.id ? 'bg-indigo-600' : 'hover:bg-indigo-600/50'} mb-1"><h4 class="font-semibold truncate">${entry.title}</h4></div>`).join('');

                // Item 9 - Square Add Button at bottom
                const addButtonHtml = `<div class="mt-2 p-2 border-t border-gray-700"><button data-action="add-static-entry" class="w-full py-2 bg-gray-700 hover:bg-indigo-600 text-white rounded flex justify-center items-center transition-colors"><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"></path></svg></button></div>`;

                const container = document.getElementById('static-entries-list');
                // We need to target the parent to append the button outside the scroll area, or keep it inside. 
                // Given the HTML structure change in Modal, the 'static-entries-list' is the flex-grow area.
                // Let's put the button adjacent to the list.
                container.innerHTML = listHtml;

                // Append button to parent container of the list
                let parent = container.parentElement;
                let existingBtn = parent.querySelector('.knowledge-add-btn-container');
                if (existingBtn) existingBtn.remove();

                const btnDiv = document.createElement('div');
                btnDiv.className = 'knowledge-add-btn-container flex-shrink-0 bg-black/30 rounded-b-lg p-2';
                btnDiv.innerHTML = `<button data-action="add-static-entry" class="w-full py-2 bg-gray-700 hover:bg-indigo-600 text-white rounded flex justify-center items-center transition-colors"><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"></path></svg></button>`;
                parent.appendChild(btnDiv);

                this.renderStaticEntryDetails();
            },

            /**
             * Renders the details view for the selected static entry.
             */
            renderStaticEntryDetails() {
                const state = StateManager.getState();
                const container = document.getElementById('static-entry-details-content');
                const entry = (state.static_entries || []).find(e => e.id === state.selectedStaticEntryId);
                if (entry) {
                    container.innerHTML = DOM.html`
            <div class="flex flex-col h-full">
                <div class="flex justify-between items-center mb-4">
                    <input type="text" value="${entry.title}" oninput="WorldController.updateStaticEntryField('${entry.id}', 'title', this.value)" onblur="UIManager.renderStaticEntries()" class="text-xl font-bold bg-black/30 p-2 flex-grow rounded mr-2">
                    <button onclick="WorldController.convertStaticToDynamic('${entry.id}')" class="text-xs bg-indigo-600/80 hover:bg-indigo-500 text-white font-bold py-2 px-3 rounded flex-shrink-0" title="Convert to Dynamic Entry">
                        To Dynamic &rarr;
                    </button>
                </div>
                <div class="relative flex-grow">
                    <textarea oninput="WorldController.updateStaticEntryField('${entry.id}', 'content', this.value)" class="w-full h-full bg-black/30 p-4 resize-none rounded-md">${entry.content}</textarea>
                    <button data-action="gen-static-ai" data-id="${entry.id}" class="absolute top-2 right-2 text-gray-500 hover:text-indigo-400 transition-colors" title="Generate with AI">${this.getAIGenIcon()}</button>
                </div>
                <div class="flex justify-end mt-4 flex-shrink-0">
                    <button data-action="delete-static-entry" data-id="${entry.id}" class="text-sm bg-red-900/50 hover:bg-red-700/80 text-red-200 font-semibold py-2 px-3 rounded-lg">Delete</button>
                </div>
            </div>`.toString();
                } else {
                    container.innerHTML = `<div class="text-gray-400 flex items-center justify-center h-full">Select a static entry.</div>`;
                }
            },

            /**
             * Renders the list of dynamic lore entries.
             */
            renderDynamicEntries() {
                const state = StateManager.getState();
                // Ensure Robust ID Comparison (Convert to String) to handle legacy numeric IDs
                const listHtml = (state.dynamic_entries || []).map(entry => {
                    const isSelected = String(state.selectedDynamicEntryId) === String(entry.id);
                    return DOM.html`
                <div data-action="select-dynamic-entry" data-id="${entry.id}" 
                     class="p-3 rounded-lg cursor-pointer ${isSelected ? 'bg-indigo-600' : 'hover:bg-indigo-600/50'} flex justify-between items-center mb-1">
                    <h4 class="font-semibold truncate">${entry.title}</h4> 
                    ${entry.triggered_at_turn !== null ? DOM.unsafe('<span class="text-xs text-sky-300">ACTIVE</span>') : ''}
                </div>`;
                }).join('');

                const container = document.getElementById('dynamic-entries-list');
                container.innerHTML = listHtml;

                let parent = container.parentElement;
                let existingBtn = parent.querySelector('.knowledge-add-btn-container');
                if (existingBtn) existingBtn.remove();

                const btnDiv = document.createElement('div');
                btnDiv.className = 'knowledge-add-btn-container flex-shrink-0 bg-black/30 rounded-b-lg p-2';
                btnDiv.innerHTML = `<button data-action="add-dynamic-entry" class="w-full py-2 bg-gray-700 hover:bg-indigo-600 text-white rounded flex justify-center items-center transition-colors"><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"></path></svg></button>`;
                parent.appendChild(btnDiv);

                this.renderDynamicEntryDetails();
            },

            /**
             * Renders the details view for the selected dynamic entry.
             */
            renderDynamicEntryDetails() {
                const state = StateManager.getState();
                const container = document.getElementById('dynamic-entry-details-content');

                // FIX: Ensure Robust ID Comparison (Convert to String)
                const entry = (state.dynamic_entries || []).find(e => String(e.id) === String(state.selectedDynamicEntryId));

                if (entry) {
                    const contentFieldsHTML = (entry.content_fields || [""]).map((content, index) =>
                        UIComponents.DynamicContentField(content, index, entry.id, entry.content_fields.length)
                    );

                    container.innerHTML = DOM.html`<div class="flex flex-col h-full">
                <label class="font-bold text-sm text-gray-400">Title</label>
                <input type="text" value="${entry.title}" oninput="WorldController.updateDynamicEntryField('${entry.id}', 'title', this.value)" onblur="UIManager.renderDynamicEntries()" class="text-xl font-bold bg-black/30 p-2 w-full mb-4 rounded">
                
                <label class="font-bold mb-1 text-sm text-gray-400">Triggers (Keywords, AND, XOR, % Chance)</label>
                <input type="text" value="${entry.triggers}" oninput="WorldController.updateDynamicEntryField('${entry.id}', 'triggers', this.value)" placeholder="e.g. house, cat AND dog, 25%" class="bg-black/30 p-2 w-full mb-4 rounded">
                
                <div class="relative flex-grow flex flex-col">
                    <label class="font-bold mb-2 text-sm text-gray-400">Content Sequence</label>
                    <div class="space-y-2 overflow-y-auto pr-1">
                        ${contentFieldsHTML}
                    </div>
                    <div class="mt-2 flex justify-end">
                        <button 
                            data-action="add-dynamic-field" data-id="${entry.id}" 
                            class="bg-gray-700 hover:bg-indigo-600 text-white text-xs font-bold py-1 px-3 rounded transition-colors"
                        >
                            + Add Step
                        </button>
                    </div>
                </div>

                <div class="flex justify-end mt-4 border-t border-gray-700 pt-2">
                    <button data-action="delete-dynamic-entry" data-id="${entry.id}" class="text-xs bg-red-900/50 hover:bg-red-700/80 text-red-200 font-semibold py-2 px-3 rounded">Delete Entry</button>
                </div>
            </div>`.toString();
                } else {
                    container.innerHTML = `<div class="text-gray-400 flex items-center justify-center h-full">Select a dynamic entry.</div>`;
                }
            },

            /**
             * Helper to create the HTML for a single chat message.
             * @param {Object} msg - The message object.
             * @param {number} index - The index of the message.
             * @returns {string} - The HTML string.
             * @private
             */
            _createMessageHTML(msg, index) {
                const state = StateManager.getState();
                return UIComponents.MessageBubble(msg, index, state);
            },

            /**
             * Renders the main chat window.
             * Handles scrolling, cinematic mode, and message display.
             */
            renderChat() {
                // Hardened check to prevent blinking during streaming updates
                if (this.RUNTIME.suppressChatRender) return;

                const state = StateManager.getState();
                const chatWindow = document.getElementById('chat-window');


                // 1. Empty State Check
                if (!state || !state.chat_history) {
                    if (chatWindow) chatWindow.innerHTML = `<div class="h-full w-full flex items-center justify-center text-gray-500 text-lg">No Narrative Loaded</div>`;
                    return;
                }

                // 2. Optimization: Don't full-render if actively streaming text
                if (this.RUNTIME.streamingInterval) return;

                // 3. Update Mode & Portraits
                document.body.dataset.mode = state.characterImageMode;
                this.updateSidePortrait();

                // 4. Handle Cinematic Background Logic
                if (state.characterImageMode === 'cinematic_overlay') {
                    let latestAiImageUrl = null;

                    // Find the last valid AI image in history
                    for (let i = state.chat_history.length - 1; i >= 0; i--) {
                        const msg = state.chat_history[i];
                        if (!msg) continue; // Safety check
                        if (msg.type !== 'chat' || msg.isHidden) continue;

                        const speaker = state.characters.find(c => c.id === msg.character_id);
                        if (speaker && !speaker.is_user) {
                            const candidate = this.getPortraitSrc(speaker, msg.emotion);
                            if (candidate) { latestAiImageUrl = candidate; break; }
                        }
                    }

                    // Apply the image transition
                    if (latestAiImageUrl && latestAiImageUrl !== this.RUNTIME.lastCinematicImageUrl) {
                        this.RUNTIME.lastCinematicImageUrl = latestAiImageUrl;
                        const bg1 = document.getElementById('cinematic-bg-1');
                        const bg2 = document.getElementById('cinematic-bg-2');

                        if (this.RUNTIME.activeCinematicBg === 1) {
                            bg2.style.backgroundImage = `url('${latestAiImageUrl}')`;
                            bg1.style.opacity = 0;
                            bg2.style.opacity = 1;
                            this.RUNTIME.activeCinematicBg = 2;
                        } else {
                            bg1.style.backgroundImage = `url('${latestAiImageUrl}')`;
                            bg1.style.opacity = 1;
                            bg2.style.opacity = 0;
                            this.RUNTIME.activeCinematicBg = 1;
                        }
                    } else if (!latestAiImageUrl && this.RUNTIME.lastCinematicImageUrl) {
                        // Keep old image if no new one found, or handle specific fallback
                        const activeBg = document.getElementById(`cinematic-bg-${this.RUNTIME.activeCinematicBg}`);
                        if (activeBg) activeBg.style.backgroundImage = `url('${this.RUNTIME.lastCinematicImageUrl}')`;
                    }
                } else {
                    // Reset cinematic backgrounds if not in that mode
                    const bg1 = document.getElementById('cinematic-bg-1');
                    const bg2 = document.getElementById('cinematic-bg-2');
                    if (bg1) { bg1.style.backgroundImage = 'none'; bg1.style.opacity = '0'; }
                    if (bg2) { bg2.style.backgroundImage = 'none'; bg2.style.opacity = '0'; }
                    this.RUNTIME.lastCinematicImageUrl = null;
                    this.RUNTIME.activeCinematicBg = 1;
                }

                // 5. Generate HTML
                chatWindow.innerHTML = (state.chat_history || [])
                    .map((msg, index) => {
                        // Guard against undefined messages during array mutation (Undo/Splice)
                        if (!msg) return '';
                        return UIComponents.MessageBubble(msg, index, state);
                    })
                    .join('');

                // 6. Cleanup flags
                (state.chat_history || []).forEach(m => { if (m) m.isNew = false; });

                // 7. Scroll to bottom
                setTimeout(() => {
                    window.requestAnimationFrame(() => {
                        if (chatWindow) {
                            chatWindow.scrollTop = chatWindow.scrollHeight;
                        }
                    });
                }, 50);
            },

            /**
             * Renders the Example Dialogue modal content.
             */
            renderExampleDialogueModal() {
                const state = StateManager.getState();
                const container = document.getElementById('example-dialogue-container');
                if (!container) return;

                const userChar = state.characters.find(c => c.is_user);
                const aiChars = state.characters.filter(c => !c.is_user);
                const exampleMessages = state.chat_history.map((msg, index) => ({ ...msg, originalIndex: index })).filter(msg => msg.isHidden === true);

                if (exampleMessages.length === 0) {
                    container.innerHTML = `<div class="text-gray-400 text-center">No example dialogue found. Add a turn to start.</div>`;
                    return;
                }

                container.innerHTML = exampleMessages.map((msg, idx) => {
                    const speakerOptions = [userChar, ...aiChars].map(char => DOM.html`<option value="${char.id}" ${msg.character_id === char.id ? 'selected' : ''}>${char.name}</option>`);
                    return DOM.html`
                <div class="bg-black/20 p-4 rounded-lg flex items-center space-x-4">
                    <div class="flex flex-col space-y-2">
                        <button data-action="move-example-turn" data-index="${msg.originalIndex}" data-direction="up" ${idx === 0 ? 'disabled' : ''} class="bg-gray-600 hover:bg-gray-500 disabled:bg-gray-700 disabled:opacity-50 text-white font-bold p-2 rounded-lg" title="Move Up"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 15l7-7 7 7"></path></svg></button>
                        <button data-action="move-example-turn" data-index="${msg.originalIndex}" data-direction="down" ${idx === exampleMessages.length - 1 ? 'disabled' : ''} class="bg-gray-600 hover:bg-gray-500 disabled:bg-gray-700 disabled:opacity-50 text-white font-bold p-2 rounded-lg" title="Move Down"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg></button>
                    </div>
                    <div class="flex-grow flex flex-col space-y-2">
                        <select onchange="NarrativeController.updateExampleDialogueTurn(${msg.originalIndex}, 'character_id', this.value)" class="w-full bg-gray-700 border-gray-600 rounded p-2 text-sm">${speakerOptions}</select>
                        <textarea oninput="NarrativeController.updateExampleDialogueTurn(${msg.originalIndex}, 'content', this.value)" class="w-full bg-gray-900/80 border-gray-600 p-2 resize-none rounded-md">${msg.content}</textarea>
                    </div>
                    <button data-action="delete-example-turn" data-index="${msg.originalIndex}" class="text-xs bg-red-900/50 hover:bg-red-700/80 text-red-200 font-semibold py-2 px-3 rounded" title="Delete Turn"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg></button>
                </div>
            `;
                }).join('');

                const textareas = container.querySelectorAll('textarea');
                textareas.forEach(textarea => {
                    const autoResize = () => { textarea.style.height = 'auto'; textarea.style.height = `${textarea.scrollHeight}px`; };
                    textarea.addEventListener('input', autoResize);
                    setTimeout(autoResize, 0);
                });
            },

            /**
             * Updates the side portrait image based on the last speaker.
             */
            updateSidePortrait() {
                const state = StateManager.getState();
                const portraitContainer = document.getElementById('character-portrait-container');
                const chatWindow = document.getElementById('chat-window');
                const globalSettings = StateManager.data.globalSettings;

                // Check Layout Mode AND the User Preference
                const showPanel = globalSettings.showPortraitPanel !== false; // Default true

                // Vertical Layout (Mobile) always hides desktop portrait container
                if (document.body.classList.contains('layout-vertical')) {
                    if (portraitContainer) {
                        portraitContainer.style.display = 'none';
                        portraitContainer.innerHTML = '';
                    }
                    // Reset chat window styles for mobile to Defaults
                    if (chatWindow) {
                        chatWindow.style.width = '';
                        chatWindow.style.maxWidth = '';
                        chatWindow.style.margin = '';
                    }
                    return;
                }

                // Horizontal Layout (Desktop)
                if (portraitContainer && chatWindow) {
                    if (!showPanel) {
                        // If user disabled it, hide it and expand chat
                        portraitContainer.style.display = 'none';
                        portraitContainer.innerHTML = '';

                        // Adjust Chat Window to be centered and wider
                        chatWindow.style.width = '100%';
                        chatWindow.style.maxWidth = '900px'; // Prevent it from stretching too wide
                        chatWindow.style.margin = '0 auto';
                    } else {
                        // Restore default styles if enabled
                        portraitContainer.style.display = 'flex';

                        // Default horizontal layout style: 65% width, aligned next to portrait
                        chatWindow.style.width = '65%';
                        chatWindow.style.maxWidth = '100%';
                        chatWindow.style.margin = '0'; // IMPORTANT: Reset auto margin to align left
                    }
                }

                const lastChatMessages = (state.chat_history || [])
                    .filter(m => m.type === 'chat' && !m.isHidden && !state.characters.find(c => c.id === m.character_id)?.is_user);
                const lastSpeakerMsg = lastChatMessages.length ? lastChatMessages[lastChatMessages.length - 1] : null;
                const lastSpeaker = lastSpeakerMsg ? state.characters.find(c => c.id === lastSpeakerMsg.character_id) : null;

                if (!lastSpeaker) {
                    if (portraitContainer) portraitContainer.innerHTML = '';
                    return;
                }

                const mood = lastSpeakerMsg?.emotion || 'neutral';
                const portraitUrl = UIManager.getPortraitSrc(lastSpeaker, mood);

                if (!portraitUrl) {
                    if (portraitContainer) portraitContainer.innerHTML = '';
                    return;
                }

                if (portraitContainer) {
                    portraitContainer.innerHTML = DOM.html`<img src="${portraitUrl}" class="max-w-full max-h-full object-contain rounded-lg">`.toString();
                }
            },



            /**
             * Simulates a streaming response from the AI.
             * Updates the chat UI character by character.
             * @param {string} charId - The ID of the speaking character.
             * @param {string} fullText - The full text to stream.
             * @param {string} emotion - The emotion of the character.
             */
            startStreamingResponse(charId, fullText, emotion) {
                if (this.RUNTIME.streamingInterval) clearInterval(this.RUNTIME.streamingInterval);

                const state = ReactiveStore.state;
                const chatWindow = document.getElementById('chat-window');

                // 1. LOCK THE DB
                if (typeof ReactiveStore.pauseSaving === 'function') {
                    ReactiveStore.pauseSaving();
                }

                // 2. Create the "Empty" Message in State
                const messageIndex = state.chat_history.length;
                const newMessage = {
                    character_id: charId,
                    content: "",
                    type: 'chat',
                    emotion: emotion,
                    timestamp: new Date().toISOString(),
                    isNew: true
                };

                // Suppress full re-render (Prevent Start Blink)
                this.RUNTIME.suppressChatRender = true;
                state.chat_history.push(newMessage);
                this.RUNTIME.suppressChatRender = false;

                // Manually append the new bubble
                const newBubbleHTML = UIComponents.MessageBubble(newMessage, messageIndex, state);
                if (chatWindow) {
                    chatWindow.insertAdjacentHTML('beforeend', newBubbleHTML.toString());
                }

                // 3. Locate the DOM Element
                const messageContentEl = document.getElementById(`message-content-${messageIndex}`);
                const bubbleEl = messageContentEl ? messageContentEl.closest('.chat-bubble-container') : null;

                if (!messageContentEl) {
                    if (typeof ReactiveStore.resumeSaving === 'function') ReactiveStore.resumeSaving();
                    return;
                }

                // 4. The Animation Loop
                const words = fullText.split(/(\s+)/);
                let currentText = "";
                let wordIndex = 0;

                this.RUNTIME.streamingInterval = setInterval(() => {
                    if (wordIndex < words.length) {
                        currentText += words[wordIndex];

                        const styledContent = currentText.replace(/(["][^"]*["])/g, `<span class="dialogue-quote">$1</span>`);
                        const fullHTML = DOM.unsafe(marked.parse(styledContent || ''));

                        let finalHTML = fullHTML.toString();
                        const character = state.characters.find(c => c.id === charId);

                        if (state.characterImageMode === 'bubble' && character) {
                            const imgSrc = this.getPortraitSrc(character, emotion);
                            if (imgSrc) finalHTML = `<img src="${imgSrc}" class="bubble-char-image">${finalHTML}`;
                        }

                        messageContentEl.innerHTML = finalHTML;
                        wordIndex++;
                    } else {
                        // 5. FINISH: Commit Data
                        clearInterval(this.RUNTIME.streamingInterval);
                        this.RUNTIME.streamingInterval = null;

                        // FIX: Keep suppression ON during post-processing
                        this.RUNTIME.suppressChatRender = true;

                        // Update the TRUE state now that we are done
                        state.chat_history[messageIndex].content = fullText;
                        state.chat_history[messageIndex].isNew = false;

                        // Manually clean up the 'new-message' class from the DOM
                        // Since we are skipping the re-render, we must update the class manually
                        if (bubbleEl) bubbleEl.classList.remove('new-message');

                        // 6. UNLOCK DB (Triggers save, but render is still suppressed)
                        if (typeof ReactiveStore.resumeSaving === 'function') {
                            ReactiveStore.resumeSaving();
                        }

                        // Check for Dynamic Entries (May modify state)
                        // We keep suppression ON so if a lore entry is added, we don't blink the whole chat.
                        // Note: If a lore entry IS added, it won't appear until the next interaction. 
                        // This is a trade-off for smoothness, but acceptable for "hidden" lore. 
                        // If you want Lore Reveals to appear instantly, we would need to manually append them here too.
                        let structureChanged = false;
                        if (typeof NarrativeController !== 'undefined') {
                            structureChanged = NarrativeController.checkDynamicEntryTriggers();
                        }

                        // If dynamic entries modified the array structure (splicing out old entries),
                        // the DOM indices are now stale. We MUST force a re-render to align them.
                        if (structureChanged) {
                            this.RUNTIME.suppressChatRender = false;
                            this.renderChat(); // Force update to fix edit buttons
                        }

                        // Final Scroll Logic
                        // Final Scroll Logic
                        if (structureChanged) {
                            // If structure changed, DOM was rebuilt. Re-acquire bubble.
                            const msgEl = document.getElementById(`message-content-${messageIndex}`);
                            if (msgEl) bubbleEl = msgEl.closest('.chat-bubble-container');
                        }

                        if (bubbleEl) {
                            // Force alignment to the top of the message
                            // Use 'auto' (instant) to prevent browser fighting
                            window.requestAnimationFrame(() => {
                                bubbleEl.scrollIntoView({ behavior: 'auto', block: 'start' });
                                setTimeout(() => {
                                    this.RUNTIME.suppressChatRender = false;
                                }, 100);
                            });
                        } else {
                            this.RUNTIME.suppressChatRender = false;
                            const chatWindow = document.getElementById('chat-window');
                            if (chatWindow) chatWindow.scrollTop = chatWindow.scrollHeight;
                        }
                    }
                }, 5);
            },

            /**
             * Displays a typing indicator for a specific character.
             * @param {string} charId - The ID of the character thinking.
             * @param {string} [text="is thinking..."] - The text to display.
             * @param {string} [nameOverride=null] - Optional override for the character name (e.g. for Scriptwriter).
             */
            showTypingIndicator(charId, text = "is thinking...", nameOverride = null) {
                this.hideTypingIndicator();
                const chatWindow = document.getElementById('chat-window');
                const state = StateManager.getState();
                const character = (state.characters || []).find(c => c.id === charId);
                const name = nameOverride || character?.name || 'System';

                // Color Logic
                const defaultColor = (character && character.is_user)
                    ? { base: '#4b5563', bold: '#e5e7eb' }
                    : { base: '#334155', bold: '#94a3b8' };

                const charColor = (character && character.color) ? character.color : defaultColor;
                const bubbleOpacity = state.bubbleOpacity !== undefined ? state.bubbleOpacity : 0.95;

                const topColor = UTILITY.hexToRgba(charColor.base, bubbleOpacity);
                const bottomColor = UTILITY.hexToRgba(UTILITY.darkenHex(charColor.base, 10), bubbleOpacity);

                const bubbleStyle = `background-image: linear-gradient(to bottom, ${topColor}, ${bottomColor});`;
                const nameStyle = `color: ${charColor.bold};`;
                const textStyle = `color: ${state.chatTextColor || '#e5e7eb'};`;

                const indicator = document.createElement('div');
                indicator.id = 'typing-indicator';

                indicator.className = 'chat-bubble-container';
                indicator.innerHTML = DOM.html`
            <div class="mb-4 flex flex-col items-start">
                <p class="font-bold text-sm mb-1" style="${DOM.unsafe(nameStyle)}">${name}</p>
                <div class="p-3 rounded-lg typing-bubble-pulse" style="${DOM.unsafe(bubbleStyle)}">
                    <p class="italic" style="${DOM.unsafe(textStyle)}">${text}</p>
                </div>
            </div>`.toString();

                chatWindow.appendChild(indicator);
                chatWindow.scrollTop = chatWindow.scrollHeight;
            },

            /**
             * Hides the current typing indicator.
             */
            hideTypingIndicator() {
                const el = document.getElementById('typing-indicator');
                if (el) el.remove();
            },

            /**
             * Applies global styling based on the current state.
             * Updates background images, blur, fonts, and colors.
             */
            applyStyling() {
                const state = StateManager.getState();
                const backgroundElement = document.getElementById('global-background');

                // 1. Handle Background Image Logic
                let backgroundUrl = '';

                // Priority 1: Location Image (World Map)
                if (state.worldMap && state.worldMap.grid.length > 0 && state.worldMap.currentLocation) {
                    const currentLoc = state.worldMap.grid.find(loc => loc.coords.x === state.worldMap.currentLocation.x && loc.coords.y === state.worldMap.currentLocation.y);
                    if (currentLoc) {
                        const locationKey = `location::${currentLoc.coords.x},${currentLoc.coords.y}`;
                        UIManager.RUNTIME.worldImageCache = UIManager.RUNTIME.worldImageCache || {};

                        if (UIManager.RUNTIME.worldImageCache[locationKey]) {
                            backgroundUrl = UIManager.RUNTIME.worldImageCache[locationKey];
                        }
                        else if (currentLoc.imageUrl && !currentLoc.imageUrl.startsWith('local_idb_location')) {
                            backgroundUrl = currentLoc.imageUrl;
                        }
                        // HYDRATION FIX: If it SHOULD be a local IDB image, but it's not in cache, fetch it.
                        else if (currentLoc.imageUrl && currentLoc.imageUrl.startsWith('local_idb_location')) {
                            // Trigger async load, but don't block render.
                            // Pass the *stored* key (e.g. local_idb_location::4,4) to the hydration helper
                            // The helper expects the raw IDB key, which is "location::4,4" usually?
                            // Let's check how we save it. 
                            // In WorldController.handleWorldMapLocationImageUpload: 
                            // locationKey = `location::${x},${y}`;
                            // location.imageUrl = `local_idb_location::${x},${y}`;
                            // So we strip the prefix.
                            this.hydrateLocationImage(currentLoc.imageUrl);
                        }
                    }
                }

                // Priority 2: Story Setting
                // Only use the cache if the setting explicitly requests the local IDB image.
                // Logic: If Priority 1 set a backgroundUrl, we should skip this block.

                if (!backgroundUrl) {
                    // Handle any local_idb_ prefix by checking the cache
                    if (state.backgroundImageURL && state.backgroundImageURL.startsWith('local_idb_')) {
                        if (UIManager.RUNTIME.globalBackgroundImageCache) {
                            backgroundUrl = UIManager.RUNTIME.globalBackgroundImageCache;
                        }
                    }
                    else if (state.backgroundImageURL) {
                        backgroundUrl = state.backgroundImageURL;
                    }
                }

                if (backgroundElement) {
                    backgroundElement.style.backgroundImage = backgroundUrl ? `url('${backgroundUrl}')` : 'none';
                }

                // 2. Handle Base UI Settings
                document.getElementById('app-container').style.backdropFilter = `blur(${state.backgroundBlur || 0}px)`;
                document.documentElement.style.setProperty('--chat-font-size', `${state.textSize || 16}px`);
                document.documentElement.style.setProperty('--bubble-image-size', `${state.bubbleImageSize || 100}px`);

                // 3. Calculate Border Hue from Text Color
                const hexToRgb = (hex) => {
                    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                    return result ? {
                        r: parseInt(result[1], 16),
                        g: parseInt(result[2], 16),
                        b: parseInt(result[3], 16)
                    } : null;
                };

                const rgb = hexToRgb(state.chatTextColor);
                if (rgb) {
                    document.documentElement.style.setProperty('--border-hue-color', `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.4)`);
                }

                document.documentElement.style.setProperty('--chat-text-color', state.chatTextColor);
                document.documentElement.style.setProperty('--chat-font-family', state.font);

                // 4. Sync Titles
                const storyTitleInput = document.getElementById('story-title-input');
                const mobileStoryTitleOverlay = document.getElementById('mobile-story-title-overlay');
                if (storyTitleInput) {
                    storyTitleInput.style.color = state.chatTextColor;
                    storyTitleInput.style.fontFamily = state.font;
                }
                if (mobileStoryTitleOverlay) {
                    mobileStoryTitleOverlay.style.color = state.chatTextColor;
                    mobileStoryTitleOverlay.style.fontFamily = state.font;
                }

                // 5. Apply Markdown Colors & Fonts
                const defaults = UTILITY.getDefaultUiSettings();
                const root = document.documentElement;
                const chatFont = state.font || defaults.font;

                // Colors
                root.style.setProperty('--md-h1-color', state.md_h1_color || defaults.md_h1_color);
                root.style.setProperty('--md-h2-color', state.md_h2_color || defaults.md_h2_color);
                root.style.setProperty('--md-h3-color', state.md_h3_color || defaults.md_h3_color);
                root.style.setProperty('--md-bold-color', state.md_bold_color || defaults.md_bold_color);
                root.style.setProperty('--md-italic-color', state.md_italic_color || defaults.md_italic_color);
                root.style.setProperty('--md-quote-color', state.md_quote_color || defaults.md_quote_color);

                // Fonts (Fallback to chat font if empty)
                root.style.setProperty('--md-h1-font', state.md_h1_font || chatFont);
                root.style.setProperty('--md-h2-font', state.md_h2_font || chatFont);
                root.style.setProperty('--md-h3-font', state.md_h3_font || chatFont);
                root.style.setProperty('--md-bold-font', state.md_bold_font || chatFont);
                root.style.setProperty('--md-italic-font', state.md_italic_font || chatFont);
                root.style.setProperty('--md-quote-font', state.md_quote_font || chatFont);

                // Smart Quote Logic
                // If the user is using the default color (#9ca3af), we use the original "Filter" style (inherit + opacity/saturation).
                // If the user picked a CUSTOM color, we disable the filter so the color appears exactly as chosen.
                const defaultQuoteColor = '#9ca3af';
                const isDefaultQuote = (state.md_quote_color || defaultQuoteColor).toLowerCase() === defaultQuoteColor.toLowerCase();

                if (isDefaultQuote) {
                    // Restore original cinematic look
                    root.style.setProperty('--active-quote-color', 'inherit');
                    root.style.setProperty('--active-quote-filter', 'saturate(175%) opacity(75%) drop-shadow(1px 1px 5px black)');
                } else {
                    // Use exact user color with a standard shadow (no opacity/saturation filter)
                    root.style.setProperty('--active-quote-color', state.md_quote_color);
                    root.style.setProperty('--active-quote-filter', 'drop-shadow(1px 1px 2px rgba(0,0,0,0.5))');
                }

                this.renderChat();
            },



            /**
             * Hydrates a location image from IndexDB into the runtime cache.
             * @param {string} locationUrl - The stored image URL (e.g. 'local_idb_location::4,4').
             */
            async hydrateLocationImage(locationUrl) {
                if (!locationUrl || !locationUrl.startsWith('local_idb_')) return;

                // key logic: remove the prefix?
                // In handleWorldMapLocationImageUpload: 
                // key = `location::${x},${y}`
                // saved url = `local_idb_location::${x},${y}`
                // So key = locationUrl.replace('local_idb_', '')

                const key = locationUrl.replace('local_idb_', ''); // "location::4,4"

                // Avoid double fetching
                UIManager.RUNTIME.worldImageCache = UIManager.RUNTIME.worldImageCache || {};
                if (UIManager.RUNTIME.worldImageCache[key]) return; // Already in cache

                try {
                    const blob = await DBService.getImage(key);
                    if (blob) {
                        const url = URL.createObjectURL(blob);
                        UIManager.RUNTIME.worldImageCache[key] = url;
                        // Re-apply styling to update the background immediately
                        this.applyStyling();

                        // Also re-render map execution if open (optional but nice)
                        // If map modal is open, re-render it
                        const mapModal = document.getElementById('world-map-modal');
                        if (mapModal && !mapModal.classList.contains('hidden')) {
                            this.renderWorldMapModal();
                        }
                    }
                } catch (e) {
                    console.warn("Hydration failed for", locationUrl, e);
                }
            },

            /**
             * Renders the World Map modal content.
             * Handles both "Move" and "World Map" (Edit) tabs.
             */
            renderWorldMapModal() {
                const state = StateManager.getState();
                const activeWorldMapTab = (typeof WorldController !== 'undefined') ? WorldController.RUNTIME.activeWorldMapTab : 'move';
                const pendingMove = (typeof WorldController !== 'undefined') ? WorldController.RUNTIME.pendingMove : null;
                const { worldMap } = state;
                const container = document.getElementById('world-map-modal-content');

                let contentHTML = '';
                // Only use columns for "Move" tab. "World Map" tab is now full width grid.
                const gridLayoutClass = activeWorldMapTab === 'move' ? 'grid-cols-1 md:grid-cols-3' : 'grid-cols-1';

                if (activeWorldMapTab === 'move') {
                    // --- MOVE TAB LOGIC (Unchanged) ---
                    const { currentLocation } = worldMap;
                    let moveGridHTML = '';
                    // Generate 3x3 Grid centered on player
                    for (let y = currentLocation.y - 1; y <= currentLocation.y + 1; y++) {
                        for (let x = currentLocation.x - 1; x <= currentLocation.x + 1; x++) {
                            const isCenter = x === currentLocation.x && y === currentLocation.y;
                            const location = worldMap.grid.find(loc => loc.coords.x === x && loc.coords.y === y);
                            let imageSrc = '';
                            if (location) {
                                const locationKey = `location::${x},${y}`;
                                UIManager.RUNTIME.worldImageCache = UIManager.RUNTIME.worldImageCache || {};
                                if (UIManager.RUNTIME.worldImageCache[locationKey]) imageSrc = UIManager.RUNTIME.worldImageCache[locationKey];
                                else if (location.imageUrl && !location.imageUrl.startsWith('local_idb_location')) imageSrc = location.imageUrl;
                            }
                            const bgImage = imageSrc ? `background-image: url('${imageSrc}');` : '';
                            let classList = ['aspect-square', 'rounded-lg', 'flex', 'items-center', 'justify-center', 'text-center', 'p-2', 'text-white', 'relative', 'overflow-hidden', 'bg-cover', 'bg-center', 'transition-all'];

                            if (isCenter) classList.push('bg-indigo-800/80', 'ring-2', 'ring-indigo-300');
                            else if (location) {
                                // If we have a background image, don't use the opaque gray background.
                                // Use a transparent black overlay to ensure text contrast if needed, but let the image shine.
                                if (imageSrc) classList.push('bg-black/20', 'cursor-pointer', 'hover:ring-2', 'hover:ring-sky-400');
                                else classList.push('bg-gray-700/80', 'cursor-pointer', 'hover:ring-2', 'hover:ring-sky-400');
                            }
                            else classList.push('bg-black/50');

                            if (pendingMove && pendingMove.x === x && pendingMove.y === y && !isCenter) classList.push('ring-4', 'ring-yellow-400');

                            if (location) {
                                const displayName = (location.name && location.name !== 'Undefined') ? location.name : '';
                                moveGridHTML += DOM.html`<div class="${classList.join(' ')}" style="${DOM.unsafe(bgImage)}" ${!isCenter ? DOM.unsafe(`data-action="select-pending-move" data-x="${x}" data-y="${y}"`) : ''}><div class="absolute inset-0 bg-gradient-to-t from-black/80 to-transparent"></div>${displayName ? DOM.html`<span class="relative z-10 text-sm font-bold">${displayName}</span>` : ''}</div>`.toString();
                            } else {
                                moveGridHTML += DOM.html`<div class="${classList.join(' ')}"></div>`.toString();
                            }
                        }
                    }

                    let detailsHTML = '';
                    const pendingLocation = pendingMove ? worldMap.grid.find(l => l.coords.x === pendingMove.x && l.coords.y === pendingMove.y) : null;
                    if (pendingLocation) {
                        detailsHTML = DOM.html`<h3 class="text-2xl font-bold">${pendingLocation.name}</h3><p class="text-gray-400 mt-2 flex-grow">${pendingLocation.description}</p><button data-action="confirm-move" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg mt-4">Confirm Move</button>`;
                    } else {
                        const currentLocationData = worldMap.grid.find(l => l.coords.x === currentLocation.x && l.coords.y === currentLocation.y);
                        detailsHTML = DOM.html`<h3 class="text-2xl font-bold">Movement</h3><p class="text-gray-400 mt-2">You are currently at <strong>${currentLocationData.name}</strong>.</p><p class="text-gray-400 mt-2">Select an adjacent tile to see its details and confirm your move.</p>`;
                    }

                    contentHTML = DOM.html`<div class="p-6 grid grid-cols-1 md:grid-cols-2 gap-6 items-start h-full"><div class="grid grid-cols-3 gap-2">${DOM.unsafe(moveGridHTML)}</div><div class="flex flex-col h-full bg-black/20 p-4 rounded-lg">${detailsHTML}</div></div>`;

                } else {
                    // --- EDIT TAB LOGIC (Updated) ---
                    const { currentLocation, destination, path } = worldMap;
                    let mapGridHTML = '';
                    for (let y = 0; y < 8; y++) {
                        for (let x = 0; x < 8; x++) {
                            const location = worldMap.grid.find(loc => loc.coords.x === x && loc.coords.y === y);
                            // 1. Resolve Image for Edit Tab
                            let imageSrc = '';
                            if (location) {
                                const locationKey = `location::${x},${y}`;
                                UIManager.RUNTIME.worldImageCache = UIManager.RUNTIME.worldImageCache || {};
                                if (UIManager.RUNTIME.worldImageCache[locationKey]) imageSrc = UIManager.RUNTIME.worldImageCache[locationKey];
                                else if (location.imageUrl && !location.imageUrl.startsWith('local_idb_location')) imageSrc = location.imageUrl;
                            }

                            let classList = [
                                'aspect-square', 'rounded', 'cursor-pointer', 'text-xs', 'p-1', 'overflow-hidden', 'leading-tight',
                                'flex', 'items-center', 'justify-center', 'text-center', 'transition-all', 'duration-200',
                                'bg-cover', 'bg-center', 'relative' // Added for image support
                            ];

                            // Subtle gradients for visibility
                            if (location) {
                                if (imageSrc) {
                                    classList.push('bg-black/20', 'text-white', 'shadow-sm', 'text-shadow-sm');
                                } else {
                                    classList.push('bg-gradient-to-br', 'from-gray-700/90', 'to-gray-800/90', 'hover:from-gray-600/90', 'hover:to-gray-700/90', 'text-gray-100', 'shadow-sm');
                                }
                            } else {
                                classList.push('bg-gradient-to-br', 'from-gray-800/40', 'to-gray-900/40', 'hover:from-gray-800/60', 'hover:to-gray-900/60', 'text-gray-500');
                            }

                            if (currentLocation.x === x && currentLocation.y === y) classList.push('ring-2', 'ring-green-400', 'z-10');
                            if (destination && destination.x === x && destination.y === y) classList.push('ring-2', 'ring-red-500', 'z-10');
                            if (path && path.some(p => p.x === x && p.y === y)) classList.push('bg-sky-900/50');

                            // Removed selectedMapTile ring logic from here as it opens a modal now

                            const bgStyle = imageSrc ? `background-image: url('${imageSrc}');` : '';
                            // Add overlay for text readability if image exists
                            const displayName = (location && location.name && location.name !== 'Undefined') ? location.name : '';
                            const content = location ? (imageSrc ? `<div class="absolute inset-0 bg-black/40"></div>${displayName ? `<span class="relative z-10">${displayName}</span>` : ''}` : displayName) : '';

                            mapGridHTML += DOM.html`<div class="${classList.join(' ')}" style="${DOM.unsafe(bgStyle)}" data-action="select-map-tile" data-x="${x}" data-y="${y}">${DOM.unsafe(content)}</div>`.toString();
                        }
                    }

                    // Center the grid and limit width for better aesthetics
                    contentHTML = DOM.html`
            <div class="p-6 h-full flex flex-col items-center justify-center">
                <p class="text-sm text-gray-400 mb-2 w-full max-w-3xl text-left">Click any tile to edit details, set prompts, or manage local lore.</p>
                <div class="grid grid-cols-8 gap-1 w-full max-w-3xl aspect-square">
                    ${DOM.unsafe(mapGridHTML)}
                </div>
            </div>`;
                }

                const headerHTML = DOM.html`
                <div class="p-4 border-b border-gray-700 flex justify-between items-center bg-black/40 flex-shrink-0">
                     <div class="flex space-x-4">
                        <button onclick="UIManager.switchWorldMapTab('move')" class="pb-2 text-lg font-bold border-b-2 ${activeWorldMapTab === 'move' ? 'border-indigo-500 text-white' : 'border-transparent text-gray-400 hover:text-white'} transition-colors">Move</button>
                        <button onclick="UIManager.switchWorldMapTab('worldmap')" class="pb-2 text-lg font-bold border-b-2 ${activeWorldMapTab === 'worldmap' ? 'border-indigo-500 text-white' : 'border-transparent text-gray-400 hover:text-white'} transition-colors">Edit Map</button>
                     </div>
                     <div class="flex items-center space-x-3">
                        <button data-action="clear-world-map" class="text-red-400 hover:text-red-300 transition-colors mr-3" title="Clear World Map">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
                        </button>
                        <button id="generate-world-button" data-action="gen-world-map" class="text-sky-400 hover:text-sky-300 transition-colors" title="Generate World with AI">${this.getAIGenIcon()}</button>
                        <button data-action="close-modal" data-id="world-map-modal" class="bg-gray-700 hover:bg-gray-600 text-gray-300 hover:text-white p-2 rounded-lg transition-colors" title="Close">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                        </button>
                     </div>
                </div>`;

                container.innerHTML = DOM.html`<div class="flex flex-col h-full">${headerHTML}<div class="flex-grow overflow-y-auto min-h-0">${contentHTML}</div></div>`.toString();
            },

            /**
             * Renders the details modal for a selected map location.
             */
            renderLocationDetailsModal() {
                if (typeof WorldController === 'undefined') return;
                const { selectedMapTile } = WorldController.RUNTIME;
                const container = document.getElementById('location-details-content');

                if (!selectedMapTile || !container) return;

                // 1. Resolve Image Source (Lazy Load & Cache)
                const x = selectedMapTile.coords.x;
                const y = selectedMapTile.coords.y;
                const imgKey = `location::${x},${y}`;
                let visualSrc = null;

                // Ensure cache object exists
                UIManager.RUNTIME.worldImageCache = UIManager.RUNTIME.worldImageCache || {};

                if (selectedMapTile.imageUrl) {
                    if (selectedMapTile.imageUrl.startsWith('local_idb_')) {
                        if (UIManager.RUNTIME.worldImageCache[imgKey]) {
                            visualSrc = UIManager.RUNTIME.worldImageCache[imgKey];
                        } else {
                            DBService.getImage(imgKey).then(blob => {
                                if (blob) {
                                    UIManager.RUNTIME.worldImageCache[imgKey] = URL.createObjectURL(blob);
                                    if (WorldController.RUNTIME.selectedMapTile &&
                                        WorldController.RUNTIME.selectedMapTile.coords.x === x &&
                                        WorldController.RUNTIME.selectedMapTile.coords.y === y) {
                                        UIManager.renderLocationDetailsModal();
                                    }
                                }
                            }).catch(e => console.warn("Failed to load location image", e));
                        }
                    } else {
                        visualSrc = selectedMapTile.imageUrl;
                    }
                }

                // 2. Generate Image HTML
                const imageDisplayHTML = visualSrc
                    ? `
                        <div class="relative w-full aspect-video rounded-lg overflow-hidden border border-gray-600 mb-3 group bg-black/50">
                             <img src="${visualSrc}" class="w-full h-full object-cover">
                             <div class="absolute inset-0 bg-black/50 opacity-0 group-hover:opacity-100 transition-opacity flex items-center justify-center pointer-events-none">
                                <span class="text-white font-bold text-sm drop-shadow-md">Change Image</span>
                             </div>
                        </div>`
                    : `
                        <div class="w-full aspect-video rounded-lg bg-black/40 border-2 border-dashed border-gray-700 mb-3 flex flex-col items-center justify-center text-gray-500 gap-2">
                            <svg class="w-8 h-8 opacity-50" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"></path></svg>
                            <span class="text-xs">No Image Set</span>
                        </div>`;

                const imageHint = selectedMapTile.imageUrl ? (selectedMapTile.imageUrl.startsWith('local_idb_') ? 'Local Storage' : 'Legacy URL') : 'None';

                const content = DOM.html`
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
                <div class="space-y-6">
                    <div>
                        <label class="block text-sm font-bold text-gray-400 mb-1">Location Name</label>
                        <input type="text" value="${selectedMapTile.name}" oninput="WorldController.updateLocationDetail('name', this.value)" class="w-full bg-black/30 border-gray-600 p-2 rounded text-lg focus:border-indigo-500">
                    </div>

                    <div>
                        <label class="block text-sm font-bold text-gray-400 mb-1">Brief Description</label>
                        <textarea oninput="WorldController.updateLocationDetail('description', this.value)" class="w-full bg-black/30 border-gray-600 p-2 rounded h-24 resize-none text-sm">${selectedMapTile.description}</textarea>
                    </div>

                    <div>
                        <label class="block text-sm font-bold text-gray-400 mb-1">Visuals</label>
                        ${DOM.unsafe(imageDisplayHTML)}
                        <div class="flex items-center justify-between bg-black/20 p-2 rounded border border-gray-700">
                            <span class="text-xs text-gray-500">Source: ${imageHint}</span>
                            <div class="flex gap-2">
                                ${UIManager.isImageGenEnabled() ? DOM.html`<button data-action="gen-location-image" data-x="${selectedMapTile.coords.x}" data-y="${selectedMapTile.coords.y}" class="bg-indigo-600 hover:bg-indigo-500 text-white text-xs font-bold py-1 px-3 rounded transition-colors shadow-sm flex items-center gap-1">
                                    <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"></path></svg>
                                    Generate
                                </button>` : ''}
                                <label class="cursor-pointer bg-gray-700 hover:bg-gray-600 text-white text-xs font-bold py-1 px-3 rounded transition-colors shadow-sm">
                                    Upload New
                                    <input type="file" accept="image/*" 
                                           onchange="WorldController.handleWorldMapLocationImageUpload(event, ${selectedMapTile.coords.x}, ${selectedMapTile.coords.y})"
                                           class="hidden">
                                </label>
                            </div>
                        </div>
                    </div>

                    <div class="pt-4 border-t border-gray-700">
                        <label class="block text-sm font-bold text-gray-400 mb-2">Navigation Actions</label>
                        <div class="grid grid-cols-2 gap-3">
                           <button data-action="set-destination" class="bg-sky-600/80 hover:bg-sky-600 text-white font-bold py-2 px-4 rounded-lg transition-colors">Set Destination</button>
                           <button data-action="jump-to-location" data-x="${selectedMapTile.coords.x}" data-y="${selectedMapTile.coords.y}" class="bg-indigo-600/80 hover:bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg transition-colors">Jump To Here</button>
                        </div>
                    </div>
                </div>

                <div class="space-y-6 flex flex-col h-full">
                    
                    <div class="flex-grow flex flex-col min-h-[200px]">
                        <label class="block text-sm font-bold text-gray-400 mb-1">Full Generative Prompt</label>
                        <div class="relative flex-grow">
                            <textarea oninput="WorldController.updateLocationDetail('prompt', this.value)" class="w-full h-full bg-black/30 border-gray-600 p-3 rounded resize-none text-sm leading-relaxed">${selectedMapTile.prompt}</textarea>
                            <button data-action="gen-loc-prompt" class="absolute top-2 right-2 text-gray-500 hover:text-indigo-400 transition-colors" title="Generate with AI">${this.getAIGenIcon()}</button>
                        </div>
                    </div>

                    <div class="h-1/2 flex flex-col min-h-[250px]">
                        <div class="flex justify-between items-center mb-2">
                            <h4 class="font-bold text-sm text-gray-300 flex items-center gap-2">
                                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.246 18 16.5 18c-1.746 0-3.332.477-4.5 1.253z"></path></svg>
                                Local Static Memory
                            </h4>
                            <button data-action="add-local-static-entry" class="text-xs bg-gray-700 hover:bg-indigo-600 text-white font-bold py-1 px-2 rounded transition-colors">+ Add</button>
                        </div>
                        <div class="flex-grow border border-gray-700 rounded-lg overflow-hidden flex">
                            <div id="local-static-entries-list" class="w-1/3 bg-black/40 border-r border-gray-700 overflow-y-auto p-1 space-y-1"></div>
                            <div id="local-static-entry-details" class="w-2/3 bg-black/20 p-2 flex flex-col"></div>
                        </div>
                    </div>
                </div>
            </div>
        `;

                container.innerHTML = content.toString();
                this.renderLocalStaticEntriesList();
                this.renderLocalStaticEntryDetails();
            },

            /**
             * Renders the list of local static entries for a location.
             */
            renderLocalStaticEntriesList() {
                // Access Controller state via WorldController
                if (typeof WorldController === 'undefined') return;
                const { selectedMapTile, selectedLocalStaticEntryId } = WorldController.RUNTIME;

                const container = document.getElementById('local-static-entries-list');
                if (!container || !selectedMapTile) return;

                const entries = selectedMapTile.local_static_entries || [];
                container.innerHTML = entries.map(entry => DOM.html`
            <div data-action="select-local-static-entry" data-id="${entry.id}" 
                 class="p-2 rounded-md cursor-pointer ${selectedLocalStaticEntryId === entry.id ? 'bg-indigo-600' : 'hover:bg-indigo-600/50'}">
                <h5 class="font-semibold truncate text-sm">${entry.title}</h5>
            </div>
        `).join('');
            },

            /**
             * Renders the details view for a selected local static entry.
             */
            renderLocalStaticEntryDetails() {
                if (typeof WorldController === 'undefined') return;
                const { selectedMapTile, selectedLocalStaticEntryId } = WorldController.RUNTIME;

                const container = document.getElementById('local-static-entry-details');
                if (!container || !selectedMapTile) return;

                const entry = (selectedMapTile.local_static_entries || []).find(e => e.id === selectedLocalStaticEntryId);

                if (entry) {
                    container.innerHTML = DOM.html`
                <input type="text" value="${entry.title}" oninput="WorldController.updateLocalStaticEntryField('${entry.id}', 'title', this.value)" class="font-bold bg-black/30 p-2 w-full mb-2 text-sm rounded-md">
                <textarea oninput="WorldController.updateLocalStaticEntryField('${entry.id}', 'content', this.value)" class="w-full flex-grow bg-black/30 p-2 resize-none text-sm rounded-md">${entry.content}</textarea>
                <div class="flex justify-end mt-2">
                    <button data-action="delete-local-static-entry" data-id="${entry.id}" class="text-xs bg-red-900/50 hover:bg-red-700/80 text-red-200 font-semibold py-2 px-3 rounded">Delete</button>
                </div>`.toString();
                } else {
                    container.innerHTML = `<div class="text-gray-500 flex items-center justify-center h-full text-sm">Select an entry.</div>`;
                }
            },

            /**
             * Hydrates a visual event image from IndexedDB.
             * @param {HTMLImageElement} img - The image element.
             */
            async hydrateVisualImage(img) {
                const key = img.getAttribute('data-visual-key');
                if (!key || img.dataset.loaded === "true") return;

                img.dataset.loaded = "true";
                // Only pulse if not already src? But img.src is empty initially.
                // img.parentElement.classList.add("animate-pulse"); 

                try {
                    // Check Cache
                    if (typeof VisualMaster !== 'undefined' && VisualMaster.RUNTIME.imageUrls[key]) {
                        img.src = VisualMaster.RUNTIME.imageUrls[key];
                        return;
                    }

                    const blob = await DBService.getImage(key);
                    if (blob) {
                        const url = URL.createObjectURL(blob);
                        // Cache it
                        if (typeof VisualMaster !== 'undefined') {
                            VisualMaster.RUNTIME.imageUrls[key] = url;
                        }
                        img.src = url;
                        img.onload = null;
                    } else {
                        img.alt = "[Image Expired]";
                        img.style.display = 'none';
                    }
                } catch (e) {
                    console.error("Failed to hydrate visual:", e);
                    img.alt = "[Error]";
                }
            },

            /**
             * Retrieves the appropriate portrait URL for a character and emotion.
             * Checks cache and local storage before falling back to URL.
             * @param {Object} character - The character object.
             * @param {string} [mood=null] - The emotion to retrieve.
             * @returns {string|null} - The image URL or null.
             */
            getPortraitSrc(character, mood) {
                const cache = UIManager.RUNTIME.characterImageCache || {};

                const emoKey = mood ? `${character.id}::emotion::${mood}` : null;
                if (emoKey && cache[emoKey]) return cache[emoKey];

                if (cache[character.id]) return cache[character.id];

                if (character.image_url && !character.image_url.startsWith('local_idb_')) {
                    return character.image_url;
                }

                return null;
            },

            /**
             * Opens the Character Detail modal for editing a character.
             * @param {string} charId - The ID of the character to edit.
             */
            /**
             * Opens the Character Detail modal for editing a character.
             * @param {string} charId - The ID of the character to edit.
             */
            openCharacterDetailModal(charId) {
                const state = StateManager.getState();
                const char = state.characters.find(c => c.id === charId);
                if (!char) return;
                const container = document.getElementById('character-detail-modal-content');

                const canGenImage = UIManager.isImageGenEnabled();

                let currentRole = 'none';
                if (char.is_user) currentRole = 'user';
                else if (char.is_narrator) currentRole = 'narrator';

                const extraPortraitsHTML = (char.extra_portraits || []).map((portrait, index) => {
                    const emo = portrait.emotion || 'happy';
                    const fileInputId = `emo-file-${char.id}-${index}`;
                    const labelId = `emo-label-${char.id}-${index}`;
                    const cached = (UIManager.RUNTIME.characterImageCache || {})[`${char.id}::emotion::${emo}`];
                    const hint = cached ? '[local image]' : '[none]';
                    return DOM.html`
                <div class="flex flex-col space-y-2 mt-2 p-2 rounded border border-gray-700/50">
                    <div class="flex items-center space-x-2">
                        <select onchange="NarrativeController.updateExtraPortrait('${char.id}', ${index}, 'emotion', this.value)" class="w-1/3 bg-black/30 border-gray-600 rounded p-1 text-sm">
                            <option value="happy" ${emo === 'happy' ? 'selected' : ''}>Happy</option>
                            <option value="sad" ${emo === 'sad' ? 'selected' : ''}>Sad</option>
                            <option value="angry" ${emo === 'angry' ? 'selected' : ''}>Angry</option>
                            <option value="surprised" ${emo === 'surprised' ? 'selected' : ''}>Surprised</option>
                            <option value="neutral" ${emo === 'neutral' ? 'selected' : ''}>Neutral</option>
                        </select>
                        <button data-action="remove-extra-portrait" data-id="${char.id}" data-index="${index}" class="text-red-400 hover:text-red-300 ml-auto">X</button>
                    </div>
                    <div class="flex items-center justify-between">
                        <label class="text-sm text-gray-400" for="${fileInputId}">Upload ${canGenImage ? 'or Generate ' : ''}for <span class="font-semibold">${emo}</span>:</label>
                        <span id="${labelId}" class="text-xs text-gray-400">${hint}</span>
                    </div>
                    <div class="flex space-x-2">
                        <input id="${fileInputId}" type="file" accept="image/*" data-action-change="upload-emo-image" data-id="${char.id}" data-index="${index}" class="block w-full text-sm text-gray-400 file:mr-4 file:py-1 file:px-3 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-gray-700 file:text-gray-200 hover:file:bg-gray-600 cursor-pointer">
                        ${canGenImage ? DOM.html`<button onclick="NarrativeController.openCharacterImageGenerator('${char.id}', 'extra', ${index})" class="bg-indigo-600 hover:bg-indigo-500 text-white px-3 rounded flex items-center justify-center transition-colors" title="Generate">
                             ${this.getAIGenIcon()}
                        </button>` : ''}
                    </div>
                </div>`;
                });

                const tagsValue = (char.tags || []).join(', ');
                const color = char.color || { base: '#334155', bold: '#94a3b8' };

                const modalHTML = DOM.html`
            <div class="p-6 border-b border-gray-700 flex flex-row justify-between items-center gap-2">
                <div class="flex-grow min-w-0">
                    <input type="text" value="${char.name}" oninput="NarrativeController.updateCharacterField('${char.id}', 'name', this.value)" class="text-2xl font-semibold bg-transparent border-b border-transparent hover:border-gray-500 focus:border-indigo-500 transition-colors w-full focus:outline-none" placeholder="Character Name">
                    <div class="flex items-center space-x-2 mt-1">
                        <span class="text-sm text-gray-400">Active in this chat</span>
                        <label class="relative inline-flex items-center cursor-pointer">
                            <input type="checkbox" class="sr-only peer" ${char.is_active ? 'checked' : ''} onchange="NarrativeController.toggleCharacterActive(event, '${char.id}')">
                            <div class="w-9 h-5 bg-gray-700 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-4 after:w-4 after:transition-all peer-checked:bg-indigo-600"></div>
                        </label>
                    </div>
                </div>
                
                <div class="flex items-center space-x-4">
                    <div class="flex bg-black/40 rounded-lg p-1">
                        <button data-action="set-char-role" data-id="${char.id}" data-role="user" class="px-3 py-1 rounded-md text-sm font-bold transition-colors ${currentRole === 'user' ? 'bg-indigo-600 text-white shadow' : 'text-gray-400 hover:text-gray-200'}">User</button>
                        <button data-action="set-char-role" data-id="${char.id}" data-role="none" class="px-3 py-1 rounded-md text-sm font-bold transition-colors ${currentRole === 'none' ? 'bg-gray-600 text-white shadow' : 'text-gray-400 hover:text-gray-200'}">NPC</button>
                        <button data-action="set-char-role" data-id="${char.id}" data-role="narrator" class="px-3 py-1 rounded-md text-sm font-bold transition-colors ${currentRole === 'narrator' ? 'bg-teal-600 text-white shadow' : 'text-gray-400 hover:text-gray-200'}">Narrator</button>
                    </div>
                    <button data-action="close-modal" data-id="character-detail-modal" class="bg-gray-700 hover:bg-gray-600 text-gray-300 hover:text-white p-2 rounded-lg transition-colors" title="Close">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                    </button>
                </div>
            </div>

            <div class="p-6 overflow-y-auto space-y-4">
                <details open>
                    <summary class="font-semibold text-lg cursor-pointer hover:text-indigo-300">Primary Info</summary>
                    <div class="p-4 space-y-4 bg-black/20 rounded-b-lg">
                        
                        <div><label class="text-sm text-gray-400">Short Description (for roster card)</label><input type="text" value="${char.short_description}" oninput="NarrativeController.updateCharacterField('${char.id}', 'short_description', this.value)" class="w-full bg-black/30 border-gray-600 p-2 rounded"></div>
                        
                        <div class="grid grid-cols-2 gap-4">
                            <div><label class="text-sm text-gray-400" style="padding-right: 1rem;">Bubble Base Color</label><input type="color" value="${color.base}" oninput="NarrativeController.updateCharacterColor('${char.id}', 'base', this.value)" class="w-full h-10 p-1 bg-black/30 border-gray-600 rounded" style="width: 4rem;"></div>
                            <div><label class="text-sm text-gray-400" style="padding-right: 1rem;">Name Color</label><input type="color" value="${color.bold}" oninput="NarrativeController.updateCharacterColor('${char.id}', 'bold', this.value)" class="w-full h-10 p-1 bg-black/30 border-gray-600 rounded" style="width: 4rem;"></div>
                        </div>
                        <div><label class="text-sm text-gray-400">Tags (comma-separated)</label><input type="text" value="${tagsValue}" oninput="NarrativeController.updateCharacterTags('${char.id}', this.value)" class="w-full bg-black/30 border-gray-600 p-2 rounded"><button data-action="gen-char-tags" data-id="${char.id}" class="text-xs text-sky-400 hover:text-sky-300 mt-1 p-1 bg-sky-600/80 rounded">${this.getAIGenIcon()}</button></div>
                        
                        <div class="mt-4 pt-4 border-t border-gray-800">
                            <label class="text-sm text-gray-400">Default Image</label>
                            <div class="flex items-start gap-4 mt-2">
                                ${this.getPortraitSrc(char) ? DOM.html`<div class="w-64 h-64 flex-shrink-0 bg-gray-800 rounded overflow-hidden border border-gray-600 relative group">
                                    <img src="${this.getPortraitSrc(char)}" class="w-full h-full object-cover">
                                    ${canGenImage ? DOM.html`<button onclick="NarrativeController.openCharacterImageGenerator('${char.id}', 'primary')" class="absolute bottom-2 right-2 bg-indigo-600/90 hover:bg-indigo-500 text-white text-xs font-bold p-1 rounded shadow-lg opacity-0 group-hover:opacity-100 transition-opacity" title="Generate New">
                                        ${this.getAIGenIcon()}
                                    </button>` : ''}
                                </div>` : ''}
                                <div class="flex-grow flex flex-row items-center gap-2">
                                    <input type="file" accept="image/*" data-action-change="upload-local-image" data-id="${char.id}" class="block w-full text-sm text-gray-400 file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-gray-700 file:text-gray-200 hover:file:bg-gray-600 cursor-pointer">
                                    ${canGenImage ? DOM.html`<button onclick="NarrativeController.openCharacterImageGenerator('${char.id}', 'primary')" class="w-10 h-10 flex-shrink-0 bg-indigo-600 hover:bg-indigo-500 text-white rounded flex items-center justify-center transition-colors shadow-sm" title="Generate Portrait">
                                        ${this.getAIGenIcon()}
                                    </button>` : ''}
                                </div>
                            </div>
                        </div>
                    </div>
                </details>
                <details>
                    <summary class="font-semibold text-lg cursor-pointer hover:text-indigo-300">Persona</summary>
                    <div class="p-4 space-y-4 bg-black/20 rounded-b-lg">
                         <textarea id="persona-description-${char.id}" oninput="NarrativeController.updateCharacterField('${char.id}', 'description', this.value); UIManager.updateTokenCount('${char.id}', this.value)" class="w-full h-48 bg-black/30 border-gray-600 p-2 resize-y rounded">${char.description}</textarea>
                         <div class="flex justify-between items-center"><span class="text-right text-sm text-gray-400" id="token-counter-${char.id}">~${Math.round((char.description || '').length / 4)} tokens</span><button data-action="enhance-persona" data-id="${char.id}" class="text-sm bg-sky-600/80 hover:bg-sky-500/80 font-semibold py-2 px-3 rounded-lg">${this.getAIGenIcon()}</button></div>
                    </div>
                </details>
                <details>
                    <summary class="font-semibold text-lg cursor-pointer hover:text-indigo-300">Model Instructions</summary>
                    <div class="p-4 space-y-4 bg-black/20 rounded-b-lg">
                         <textarea oninput="NarrativeController.updateCharacterField('${char.id}', 'model_instructions', this.value)" class="w-full h-48 bg-black/30 border-gray-600 p-2 resize-y rounded">${char.model_instructions}</textarea>
                         <div class="text-right"><button data-action="gen-model-instructions" data-id="${char.id}" class="text-sm bg-sky-600/80 hover:bg-sky-700/80 font-semibold py-2 px-3 rounded-lg">${this.getAIGenIcon()}</button></div>
                    </div>
                </details>
                <details>
                    <summary class="font-semibold text-lg cursor-pointer hover:text-indigo-300">Emotional Portraits</summary>
                    <div class="p-4 space-y-2 bg-black/20 rounded-b-lg">
                        <div id="extra-portraits-${char.id}">${extraPortraitsHTML}</div>
                        <button data-action="add-extra-portrait" data-id="${char.id}" class="text-sm text-sky-400 hover:text-sky-300 mt-2">+ Add Emotional Portrait</button>
                    </div>
                </details>
            </div>
            <div class="p-4 bg-black/20 border-t border-gray-700 flex justify-between">
                <button data-action="delete-character" data-id="${char.id}" class="text-xs bg-red-900/50 hover:bg-red-700/80 text-red-200 font-semibold py-2 px-3 rounded">Delete</button>
            </div>
        `;
                container.innerHTML = modalHTML.toString();

                container.querySelectorAll('textarea').forEach(textarea => {
                    const autoResize = () => { textarea.style.height = 'auto'; textarea.style.height = `${textarea.scrollHeight}px`; };
                    textarea.addEventListener('input', autoResize);
                    setTimeout(autoResize, 0);
                });
            },

            updateTokenCount(charId, text) {
                const counter = document.getElementById(`token-counter-${charId}`);
                if (counter) counter.textContent = `~${Math.round((text || '').length / 4)} tokens`;
            },

            /**
             * Updates the AI character selector visibility and options.
             * Hides the selector if there is only one AI character.
             */
            updateAICharacterSelector() {
                const state = StateManager.getState();
                const selector = document.getElementById('ai-character-selector');
                if (!state || !state.characters) {
                    selector.innerHTML = '';
                    return;
                }

                // activeAiChars contains ONLY non-user characters
                const activeAiChars = state.characters.filter(c => !c.is_user && c.is_active);

                // FIX: Item 7 - Logic check:
                // If 1 AI char + 1 User = 2 total. activeAiChars.length is 1. 1 <= 1 is true. Hidden. Correct.
                // If 2 AI chars + 1 User = 3 total. activeAiChars.length is 2. 2 <= 1 is false. Shown. Correct.
                if (activeAiChars.length <= 1) {
                    selector.style.display = 'none';
                } else {
                    selector.style.display = 'block';
                }

                // ... (rest of function remains same)
                const currentValue = selector.value;
                let optionsHTML = DOM.html`<option value="any">Any</option>`.toString();
                optionsHTML += activeAiChars.map(c => DOM.html`<option value="${c.id}">${c.name}</option>`).join('');
                selector.innerHTML = optionsHTML;

                if (currentValue && selector.querySelector(`option[value="${currentValue}"]`)) {
                    selector.value = currentValue;
                }
            },

            /**
             * Renders the Import/Export Hub modal.
             * Repurposed to handle Imports only. Exports moved to Settings.
             */
            renderIOHubModal() {
                const modalContent = document.getElementById('io-hub-modal-content');

                const hubHTML = DOM.html`
            <div class="p-6 border-b border-gray-700 flex justify-between items-center">
                <h2 class="text-2xl font-semibold">Library Import</h2>
                <button data-action="close-modal" data-id="io-hub-modal" class="bg-gray-700 hover:bg-gray-600 text-gray-300 hover:text-white p-2 rounded-lg transition-colors" title="Close">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </div>
            <div class="p-6 overflow-y-auto">
                <div class="max-w-2xl mx-auto space-y-8">
                    
                    <!-- === IMPORT OPTIONS === -->
                    <div class="space-y-6">
                        
                        <div class="bg-black/20 p-6 rounded-lg border border-gray-700/50">
                            <h3 class="text-xl font-bold mb-4 flex items-center gap-2">
                                <svg class="w-6 h-6 text-indigo-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"></path></svg>
                                Import Single File
                            </h3>
                            <p class="text-sm text-gray-300 mb-4">Import a single Story from a V2 PNG, BYAF, or Ellipsis JSON file.</p>
                            <label for="single-file-upload" class="cursor-pointer group">
                                <div class="border-2 border-dashed border-gray-600 group-hover:border-indigo-500 rounded-lg p-8 text-center bg-gray-800/30 group-hover:bg-gray-800/60 transition-all">
                                    <p class="font-semibold text-indigo-300 group-hover:text-indigo-200 text-lg">Click to upload a file</p>
                                    <p class="text-xs text-gray-400 mt-2">Supported: .png (V2), .byaf, .zip, .json</p>
                                </div>
                            </label>
                            <input id="single-file-upload" type="file" class="hidden" accept=".png,.byaf,.zip,.json" data-action-change="handle-file-upload">
                        </div>

                        <div class="bg-black/20 p-6 rounded-lg border border-gray-700/50">
                            <h3 class="text-xl font-bold mb-4 flex items-center gap-2">
                                <svg class="w-6 h-6 text-teal-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10"></path></svg>
                                Bulk Import
                            </h3>
                            <p class="text-sm text-gray-300 mb-4">Import an entire folder of V2 PNG or BYAF files at once.</p>
                            <button data-action="handle-bulk-import" class="w-full bg-teal-600/80 hover:bg-teal-700/80 text-white font-bold py-3 px-4 rounded-lg transition-colors flex items-center justify-center gap-2">
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z"></path></svg>
                                Select Folder to Import
                            </button>
                        </div>

                        <div class="bg-red-900/10 p-6 rounded-lg border border-red-900/30">
                            <h3 class="text-xl font-bold mb-4 flex items-center gap-2 text-red-400">
                                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path></svg>
                                Restore Library Backup
                            </h3>
                            <p class="text-sm text-gray-300 mb-4">Replace your current library with an Ellipsis Library ZIP file. <span class="font-bold text-red-400">Warning: This is a destructive action.</span></p>
                            <label class="w-full bg-red-800/80 hover:bg-red-900/80 text-white font-bold py-3 px-4 rounded-lg inline-flex items-center justify-center gap-2 cursor-pointer transition-colors">
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path></svg>
                                <span>Import Library Package (ZIP)</span>
                                <input type="file" class="hidden" accept=".zip" data-action-change="import-library">
                            </label>
                        </div>
                    </div>

                </div>
            </div>
            <div class="p-4 bg-black/20 border-t border-gray-700 flex justify-end">
                <button data-action="close-modal" data-id="io-hub-modal" class="bg-gray-600 hover:bg-gray-700 font-bold py-2 px-4 rounded-lg">Close</button>
            </div>
        `;

                modalContent.innerHTML = hubHTML.toString();
            },

            /**
             * Shows a confirmation modal and returns a Promise resolving to true/false.
             * @param {string} message - The confirmation message.
             * @returns {Promise<boolean>} - Resolves with the user's choice.
             */
            showConfirmationPromise(message) {
                return new Promise((resolve) => {
                    const modal = document.getElementById('confirmation-modal');
                    const messageEl = document.getElementById('confirmation-modal-message');
                    const confirmBtn = document.getElementById('confirmation-modal-confirm-button');

                    // Defensive check: If critical UI elements are missing, auto-fail gracefully
                    if (!modal || !messageEl || !confirmBtn) {
                        console.error("UIManager: Critical Error - Confirmation Modal elements missing from DOM.");
                        resolve(false);
                        return;
                    }

                    const cancelBtn = modal.querySelector('button:not(#confirmation-modal-confirm-button)');
                    if (!cancelBtn) {
                        console.error("UIManager: Critical Error - Cancel button missing.");
                        resolve(false);
                        return;
                    }

                    messageEl.textContent = message;

                    const confirmClickHandler = () => {
                        cleanup();
                        resolve(true);
                    };
                    const cancelClickHandler = () => {
                        cleanup();
                        resolve(false);
                    };

                    const cleanup = () => {
                        confirmBtn.removeEventListener('click', confirmClickHandler);
                        cancelBtn.removeEventListener('click', cancelClickHandler);
                        const overlay = modal.querySelector('.modal-overlay');
                        if (overlay) overlay.removeEventListener('click', cancelClickHandler);
                        AppController.closeModal('confirmation-modal');
                    };

                    confirmBtn.addEventListener('click', confirmClickHandler, { once: true });
                    cancelBtn.addEventListener('click', cancelClickHandler, { once: true });

                    const overlay = modal.querySelector('.modal-overlay');
                    if (overlay) overlay.addEventListener('click', cancelClickHandler, { once: true });

                    AppController.openModal('confirmation-modal');
                });
            },

            /**
             * Displays a full-screen loading spinner with a message.
             * @param {string} [message='Loading...'] - The message to display.
             */
            showLoadingSpinner(message = 'Loading...') {
                let spinner = document.getElementById('loading-spinner');
                if (!spinner) {
                    spinner = document.createElement('div');
                    spinner.id = 'loading-spinner';
                    spinner.className = 'fixed inset-0 z-[80] bg-black/60 backdrop-blur-sm flex flex-col items-center justify-center';
                    spinner.innerHTML = DOM.html`
                <div class="w-16 h-16 border-4 border-t-indigo-500 border-gray-600 rounded-full animate-spin"></div>
                <p id="spinner-message" class="mt-4 text-white font-semibold"></p>
            `.toString();
                    document.body.appendChild(spinner);
                }
                document.getElementById('spinner-message').textContent = message;
                spinner.style.display = 'flex';
            },

            /**
             * Hides the loading spinner.
             */
            hideLoadingSpinner() {
                const spinner = document.getElementById('loading-spinner');
                if (spinner) {
                    spinner.style.display = 'none';
                }
            },

            /**
             * Displays a toast notification.
             */
            showNotification(message, type = 'info') {
                const container = document.getElementById('notification-container') || (() => {
                    const d = document.createElement('div');
                    d.id = 'notification-container';
                    d.className = 'fixed top-20 right-4 z-[90] flex flex-col gap-2 pointer-events-none';
                    document.body.appendChild(d);
                    return d;
                })();

                const toast = document.createElement('div');
                toast.className = `max-w-xs p-4 rounded-lg shadow-2xl text-white font-medium backdrop-blur-md transition-all duration-300 transform translate-x-full opacity-0 pointer-events-auto border border-white/10 ${type === 'error' ? 'bg-red-600/90' :
                    type === 'success' ? 'bg-green-600/90' :
                        'bg-indigo-600/90'
                    }`;
                toast.textContent = message;

                container.appendChild(toast);

                // Animate In
                requestAnimationFrame(() => {
                    toast.classList.remove('translate-x-full', 'opacity-0');
                });

                // Remove after delay
                setTimeout(() => {
                    toast.classList.add('translate-x-full', 'opacity-0');
                    setTimeout(() => toast.remove(), 300);
                }, 3000);
            },

            /**
             * Displays a report modal after a bulk import operation.
             * @param {Array<string>} importedStoryNames - List of successfully imported stories.
             * @param {Array<Object>} failedFiles - List of files that failed to import.
             */
            showBulkImportReport(importedStoryNames, failedFiles) {
                const container = document.getElementById('report-modal-content');

                const successList = importedStoryNames.map(name => DOM.html`<li>${name}</li>`);
                const failureSection = failedFiles.length > 0 ? (() => {
                    const logContent = failedFiles.map(f => `File: ${f.name}\nReason: ${f.reason}\n---`).join('\n');
                    const logBlob = new Blob([logContent], { type: 'text/plain' });
                    const logUrl = URL.createObjectURL(logBlob);
                    return DOM.html`
                <div>
                    <h3 class="font-bold text-lg text-red-400">Failures (${failedFiles.length})</h3>
                    <p class="text-sm mt-2">Some files could not be imported. <a href="${logUrl}" download="import_error_log.txt" class="text-indigo-400 hover:underline">Download Error Log</a> for details.</p>
                </div>
            `;
                })() : '';

                const reportHTML = DOM.html`
            <div class="p-6 border-b border-gray-700"><h2 class="text-2xl font-semibold">Bulk Import Report</h2></div>
            <div class="p-6 overflow-y-auto space-y-4">
                <div>
                    <h3 class="font-bold text-lg text-green-400">Success (${importedStoryNames.length})</h3>
                    <ul class="list-disc list-inside text-sm mt-2 max-h-40 overflow-y-auto bg-black/20 p-2 rounded-md">
                        ${successList.length ? successList : DOM.unsafe('<li>No stories were imported successfully.</li>')}
                    </ul>
                </div>
                ${failureSection}
            </div>
            <div class="p-4 bg-black/20 border-t border-gray-700 flex justify-end">
                <button data-action="close-modal" data-id="report-modal" class="bg-gray-600 hover:bg-gray-700 font-bold py-2 px-4 rounded-lg">Done</button>
            </div>
        `;

                container.innerHTML = reportHTML.toString();
                AppController.openModal('report-modal');
            },

            /**
             * Shows a confirmation modal with a callback for the confirm action.
             * @param {string} message - The confirmation message.
             * @param {Function} onConfirmCallback - The function to call on confirmation.
             */
            showConfirmationModal(message, onConfirmCallback) {
                const modal = document.getElementById('confirmation-modal');
                const messageEl = document.getElementById('confirmation-modal-message');
                const confirmBtn = document.getElementById('confirmation-modal-confirm-button');

                if (modal && messageEl && confirmBtn) {
                    messageEl.textContent = message;

                    const newConfirmBtn = confirmBtn.cloneNode(true);
                    confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);

                    newConfirmBtn.onclick = () => {
                        onConfirmCallback();
                        AppController.closeModal('confirmation-modal');
                    };
                    AppController.openModal('confirmation-modal');
                } else {
                    console.error("Confirmation modal elements not found.");
                }
            },

            /**
             * Opens a Generic Image Generator Modal.
             * @param {Object} options - Configuration for the generator.
             * @param {string} options.title - Header title.
             * @param {string} options.initialPrompt - Default prompt text.
             * @param {string|null} [options.initialNegative] - Default negative prompt.
             * @param {Function} options.onSave - Async callback(blob) when user clicks Save.
             */
            openGenericImageGenerator(opts) {
                const { title, initialPrompt, initialNegative = null, onSave } = opts;
                // Remove existing if any
                const existing = document.getElementById('image-gen-modal');
                if (existing) existing.remove();

                const modal = document.createElement('div');
                modal.id = 'image-gen-modal';
                modal.className = 'fixed inset-0 bg-black/80 backdrop-blur-sm flex items-center justify-center z-[100] modal-overlay hidden';
                modal.innerHTML = `
                             <div class="bg-gray-800 rounded-lg w-full max-w-2xl max-h-[90vh] flex flex-col shadow-2xl border border-gray-700">
                                <div class="px-6 py-4 border-b border-gray-700 flex justify-between items-center bg-gray-900/50 rounded-t-lg">
                                    <h3 class="text-xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-indigo-400 to-cyan-400">
                                        ${title}
                                    </h3>
                                    <button onclick="AppController.closeModal('image-gen-modal')" class="text-gray-400 hover:text-white">&times;</button>
                                </div>
                                <div id="image-gen-content" class="p-6 overflow-y-auto space-y-4">
                                     <div>
                                        <label class="block text-sm font-bold text-gray-400 mb-1">Prompt</label>
                                        <textarea id="gen-img-prompt" class="w-full bg-black/30 border-gray-600 p-3 rounded h-24 resize-none focus:border-indigo-500 font-mono text-sm">${initialPrompt}</textarea>
                                    </div>
                                    <div>
                                         <label class="block text-sm font-bold text-gray-400 mb-1">Negative Prompt (Optional)</label>
                                         <input type="text" id="gen-img-neg" value="${initialNegative || 'nsfw, text, watermark, bad anatomy, blurry'}" class="w-full bg-black/30 border-gray-600 p-2 rounded focus:border-indigo-500">
                                    </div>
                                    
                                    <div id="gen-result-area" class="mt-4 min-h-[300px] flex items-center justify-center bg-black/20 border-2 border-dashed border-gray-700 rounded-lg relative overflow-hidden group">
                                        <span class="text-gray-500 text-sm">Preview will appear here</span>
                                    </div>

                                    <div class="flex justify-end gap-3 pt-4 border-t border-gray-700 mt-4">
                                         <button onclick="AppController.closeModal('image-gen-modal')" class="px-4 py-2 text-gray-400 hover:text-white transition-colors">Cancel</button>
                                         <div class="flex-grow"></div>
                                         <button id="btn-do-generate" class="bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-2 px-6 rounded-lg transition-all shadow-lg shadow-indigo-900/50 flex items-center gap-2">
                                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"></path></svg>
                                            Generate
                                         </button>
                                    </div>
                                </div>
                            </div>
                         `;
                document.body.appendChild(modal);

                // Bind Generate Action
                document.getElementById('btn-do-generate').onclick = async (e) => {
                    const prompt = document.getElementById('gen-img-prompt').value;
                    const neg = document.getElementById('gen-img-neg').value;
                    const resultArea = document.getElementById('gen-result-area');
                    const btn = e.target.closest('button');

                    btn.disabled = true;
                    btn.innerHTML = `<svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-white" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg> Generating...`;

                    try {
                        const blob = await ImageGenerationService.generateImage(prompt, neg);
                        const url = URL.createObjectURL(blob);

                        // Render Result with Save Options
                        resultArea.innerHTML = `
                            <img src="${url}" class="w-full h-full object-contain">
                            <div class="absolute bottom-0 left-0 right-0 bg-black/80 p-3 flex justify-center gap-4 backdrop-blur-sm transition-transform translate-y-full group-hover:translate-y-0">
                                <button id="btn-save-img" class="bg-green-600 hover:bg-green-500 text-white font-bold py-1 px-4 rounded shadow-lg text-sm flex items-center gap-2">
                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg>
                                    Save & Use
                                </button>
                                <button id="btn-discard-img" class="bg-red-600/80 hover:bg-red-500 text-white font-bold py-1 px-4 rounded shadow-lg text-sm">Discard</button>
                            </div>
                        `;
                        resultArea.classList.remove('border-dashed', 'border-gray-700');
                        resultArea.classList.add('border-indigo-500');

                        // Move Save bar up immediately on mobile/touch? No, hover is fine for now, or ensure it's visible.
                        // Actually, let's make it always visible on completion to be safe.
                        resultArea.querySelector('div').classList.remove('translate-y-full', 'group-hover:translate-y-0');

                        // Save Handler
                        document.getElementById('btn-save-img').onclick = async () => {
                            try {
                                await onSave(blob);
                                AppController.closeModal('image-gen-modal');
                            } catch (err) {
                                alert("Failed to save image: " + err.message);
                            }
                        };

                        // Discard Handler
                        document.getElementById('btn-discard-img').onclick = () => {
                            resultArea.innerHTML = '<span class="text-gray-500 text-sm">Preview will appear here</span>';
                            resultArea.classList.add('border-dashed', 'border-gray-700');
                            resultArea.classList.remove('border-indigo-500');
                        };

                    } catch (err) {
                        resultArea.innerHTML = `<div class="text-red-400 p-4 text-center font-bold">Generation Failed</div><div class="text-red-300 text-xs px-4 pb-4 text-center">${err.message}</div>`;
                    } finally {
                        btn.disabled = false;
                        btn.innerHTML = 'Generate'; // Reset Label
                    }
                };

                AppController.openModal('image-gen-modal');
            },

            /**
             * Updates the primary action button to "Stop Generation" mode.
             */
            setButtonToStopMode() {
                const button = document.getElementById('primary-action-btn');
                if (!button) return;
                button.onclick = () => NarrativeController.stopGeneration();
                button.title = "Stop Generation";
                button.classList.remove('bg-indigo-600/50', 'hover:bg-indigo-600/80');
                button.classList.add('bg-red-700/60', 'hover:bg-red-700/80');
                // FIX: Updated Stop Icon (Rounded Square)
                button.innerHTML = DOM.unsafe(`<svg class="w-5 h-5" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="6" y="6" width="12" height="12" rx="2" /></svg>`);

                setTimeout(() => {
                    button.onclick = () => NarrativeController.stopGeneration();
                }, 0);
            },

            /**
             * Updates the primary action button to "Send / Write for Me" mode.
             */
            setButtonToSendMode() {
                const button = document.getElementById('primary-action-btn');
                if (!button) return;
                button.onclick = () => NarrativeController.handlePrimaryAction();
                button.title = "Send / Write for Me";
                button.classList.remove('bg-red-700/60', 'hover:bg-red-700/80');
                button.classList.add('bg-indigo-600/50', 'hover:bg-indigo-600/80');
                // FIX: Updated Send Icon (Paper Plane)
                button.innerHTML = DOM.unsafe(`<svg class="w-5 h-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon></svg>`);
            },
        };






















        /**
         * AppController
         * 
         * Central coordinating controller for high-level application logic.
         * Handling Modal orchestration, Settings management, and Persona logic.
         * Acts as the bridge between UI events and the Data/State layers.
         */
        const AppController = {
            RUNTIME: {
                activeSettingsTab: 'appearance',
            },

            CONSTANTS: {
                MODEL_SETTING_KEYS: [
                    'geminiApiKey', 'openRouterKey', 'openRouterModel',
                    'koboldcpp_url', 'koboldcpp_template', 'koboldcpp_min_p', 'koboldcpp_dry', 'lmstudio_url',
                    'geminiModel',
                    // Image Gen Keys
                    'imageGenBackend', 'koboldImageGenUrl', 'imageGenOpenRouterKey', 'imageGenOpenRouterModel',
                    'imageGenWidth', 'imageGenHeight',
                    'koboldImageGenCfg', 'koboldImageGenSampler', 'koboldImageGenScheduler', 'koboldImageGenSteps'
                ]
            },

            /**
             * Opens a modal dialog, performing necessary setup and guard checks.
             * @param {string} modalId - The ID of the modal to open.
             * @param {*} [contextId=null] - Optional context (character ID, message index, etc.).
             */
            openModal(modalId, contextId = null) {
                // 1. Guard: Check if story is loaded for context-dependent modals
                // 'io-hub-modal' and 'story-library-modal' are allowed without an active story.
                const needsStory = ['knowledge-modal', 'characters-modal', 'settings-modal', 'world-map-modal', 'example-dialogue-modal', 'character-detail-modal', 'edit-response-modal'];

                if (needsStory.includes(modalId) && !StateManager.getLibrary().active_story_id) {
                    alert("Please load a narrative first.");
                    return;
                }

                // 2. Specific Setup Logic based on Modal ID
                switch (modalId) {
                    case 'story-library-modal':
                        // Detect layout mode and pass it down
                        const isMobile = document.body.classList.contains('layout-vertical') || (window.innerHeight > window.innerWidth);
                        UIManager.renderLibraryInterface({ layout: isMobile ? 'mobile' : 'desktop' });
                        break;

                    case 'io-hub-modal':
                        UIManager.renderIOHubModal();
                        break;

                    case 'knowledge-modal':
                        // Reset to static tab by default
                        this.activeKnowledgeTab = 'static'; // Ensure Controller state is sync'd if used elsewhere
                        UIManager.switchKnowledgeTab('static');
                        break;

                    case 'world-map-modal':
                        // Reset map selection state via WorldController
                        if (typeof WorldController !== 'undefined') {
                            WorldController.RUNTIME.selectedMapTile = null;
                            WorldController.RUNTIME.pendingMove = null;
                            WorldController.RUNTIME.selectedLocalStaticEntryId = null;
                        }
                        UIManager.switchWorldMapTab('move');
                        break;

                    case 'settings-modal':
                        this.prepareSettingsModal();
                        this.switchSettingsTab(this.RUNTIME.activeSettingsTab || 'appearance');
                        break;

                    case 'example-dialogue-modal':
                        UIManager.renderExampleDialogueModal();
                        break;

                    case 'character-detail-modal':
                        UIManager.openCharacterDetailModal(contextId);
                        break;

                    case 'edit-response-modal':
                        // Delegate to NarrativeController if it exists
                        if (typeof NarrativeController !== 'undefined') {
                            NarrativeController.openEditModal(contextId);
                        }
                        break;


                    case 'location-details-modal':
                        UIManager.renderLocationDetailsModal();
                        break;
                }

                // 3. Open the modal via the low-level manager
                ModalManager.open(modalId);
            },

            /**
             * Closes a modal and performs necessary cleanup.
             * @param {string} modalId 
             */
            closeModal(modalId) {
                ModalManager.close(modalId);

                // Clear viewingStoryId if closing story details
                if (modalId === 'story-details-modal' || modalId === 'story-library-modal') {
                    UIManager.RUNTIME.viewingStoryId = null;
                }

                // Cleanup Logic
                if (modalId === 'character-detail-modal') {
                    UIManager.renderCharacters();
                }

                if (modalId === 'characters-modal') {
                    UIManager.updateAICharacterSelector();
                }

                if (modalId === 'knowledge-modal') {
                    // Clean up empty fields in dynamic entries
                    if (typeof WorldController !== 'undefined') {
                        WorldController.cleanupEmptyDynamicFields();
                    }
                }
            },

            /**
             * Toggles the mobile navigation menu.
             */
            toggleMobileMenu() {
                const menu = document.getElementById('mobile-menu');
                if (menu) {
                    menu.classList.toggle('hidden');
                }
            },

            /**
             * Prepares the settings modal structure if it hasn't been initialized yet.
             */
            prepareSettingsModal() {
                // Logic removed to allow natural scrolling.
                // The CSS classes (flex-grow, min-h-0, overflow-y-auto) on the container 
                // handle the layout correctly without a fixed min-height.
            },

            /**
             * Switches tabs within the Settings modal.
             * @param {string} tabName - 'appearance', 'prompt', or 'model'.
             */
            switchSettingsTab(tabName) {
                this.RUNTIME.activeSettingsTab = tabName;
                const tabs = ['appearance', 'prompt', 'model', 'personas', 'image-gen', 'export'];
                const container = document.getElementById('settings-content-container');
                const template = document.getElementById(`settings-${tabName}-content`);

                if (container && template) {
                    container.innerHTML = template.innerHTML;
                    const buildDisplay = document.getElementById('build-info-display');
                    if (buildDisplay && typeof APP_BUILD_TIMESTAMP !== 'undefined') {
                        buildDisplay.textContent = APP_BUILD_TIMESTAMP;
                    }
                }

                tabs.forEach(tab => {
                    const tabButton = document.getElementById(`settings-tab-${tab}`);
                    if (tabButton) {
                        if (tab === tabName) {
                            tabButton.classList.add('border-indigo-500', 'text-white');
                            tabButton.classList.remove('border-transparent', 'text-gray-400');
                        } else {
                            tabButton.classList.remove('border-indigo-500', 'text-white');
                            tabButton.classList.add('border-transparent', 'text-gray-400');
                        }
                    }
                });

                this.bindSettingsListeners();

                if (tabName === 'personas') {
                    this.renderUserPersonaList();
                } else if (tabName === 'model') {
                    this.renderSavedOpenRouterModels();
                    // NEW: Populate Gemini Models dynamically
                    this.populateGeminiModels();
                } else if (tabName === 'image-gen') {
                    // Dynamic show/hide based on backend
                    const backendSelect = document.getElementById('image-gen-backend-selector');
                    const koboldSettings = document.getElementById('image-gen-kobold-settings');
                    const openRouterSettings = document.getElementById('image-gen-openrouter-settings');

                    // NEW: Render saved image models
                    this.renderSavedOpenRouterImageModels();



                    // Initial Visibility Check (handled by bindSettingsListeners primarily, but we force one check)
                    setTimeout(() => AppController.updateImageGenSettingsVisibility(), 50);

                    // Test Connection Button
                    const testBtn = document.getElementById('test-image-gen-connection-btn');
                    const statusEl = document.getElementById('image-gen-connection-status');
                    if (testBtn) {
                        testBtn.onclick = async () => {
                            if (statusEl) { statusEl.textContent = "Testing..."; statusEl.className = "text-yellow-400 text-xs mt-2"; }
                            const result = await ImageGenerationService.testConnection();
                            if (statusEl) {
                                if (result) {
                                    statusEl.textContent = "Connection Successful!";
                                    statusEl.className = "text-green-400 text-xs mt-2";
                                } else {
                                    statusEl.textContent = "Connection Failed. Check URL/Key.";
                                    statusEl.className = "text-red-400 text-xs mt-2";
                                }
                            }
                        };
                    }
                } else if (tabName === 'export') {
                    const selector = document.getElementById('export-primary-character-selector');
                    if (selector) {
                        const currentVal = selector.value;
                        selector.innerHTML = '<option value="">Auto-detect (First AI)</option>';
                        const state = StateManager.getState();
                        if (state && state.characters && Array.isArray(state.characters)) {
                            state.characters.forEach(c => {
                                const opt = document.createElement('option');
                                opt.value = c.id;
                                opt.textContent = `${c.name || 'Unnamed'}${c.is_user ? ' (User)' : ''}`;
                                if (c.id === currentVal) opt.selected = true;
                                selector.appendChild(opt);
                            });
                        }
                    }
                }
            },

            /**
             * Fetches available Gemini models and populates the selector.
             */
            async populateGeminiModels() {
                const selector = document.getElementById('gemini-model-selector');
                const state = StateManager.getState();
                const globalSettings = StateManager.data.globalSettings;

                // Get Key from global settings primarily
                const apiKey = globalSettings.geminiApiKey || state.geminiApiKey;

                if (!selector) return;

                // If no key, show placeholder
                if (!apiKey) {
                    selector.innerHTML = '<option value="gemini-1.5-flash">Default (Gemini 1.5 Flash)</option>';
                    return;
                }

                const currentSelection = globalSettings.geminiModel || state.geminiModel || 'gemini-1.5-flash';

                // Add loading indicator
                selector.innerHTML = '<option>Fetching available models...</option>';

                try {
                    const models = await APIService.getGeminiModels();

                    if (models.length > 0) {
                        selector.innerHTML = ''; // Clear loading
                        models.forEach(m => {
                            // m.name usually comes as "models/gemini-pro"
                            // We will use the simple ID "gemini-pro" as value to keep things clean,
                            // or keep the full name. APIService.callGemini now handles both.
                            // Let's store the CLEAN ID.
                            const simpleId = m.name.replace('models/', '');

                            const opt = document.createElement('option');
                            opt.value = simpleId;
                            opt.text = `${m.displayName} (${m.version})`;
                            selector.appendChild(opt);
                        });
                    } else {
                        // Fallback if list fails but key exists
                        selector.innerHTML = '<option value="gemini-1.5-flash">Gemini 1.5 Flash (Fallback)</option><option value="gemini-1.5-pro">Gemini 1.5 Pro</option>';
                    }

                    // Restore selection
                    // We check against the simple ID (e.g. "gemini-1.5-flash")
                    let cleanCurrent = currentSelection.replace('models/', '');
                    selector.value = cleanCurrent;

                } catch (e) {
                    console.error("Error populating models", e);
                    selector.innerHTML = '<option value="gemini-1.5-flash">Error loading list (Using Flash)</option>';
                }
            },

            /**
             * Opens the settings modal and immediately switches to a specific tab.
             */
            openSettingsToTab(tabName) {
                this.openModal('settings-modal');
                this.switchSettingsTab(tabName);
            },

            /**
             * Binds live event listeners to inputs in the Settings modal.
             * Handles bi-directional binding between UI and ReactiveStore/GlobalSettings.
             */
            bindSettingsListeners() {
                const state = ReactiveStore.state;
                const globalSettings = StateManager.data.globalSettings;

                // Retrieve defaults to handle uninitialized values (e.g. blank prompts)
                const defaultPrompts = UTILITY.getDefaultSystemPrompts();
                const defaultUI = UTILITY.getDefaultUiSettings();
                const defaultStory = UTILITY.getDefaultStorySettings();
                const allDefaults = { ...defaultPrompts, ...defaultUI, ...defaultStory };

                const setListener = (id, key, callback) => {
                    const input = document.getElementById(id);
                    if (!input) return;

                    const isGlobal = this.CONSTANTS.MODEL_SETTING_KEYS.includes(key);

                    // Logic to determine value: Global -> State -> Default -> Empty String
                    let val;
                    if (isGlobal) {
                        val = globalSettings[key];
                    } else {
                        val = state[key];
                        // If state value is missing/undefined, try the default
                        if (val === undefined || val === null) {
                            val = allDefaults[key];
                        }
                    }

                    input.value = (val !== undefined && val !== null) ? val : '';

                    const debouncedCallback = debounce(function (e) {
                        // Determine value
                        const val = e.target.value;

                        if (isGlobal) {
                            globalSettings[key] = val;
                            StateManager.saveGlobalSettings();
                        } else {
                            // Update Proxy State
                            state[key] = val;
                            // Explicitly trigger the save mechanism to be safe
                            if (typeof ReactiveStore.forceSave === 'function') {
                                ReactiveStore.forceSave();
                            }
                        }
                        if (callback) callback();
                    }.bind(this), 500);

                    input.addEventListener('input', debouncedCallback);
                };

                // Helper: Bind range sliders
                const setupSlider = (sliderId, valueId, stateKey, callback = null) => {
                    const slider = document.getElementById(sliderId);
                    const valueDisplay = document.getElementById(valueId);
                    if (!slider || !valueDisplay) return;

                    const isGlobal = this.CONSTANTS.MODEL_SETTING_KEYS.includes(stateKey);
                    const currentValue = isGlobal ? globalSettings[stateKey] : state[stateKey];

                    slider.value = currentValue;
                    valueDisplay.textContent = slider.value;

                    slider.addEventListener('input', (e) => {
                        const newValue = parseFloat(e.target.value);

                        if (isGlobal) {
                            globalSettings[stateKey] = newValue;
                        } else {
                            state[stateKey] = newValue;
                        }

                        valueDisplay.textContent = e.target.value;
                        if (callback) callback();
                    });

                    slider.addEventListener('change', () => {
                        if (isGlobal) StateManager.saveGlobalSettings();
                        // ReactiveStore auto-saves state on set, so no manual save needed for local state
                    });
                };

                // --- Bindings: Image Generation Tab ---
                if (document.getElementById('image-gen-backend')) setListener('image-gen-backend', 'imageGenBackend', () => {
                    // Trigger visibility update if valid
                    AppController.updateImageGenSettingsVisibility();
                });
                if (document.getElementById('image-gen-kobold-url')) setListener('image-gen-kobold-url', 'koboldImageGenUrl');
                if (document.getElementById('image-gen-width')) setListener('image-gen-width', 'imageGenWidth');
                if (document.getElementById('image-gen-height')) setListener('image-gen-height', 'imageGenHeight');
                if (document.getElementById('image-gen-openrouter-key-input')) setListener('image-gen-openrouter-key-input', 'imageGenOpenRouterKey');
                if (document.getElementById('image-gen-openrouter-model-input')) setListener('image-gen-openrouter-model-input', 'imageGenOpenRouterModel');

                // Kobold Extended Settings
                if (document.getElementById('kobold-cfg-scale')) setListener('kobold-cfg-scale', 'koboldImageGenCfg');
                if (document.getElementById('kobold-sampler')) setListener('kobold-sampler', 'koboldImageGenSampler');
                if (document.getElementById('kobold-scheduler')) setListener('kobold-scheduler', 'koboldImageGenScheduler');
                if (document.getElementById('kobold-steps')) setListener('kobold-steps', 'koboldImageGenSteps');

                // --- Bindings: Model Tab ---
                if (document.getElementById('gemini-api-key-input')) setListener('gemini-api-key-input', 'geminiApiKey');
                if (document.getElementById('openrouter-api-key-input')) setListener('openrouter-api-key-input', 'openRouterKey');
                if (document.getElementById('openrouter-model-input')) setListener('openrouter-model-input', 'openRouterModel');
                if (document.getElementById('koboldcpp-min-p-slider')) setupSlider('koboldcpp-min-p-slider', 'koboldcpp-min-p-value', 'koboldcpp_min_p');
                if (document.getElementById('koboldcpp-dry-slider')) setupSlider('koboldcpp-dry-slider', 'koboldcpp-dry-value', 'koboldcpp_dry');
                if (document.getElementById('koboldcpp-url-input')) setListener('koboldcpp-url-input', 'koboldcpp_url');
                if (document.getElementById('lmstudio-url-input')) setListener('lmstudio-url-input', 'lmstudio_url');
                // Gemini Model Selector (Just bind listener, population handled in switchSettingsTab)
                if (document.getElementById('gemini-model-selector')) {
                    setListener('gemini-model-selector', 'geminiModel');
                }

                // --- Bindings: Appearance Tab ---
                // Background Image Handlers (Delegating to LibraryController if available)
                document.getElementById('background-image-upload')?.addEventListener('change', (e) => {
                    if (typeof LibraryController !== 'undefined') LibraryController.handleBackgroundImageUpload(e);
                });
                document.getElementById('background-image-clear')?.addEventListener('click', () => {
                    if (typeof LibraryController !== 'undefined') LibraryController.clearBackgroundImage();
                });

                // Visual Settings
                if (document.getElementById('chat-text-color')) setListener('chat-text-color', 'chatTextColor');
                if (document.getElementById('blur-slider')) setupSlider('blur-slider', 'blur-value', 'backgroundBlur');
                if (document.getElementById('text-size-slider')) setupSlider('text-size-slider', 'text-size-value', 'textSize');
                if (document.getElementById('bubble-image-size-slider')) setupSlider('bubble-image-size-slider', 'bubble-image-size-value', 'bubbleImageSize');

                // Response Length Binding
                if (document.getElementById('response-length-selector')) setListener('response-length-selector', 'responseLength');

                // Background Hint Update
                const bgHint = document.getElementById('background-image-hint');
                if (bgHint) {
                    if (state.backgroundImageURL === 'local_idb_background') {
                        bgHint.textContent = 'Current: [Local Image]';
                    } else if (state.backgroundImageURL) {
                        bgHint.textContent = 'Current: [Legacy URL]';
                    } else {
                        bgHint.textContent = 'Current: None';
                    }
                }

                // --- Bindings: Prompt Tab ---
                if (document.getElementById('system-prompt-input')) setListener('system-prompt-input', 'system_prompt');
                if (document.getElementById('event-master-prob-input')) {
                    setListener('event-master-prob-input', 'event_master_probability');
                    // Ensure default display if missing
                    const input = document.getElementById('event-master-prob-input');
                    if (input.value === '' || input.value === undefined) input.value = 10;
                }

                // Event Master Prompt (Base)
                if (document.getElementById('event-master-prompt-input')) {
                    setListener('event-master-prompt-input', 'event_master_base_prompt');
                    // Ensure default display if missing
                    const input = document.getElementById('event-master-prompt-input');
                    if (!input.value) {
                        const def = UTILITY.getDefaultSystemPrompts().event_master_base_prompt;
                        input.value = def;
                        if (!state.event_master_base_prompt) state.event_master_base_prompt = def;
                    }
                }

                // Visual Master Probability
                if (document.getElementById('visual-master-prob-input')) {
                    setListener('visual-master-prob-input', 'visual_master_probability');
                }

                // Visual Master Prompt (Base) - NEW BINDING
                if (document.getElementById('visual-master-prompt-input')) {
                    setListener('visual-master-prompt-input', 'visual_master_base_prompt');
                    const input = document.getElementById('visual-master-prompt-input');
                    if (!input.value) {
                        const def = UTILITY.getDefaultSystemPrompts().visual_master_base_prompt || "";
                        input.value = def;
                        if (!state.visual_master_base_prompt) state.visual_master_base_prompt = def;
                    }
                }

                if (document.getElementById('prompt-persona-gen-input')) setListener('prompt-persona-gen-input', 'prompt_persona_gen');
                if (document.getElementById('prompt-world-map-gen-input')) setListener('prompt-world-map-gen-input', 'prompt_world_map_gen');
                if (document.getElementById('prompt-location-gen-input')) setListener('prompt-location-gen-input', 'prompt_location_gen');
                if (document.getElementById('prompt-entry-gen-input')) setListener('prompt-entry-gen-input', 'prompt_entry_gen');
                if (document.getElementById('prompt-location-memory-gen-input')) setListener('prompt-location-memory-gen-input', 'prompt_location_memory_gen');

                // Toggle for Analysis
                const analysisToggle = document.getElementById('enable-analysis-toggle');
                if (analysisToggle) {
                    analysisToggle.checked = state.enableAnalysis !== false; // Default true
                    analysisToggle.addEventListener('change', (e) => {
                        state.enableAnalysis = e.target.checked;
                        if (typeof ReactiveStore.forceSave === 'function') ReactiveStore.forceSave();
                    });
                }

                // Font Selector
                const fontSelector = document.getElementById('font-selector');
                if (fontSelector) {
                    fontSelector.value = state.font;
                    fontSelector.addEventListener('change', (e) => this.changeFont(e.target.value));
                }

                // Markdown Color & Font Bindings
                [
                    'md_h1_color', 'md_h2_color', 'md_h3_color', 'md_bold_color', 'md_italic_color', 'md_quote_color',
                    'md_h1_font', 'md_h2_font', 'md_h3_font', 'md_bold_font', 'md_italic_font', 'md_quote_font'
                ].forEach(key => {
                    // The HTML IDs use dashes, the state keys use underscores
                    const inputId = key.replace(/_/g, '-') + '-input';
                    if (document.getElementById(inputId)) setListener(inputId, key);
                });

                // Kobold Template Selector
                const templateSelector = document.getElementById('koboldcpp-template-selector');
                if (templateSelector) {
                    templateSelector.value = globalSettings.koboldcpp_template || 'none';
                    templateSelector.addEventListener('change', (e) => {
                        globalSettings.koboldcpp_template = e.target.value;
                        StateManager.saveGlobalSettings();
                    });
                }

                // Bubble Opacity
                const opacitySlider = document.getElementById('bubble-opacity-slider');
                if (opacitySlider) {
                    const opacityValue = document.getElementById('bubble-opacity-value');
                    opacitySlider.value = state.bubbleOpacity;
                    opacityValue.textContent = `${Math.round(state.bubbleOpacity * 100)}%`;
                    opacitySlider.addEventListener('input', (e) => {
                        state.bubbleOpacity = parseFloat(e.target.value);
                        opacityValue.textContent = `${Math.round(state.bubbleOpacity * 100)}%`;
                    });
                }

                // Radio Buttons
                document.querySelectorAll('input[name="imageDisplayMode"]').forEach(radio => {
                    radio.checked = state.characterImageMode === radio.value;
                    radio.addEventListener('change', (e) => this.setCharacterImageMode(e.target.value));
                });

                // API Provider Dropdown
                const apiProviderSelect = document.getElementById('api-provider-selector');
                if (apiProviderSelect) {
                    // Use Global Settings as source of truth, fallback to 'gemini'
                    const activeProvider = globalSettings.apiProvider || 'gemini';
                    apiProviderSelect.value = activeProvider;

                    apiProviderSelect.addEventListener('change', (e) => {
                        this.setApiProvider(e.target.value);
                    });
                }

                // Settings Visibility Toggles
                const geminiSettings = document.getElementById('gemini-settings');
                const openrouterSettings = document.getElementById('openrouter-settings');
                const koboldcppSettings = document.getElementById('koboldcpp-settings');
                const lmstudioSettings = document.getElementById('lmstudio-settings');

                const currentProvider = globalSettings.apiProvider || 'gemini';

                if (geminiSettings) geminiSettings.style.display = currentProvider === 'gemini' ? 'block' : 'none';
                if (openrouterSettings) openrouterSettings.style.display = currentProvider === 'openrouter' ? 'block' : 'none';
                if (koboldcppSettings) koboldcppSettings.style.display = currentProvider === 'koboldcpp' ? 'block' : 'none';
                if (lmstudioSettings) lmstudioSettings.style.display = currentProvider === 'lmstudio' ? 'block' : 'none';

                // Toggle for Portrait Panel
                const portraitToggle = document.getElementById('show-portrait-panel-toggle');
                if (portraitToggle) {
                    // Use Global Settings for UI preference, or Story settings? usually UI pref is global
                    portraitToggle.checked = globalSettings.showPortraitPanel !== false; // Default true
                    portraitToggle.addEventListener('change', (e) => {
                        globalSettings.showPortraitPanel = e.target.checked;
                        StateManager.saveGlobalSettings();
                        if (typeof app !== 'undefined' && app.updateLayout) {
                            app.updateLayout(); // Trigger immediate layout refresh
                        }
                    });
                }

                // Force visibility update on init
                AppController.updateImageGenSettingsVisibility();
            },

            /**
             * Updates visibility of Image Generation settings based on selected backend.
             * Called by HTML onchange event.
             */
            updateImageGenSettingsVisibility() {
                const backendSelect = document.getElementById('image-gen-backend-selector');
                const koboldSettings = document.getElementById('image-gen-kobold-settings');
                const openRouterSettings = document.getElementById('image-gen-openrouter-settings');

                if (!backendSelect) return;

                const val = backendSelect.value;

                if (koboldSettings) {
                    koboldSettings.style.display = val === 'koboldcpp' ? 'block' : 'none';
                }
                if (openRouterSettings) {
                    openRouterSettings.style.display = val === 'openrouter' ? 'block' : 'none';
                    // Ensure the hidden class is removed if present
                    if (val === 'openrouter') openRouterSettings.classList.remove('hidden');
                }
            },

            /**
             * Helper: Updates font setting via Reactive Store.
             */
            changeFont(font) {
                ReactiveStore.state.font = font;
            },

            /**
             * Helper: Updates character image display mode via Reactive Store.
             */
            setCharacterImageMode(mode) {
                ReactiveStore.state.characterImageMode = mode;
            },

            /**
             * Helper: Updates API Provider setting (Global & Local) and refreshes settings view.
             */
            setApiProvider(provider) {
                // Update live state
                ReactiveStore.state.apiProvider = provider;

                // Update global state
                StateManager.data.globalSettings.apiProvider = provider;
                StateManager.saveGlobalSettings();

                // Re-bind to show/hide correct sections
                this.bindSettingsListeners();
            },

            /**
             * Opens the generator for the story background.
             */
            openBackgroundImageGenerator() {
                UIManager.openGenericImageGenerator({
                    title: 'Generate Background',
                    initialPrompt: 'A cinematic, high-resolution background landscape...',
                    onSave: async (blob) => {
                        const file = new File([blob], "generated_background.png", { type: "image/png" });
                        if (typeof LibraryController !== 'undefined') {
                            await LibraryController.handleBackgroundImageUpload({ target: { files: [file] } });
                        }
                        AppController.closeModal('image-gen-modal');
                    }
                });
            },

            // --- User Persona Methods ---

            /**
             * Creates a new user persona with default values.
             */
            addUserPersona() {
                const globalSettings = StateManager.data.globalSettings;
                if (!globalSettings.userPersonas) globalSettings.userPersonas = [];

                const newPersona = {
                    id: UTILITY.uuid(),
                    name: "New Persona",
                    short_description: "Brief summary.",
                    description: "Full description.",
                    model_instructions: "Write a response for {character}...",
                    tags: []
                };

                globalSettings.userPersonas.push(newPersona);
                StateManager.saveGlobalSettings();
                this.RUNTIME.selectedPersonaId = newPersona.id;
                this.renderUserPersonaList();
            },

            /**
             * Deletes a user persona by ID after confirmation.
             * @param {string} id - The ID of the persona to delete.
             */
            deleteUserPersona(id) {
                const globalSettings = StateManager.data.globalSettings;
                if (!globalSettings.userPersonas) return;

                if (confirm("Delete this persona?")) {
                    globalSettings.userPersonas = globalSettings.userPersonas.filter(p => p.id !== id);
                    if (this.RUNTIME.selectedPersonaId === id) this.RUNTIME.selectedPersonaId = null;
                    StateManager.saveGlobalSettings();
                    this.renderUserPersonaList();
                }
            },

            /**
             * Selects a user persona for editing.
             * @param {string} id - The ID of the persona to select.
             */
            selectUserPersona(id) {
                this.RUNTIME.selectedPersonaId = id;
                this.renderUserPersonaList(); // Update visual selection state
            },

            /**
             * Updates a specific field of a user persona.
             * @param {string} id - The ID of the persona.
             * @param {string} field - The field to update.
             * @param {string} value - The new value.
             */
            updateUserPersonaField(id, field, value) {
                const globalSettings = StateManager.data.globalSettings;
                const persona = globalSettings.userPersonas.find(p => p.id === id);
                if (persona) {
                    if (field === 'tags') {
                        persona.tags = value.split(',').map(t => t.trim()).filter(Boolean);
                    } else {
                        persona[field] = value;
                    }
                    StateManager.saveGlobalSettings();
                    // If name changed, update list
                    if (field === 'name') this.renderUserPersonaList(true);
                }
            },

            /**
             * Renders the list of user personas in the settings modal.
             * @param {boolean} [preserveDetails=false] - Whether to skip re-rendering details.
             */
            renderUserPersonaList(preserveDetails = false) {
                const globalSettings = StateManager.data.globalSettings;
                const personas = globalSettings.userPersonas || [];
                const listContainer = document.getElementById('user-personas-list');

                listContainer.innerHTML = personas.map(p => `
            <div onclick="AppController.selectUserPersona('${p.id}')" class="p-3 rounded-lg cursor-pointer ${this.RUNTIME.selectedPersonaId === p.id ? 'bg-indigo-600' : 'hover:bg-indigo-600/50'} mb-1 transition-colors">
                <h4 class="font-semibold truncate">${p.name}</h4>
                <p class="text-xs text-gray-300 truncate">${p.short_description}</p>
            </div>
        `).join('');

                if (!preserveDetails) this.renderUserPersonaDetails();
            },

            /**
             * Renders the details form for the selected user persona.
             * Handles image hydration and display.
             */
            async renderUserPersonaDetails() {
                const container = document.getElementById('user-persona-details');
                const globalSettings = StateManager.data.globalSettings;
                const persona = (globalSettings.userPersonas || []).find(p => p.id === this.RUNTIME.selectedPersonaId);

                if (!persona) {
                    container.innerHTML = `<div class="text-gray-400 flex items-center justify-center h-full">Select a persona to edit.</div>`;
                    return;
                }

                // Hydrate image if missing from cache
                if (!UIManager.RUNTIME.characterImageCache[persona.id]) {
                    try {
                        const blob = await DBService.getImage(persona.id);
                        if (blob) UIManager.RUNTIME.characterImageCache[persona.id] = URL.createObjectURL(blob);
                    } catch (e) { /* Ignore */ }
                }

                const imgSrc = UIManager.RUNTIME.characterImageCache[persona.id] || persona.image_url;
                // Standard placeholder (URL encoded)
                const placeholder = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%234b5563' opacity='0.25'%3E%3Cpath d='M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z'/%3E%3C/svg%3E";
                const displayImage = imgSrc ? imgSrc : placeholder;

                container.innerHTML = `
            <div class="flex flex-col gap-4">
                <div class="flex justify-between items-center pb-2 border-b border-gray-700">
                    <h3 class="text-xl font-bold">Edit Persona</h3>
                    <div class="flex gap-2">
                        <button onclick="AppController.applyUserPersonaToCurrentStory('${persona.id}')" class="bg-teal-600 hover:bg-teal-700 text-white text-sm font-bold py-1 px-3 rounded">Add to Roleplay</button>
                        <button onclick="AppController.deleteUserPersona('${persona.id}')" class="bg-red-900/50 hover:bg-red-700/80 text-red-200 text-sm font-bold py-1 px-3 rounded">Delete</button>
                    </div>
                </div>

                <div class="flex items-start gap-4">
                    <div class="w-24 h-32 flex-shrink-0 bg-gray-800 rounded-lg overflow-hidden border border-gray-600 relative group">
                        <img src="${displayImage}" class="w-full h-full object-cover">
                        <label class="absolute inset-0 bg-black/50 flex items-center justify-center opacity-0 group-hover:opacity-100 cursor-pointer transition-opacity text-xs text-white font-bold">
                            Change
                            <input type="file" accept="image/*" onchange="AppController.handleUserPersonaImageUpload(event, '${persona.id}')" class="hidden">
                        </label>
                    </div>
                    <div class="flex-grow space-y-4">
                        <div>
                            <label class="block text-sm font-bold text-gray-400 mb-1">Name</label>
                            <input type="text" value="${persona.name}" oninput="AppController.updateUserPersonaField('${persona.id}', 'name', this.value)" class="w-full bg-black/30 border-gray-600 p-2 rounded focus:border-indigo-500">
                        </div>
                        <div>
                            <label class="block text-sm font-bold text-gray-400 mb-1">Short Description</label>
                            <input type="text" value="${persona.short_description}" oninput="AppController.updateUserPersonaField('${persona.id}', 'short_description', this.value)" class="w-full bg-black/30 border-gray-600 p-2 rounded focus:border-indigo-500">
                        </div>
                    </div>
                </div>

                <div>
                    <label class="block text-sm font-bold text-gray-400 mb-1">Full Description</label>
                    <textarea oninput="AppController.updateUserPersonaField('${persona.id}', 'description', this.value)" class="w-full h-32 bg-black/30 border-gray-600 p-2 rounded resize-y">${persona.description}</textarea>
                </div>

                <div>
                    <label class="block text-sm font-bold text-gray-400 mb-1">Model Instructions</label>
                    <textarea oninput="AppController.updateUserPersonaField('${persona.id}', 'model_instructions', this.value)" class="w-full h-24 bg-black/30 border-gray-600 p-2 rounded resize-y">${persona.model_instructions}</textarea>
                </div>

                <div>
                    <label class="block text-sm font-bold text-gray-400 mb-1">Tags (comma-separated)</label>
                    <input type="text" value="${(persona.tags || []).join(', ')}" oninput="AppController.updateUserPersonaField('${persona.id}', 'tags', this.value)" class="w-full bg-black/30 border-gray-600 p-2 rounded focus:border-indigo-500">
                </div>
            </div>
        `;
            },

            /**
             * Handles the upload of a custom image for a user persona.
             * Processes the image and saves it to IndexedDB.
             * @param {Event} event - The file input change event.
             * @param {string} personaId - The ID of the persona.
             */
            async handleUserPersonaImageUpload(event, personaId) {
                const file = event.target.files[0];
                if (!file) return;

                UIManager.showLoadingSpinner('Saving persona image...');
                try {
                    const blob = await ImageProcessor.processImageAsBlob(file);
                    await DBService.saveImage(personaId, blob);

                    // Update Cache
                    if (UIManager.RUNTIME.characterImageCache[personaId]) {
                        URL.revokeObjectURL(UIManager.RUNTIME.characterImageCache[personaId]);
                    }
                    UIManager.RUNTIME.characterImageCache[personaId] = URL.createObjectURL(blob);

                    // Update Data Object marker
                    this.updateUserPersonaField(personaId, 'image_url', `local_idb_persona_${personaId}`);

                    // Refresh UI
                    this.renderUserPersonaDetails();
                } catch (e) {
                    alert("Image upload failed: " + e.message);
                } finally {
                    UIManager.hideLoadingSpinner();
                }
            },

            /**
             * Applies the selected user persona to the current story.
             * Demotes the current user to an NPC and creates a new User character.
             * @param {string} personaId - The ID of the persona to apply.
             */
            async applyUserPersonaToCurrentStory(personaId) {
                const state = ReactiveStore.state;
                if (!state || !state.characters) {
                    alert("No active story loaded.");
                    return;
                }

                const globalSettings = StateManager.data.globalSettings;
                const persona = globalSettings.userPersonas.find(p => p.id === personaId);
                if (!persona) return;

                if (!confirm(`Add "${persona.name}" as the new User? The current User character will be saved as an inactive NPC.`)) {
                    return;
                }

                // 1. Demote existing User(s)
                state.characters.forEach(c => {
                    if (c.is_user) {
                        c.is_user = false;
                        c.is_active = false;
                    }
                });

                // 2. Create New Character Object
                const newCharId = UTILITY.uuid();

                // Clone Image Logic:
                // If persona has an image in IDB, copy it to the new character ID
                // This ensures the story character has an independent copy of the image
                let newImageUrl = "";
                try {
                    const personaBlob = await DBService.getImage(persona.id);
                    if (personaBlob) {
                        await DBService.saveImage(newCharId, personaBlob);
                        newImageUrl = `local_idb_${newCharId}`;
                        // Pre-cache for immediate display
                        UIManager.RUNTIME.characterImageCache[newCharId] = URL.createObjectURL(personaBlob);
                    }
                } catch (e) {
                    console.warn("Failed to clone persona image:", e);
                }

                const newChar = {
                    id: newCharId,
                    name: persona.name,
                    short_description: persona.short_description || "User Persona",
                    description: persona.description || "",
                    model_instructions: persona.model_instructions || `Act as ${persona.name}.`,
                    tags: [...(persona.tags || [])],
                    image_url: newImageUrl,
                    extra_portraits: [],
                    is_user: true,
                    is_active: true,
                    is_narrator: false,
                    color: { base: '#4b5563', bold: '#e5e7eb' }
                };

                // 3. Add to Story
                state.characters.push(newChar);

                // 4. Save and Refresh UI
                await ReactiveStore.forceSave();
                UIManager.renderCharacters();
                UIManager.updateAICharacterSelector();

                alert(`"${persona.name}" is now the active User.`);
            },
            // --- OpenRouter Saved Models Logic ---

            /**
             * Updates visibility of Image Generation settings based on selected backend.
             */
            updateImageGenSettingsVisibility() {
                const backendSelect = document.getElementById('image-gen-backend');
                if (!backendSelect) return;
                const val = backendSelect.value;

                const koboldSettings = document.getElementById('image-gen-kobold-settings');
                const openRouterSettings = document.getElementById('image-gen-openrouter-settings');

                // Toggle Visual Master controls
                const vmSlider = document.getElementById('visual-master-probability-slider');
                const isDisabled = val === 'disabled';

                if (vmSlider) {
                    vmSlider.disabled = isDisabled;
                    // Visual feedback
                    if (isDisabled) {
                        vmSlider.parentElement.classList.add('opacity-50', 'pointer-events-none');
                    } else {
                        vmSlider.parentElement.classList.remove('opacity-50', 'pointer-events-none');
                    }
                }

                if (koboldSettings) {
                    const show = val === 'koboldcpp';
                    koboldSettings.style.display = show ? 'block' : 'none';
                    if (show) koboldSettings.classList.remove('hidden');
                    else koboldSettings.classList.add('hidden');
                }
                if (openRouterSettings) {
                    const show = val === 'openrouter';
                    openRouterSettings.style.display = show ? 'block' : 'none';
                    if (show) openRouterSettings.classList.remove('hidden');
                    else openRouterSettings.classList.add('hidden');
                }
            },

            /**
             * Saves the current OpenRouter model string to the global settings.
             */
            saveOpenRouterModel() {
                const input = document.getElementById('openrouter-model-input');
                if (!input) return;

                const value = input.value.trim();
                if (!value) return;

                const globalSettings = StateManager.data.globalSettings;
                if (!globalSettings.savedOpenRouterModels) globalSettings.savedOpenRouterModels = [];

                // Avoid duplicates
                if (!globalSettings.savedOpenRouterModels.includes(value)) {
                    globalSettings.savedOpenRouterModels.push(value);
                    StateManager.saveGlobalSettings();
                    this.renderSavedOpenRouterModels();
                }
            },

            /**
             * Deletes a saved OpenRouter model from the global settings.
             * @param {string} modelName - The name of the model to delete.
             */
            deleteOpenRouterModel(modelName) {
                const globalSettings = StateManager.data.globalSettings;
                if (!globalSettings.savedOpenRouterModels) return;

                if (confirm(`Remove "${modelName}" from saved models?`)) {
                    globalSettings.savedOpenRouterModels = globalSettings.savedOpenRouterModels.filter(m => m !== modelName);
                    StateManager.saveGlobalSettings();
                    this.renderSavedOpenRouterModels();
                }
            },

            /**
             * Selects a saved OpenRouter model and updates the input field.
             * @param {string} modelName - The name of the model to select.
             */
            selectOpenRouterModel(modelName) {
                const input = document.getElementById('openrouter-model-input');
                if (input) {
                    input.value = modelName;
                    // Manually trigger the input event to update the Global Settings via the listener
                    input.dispatchEvent(new Event('input'));
                }
            },

            /**
             * Renders the list of saved OpenRouter models in the settings modal.
             */
            renderSavedOpenRouterModels() {
                const container = document.getElementById('openrouter-saved-models-list');
                if (!container) return;

                const globalSettings = StateManager.data.globalSettings;
                const models = globalSettings.savedOpenRouterModels || [];

                if (models.length === 0) {
                    container.innerHTML = '<span class="text-xs text-gray-500 italic">No saved models.</span>';
                    return;
                }

                container.innerHTML = models.map(model => {
                    // Simplify: show only the part after the slash if present
                    const shortName = model.includes('/') ? model.split('/').slice(1).join('/') : model;

                    // Color logic based on :free suffix
                    const isFree = model.endsWith(':free');
                    const borderColor = isFree ? 'border-green-500' : 'border-gray-600';
                    const textColor = isFree ? 'text-green-200' : 'text-gray-300';

                    return `
            <div class="inline-flex items-center bg-black/30 border ${borderColor} rounded-lg overflow-hidden" title="${model}">
                <button onclick="AppController.selectOpenRouterModel('${model}')" class="px-3 py-1 text-xs ${textColor} hover:text-white hover:bg-white/10 transition-colors truncate max-w-[200px]">
                    ${shortName}
                </button>
                <button onclick="AppController.deleteOpenRouterModel('${model}')" class="px-2 py-1 text-xs text-gray-500 hover:text-red-400 hover:bg-black/20 border-l ${borderColor} transition-colors" title="Remove">
                    <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </div>
        `;
                }).join('');
            },

            // --- OpenRouter Model Browser ---

            // --- OpenRouter Model Browser ---

            /**
             * Opens the OpenRouter model browser modal and fetches available models.
             * @param {string} [mode='text'] - 'text' or 'image'.
             */
            async openOpenRouterModelBrowser(mode = 'text') {
                this.RUNTIME.modelBrowserMode = mode;

                const listContainer = document.getElementById('openrouter-model-list');
                const searchInput = document.getElementById('openrouter-model-search');

                // Ensure search input is visible (in case hidden by Image Browser)
                if (searchInput) searchInput.style.display = 'block';

                // Reset search input
                if (searchInput) {
                    searchInput.value = '';
                }

                // Show loading state
                if (listContainer) {
                    listContainer.innerHTML = '<div class="flex items-center justify-center h-full text-gray-400"><span>Loading models...</span></div>';
                }

                this.openModal('openrouter-model-modal');

                try {
                    let models = await APIService.fetchOpenRouterModels();

                    if (models.length > 0) {
                        console.groupCollapsed("OpenRouter Model Fetch Debug");
                        console.log("Total Models Fetched:", models.length);
                        console.log("Sample Model 0:", models[0]);
                        console.groupEnd();
                    }

                    // Filter based on mode
                    if (mode === 'image') {
                        models = models.filter(m => {
                            const id = m.id.toLowerCase();

                            // 1. Check root properties (Some APIs put it here)
                            if (m.modalities && Array.isArray(m.modalities) && m.modalities.includes('image')) return true;

                            // 2. Check Architecture Object
                            if (m.architecture) {
                                // Legacy: modality string (e.g., 'text->image')
                                if (m.architecture.modality && String(m.architecture.modality).includes('->image')) return true;

                                // New: output_modalities
                                if (m.architecture.output_modalities && Array.isArray(m.architecture.output_modalities) && m.architecture.output_modalities.includes('image')) return true;
                            }

                            // 3. String Heuristics (Robust Fallback)
                            if (id.includes('dall-e') ||
                                id.includes('diffusion') ||
                                id.includes('flux') ||
                                id.includes('midjourney') ||
                                id.includes('imagen') ||
                                id.includes('recraft') ||
                                id.includes('ideogram')) return true;

                            return false;
                        });
                        console.log(`Filtered Image Models: ${models.length}`);
                    } else {
                        // Text Mode: Filter out known strict image generators to reduce noise
                        models = models.filter(m => {
                            const id = m.id.toLowerCase();
                            const mod = m.architecture?.modality;
                            if (mod && String(mod) === 'text->image') return false; // Strict image

                            // Exclude obvious image-only models (heuristics)
                            // Note: GPT-4 Vision is text->text (input image, output text), so we keep it.
                            if (id.includes('dall-e')) return false;
                            if (id.includes('stable-diffusion') || id.includes('stabilityai/stable-diffusion')) return false;
                            if (id.includes('flux') && !id.includes('text')) return false; // Flux usually image
                            return true;
                        });
                    }

                    this._openRouterModelsList = models;
                    this._renderOpenRouterModelList(models);

                    // Setup search handler with debounce
                    if (searchInput) {
                        searchInput.oninput = debounce((e) => {
                            const query = e.target.value.toLowerCase().trim();
                            const filtered = query ? models.filter(m =>
                                m.id.toLowerCase().includes(query) ||
                                (m.name && m.name.toLowerCase().includes(query))
                            ) : models;
                            this._renderOpenRouterModelList(filtered);
                        }, 200);
                    }
                } catch (error) {
                    console.error('Failed to fetch OpenRouter models:', error);
                    if (listContainer) {
                        listContainer.innerHTML = `<div class="flex flex-col items-center justify-center h-full text-red-400 p-4">
                            <span class="text-center">Failed to load models.</span>
                            <span class="text-center text-sm mt-1">${error.message}</span>
                            <button onclick="AppController.openOpenRouterModelBrowser('${mode}')" class="mt-4 bg-indigo-600 hover:bg-indigo-700 px-4 py-2 rounded-lg text-white">Retry</button>
                        </div>`;
                    }
                }
            },

            /**
             * Helper to open the browser in Image Mode.
             */
            async openOpenRouterImageModelBrowser() {
                await this.openOpenRouterModelBrowser('image');
            },

            /**
             * Renders the OpenRouter model list in the browser modal.
             * @param {Array} models - Array of model objects to render.
             */
            _renderOpenRouterModelList(models) {
                const listContainer = document.getElementById('openrouter-model-list');
                if (!listContainer) return;

                if (!models || models.length === 0) {
                    listContainer.innerHTML = '<div class="flex items-center justify-center h-full text-gray-400"><span>No models found</span></div>';
                    return;
                }

                const global = StateManager.data.globalSettings;
                const state = StateManager.getState();

                // Determine current model based on mode
                let currentModel;
                if (this.RUNTIME.modelBrowserMode === 'image') {
                    currentModel = global.imageGenOpenRouterModel || state.imageGenOpenRouterModel;
                } else {
                    currentModel = global.openRouterModel || state.openRouterModel;
                }

                // Sort models: selected first, then alphabetically by name
                const sortedModels = [...models].sort((a, b) => {
                    if (a.id === currentModel) return -1;
                    if (b.id === currentModel) return 1;
                    return (a.name || a.id).localeCompare(b.name || b.id);
                });

                const formatPrice = (price) => {
                    if (!price || price === 0) return 'Free';
                    const perMillion = parseFloat(price) * 1000000;
                    if (perMillion < 0.01) return '<$0.01/M';
                    return `$${perMillion.toFixed(2)}/M`;
                };

                const getPriceColor = (price) => {
                    const val = parseFloat(price || 0) * 1000000;
                    if (val <= 0.05) return 'text-green-400 font-bold'; // Free or dirt cheap
                    if (val < 5) return 'text-gray-300'; // Reasonable
                    return 'text-amber-400'; // Expensive
                };

                listContainer.innerHTML = sortedModels.map(model => {
                    const isSelected = model.id === currentModel;
                    const promptPrice = formatPrice(model.pricing?.prompt);
                    const completionPrice = formatPrice(model.pricing?.completion);
                    const contextLength = model.context_length ? `${Math.round(model.context_length / 1024)}K ctx` : '';

                    const pColor = getPriceColor(model.pricing?.prompt);
                    const cColor = getPriceColor(model.pricing?.completion);

                    return `
                        <div class="p-3 rounded-lg cursor-pointer transition-colors mb-1 ${isSelected ? 'bg-indigo-600/50 border border-indigo-500' : 'bg-gray-700/50 hover:bg-gray-600/50 border border-transparent'}" onclick="AppController._selectModelFromBrowser('${model.id}')">
                            <div class="flex justify-between items-start">
                                <div class="flex-1 min-w-0">
                                    <div class="font-medium text-white truncate">${model.name || model.id}</div>
                                    <div class="text-xs text-gray-400 truncate">${model.id}</div>
                                </div>
                                ${isSelected ? '<span class="ml-2 text-indigo-300 text-sm whitespace-nowrap">Current</span>' : ''}
                            </div>
                            <div class="flex gap-3 mt-2 text-xs text-gray-400">
                                <span title="Input price per million tokens" class="${pColor}">In: ${promptPrice}</span>
                                <span title="Output price per million tokens" class="${cColor}">Out: ${completionPrice}</span>
                                ${contextLength ? `<span title="Context window">${contextLength}</span>` : ''}
                            </div>
                        </div>
                    `;
                }).join('');
            },

            /**
             * Selects a model from the browser and populates the input field.
             * @param {string} modelId - The model ID to select.
             */
            _selectModelFromBrowser(modelId) {
                if (this.RUNTIME.modelBrowserMode === 'image') {
                    // Image Mode Selection
                    const input = document.getElementById('image-gen-openrouter-model-input');
                    if (input) {
                        input.value = modelId;
                        input.dispatchEvent(new Event('input')); // Sync with Global/State
                    }
                    ReactiveStore.state.imageGenOpenRouterModel = modelId;
                } else {
                    // Text Mode Selection (Default)
                    const input = document.getElementById('openrouter-model-input');
                    if (input) {
                        input.value = modelId;
                        input.dispatchEvent(new Event('input'));
                    }
                    ReactiveStore.state.openRouterModel = modelId;
                }

                this.closeModal('openrouter-model-modal');
            },

            // --- OpenRouter Image Model Management ---

            /**
             * Saves the current OpenRouter image model string to the global settings.
             */
            saveOpenRouterImageModel() {
                const input = document.getElementById('image-gen-openrouter-model-input');
                if (!input) return;

                const value = input.value.trim();
                if (!value) return;

                const globalSettings = StateManager.data.globalSettings;
                if (!globalSettings.savedOpenRouterImageModels) globalSettings.savedOpenRouterImageModels = [];

                // Avoid duplicates
                if (!globalSettings.savedOpenRouterImageModels.includes(value)) {
                    globalSettings.savedOpenRouterImageModels.push(value);
                    StateManager.saveGlobalSettings();
                    this.renderSavedOpenRouterImageModels();
                }
            },

            /**
             * Deletes a saved OpenRouter image model from the global settings.
             * @param {string} modelName - The name of the model to delete.
             */
            deleteOpenRouterImageModel(modelName) {
                const globalSettings = StateManager.data.globalSettings;
                if (!globalSettings.savedOpenRouterImageModels) return;

                if (confirm(`Remove "${modelName}" from saved image models?`)) {
                    globalSettings.savedOpenRouterImageModels = globalSettings.savedOpenRouterImageModels.filter(m => m !== modelName);
                    StateManager.saveGlobalSettings();
                    this.renderSavedOpenRouterImageModels();
                }
            },

            /**
             * Selects a saved OpenRouter image model and updates the input field.
             * @param {string} modelName - The name of the model to select.
             */
            selectOpenRouterImageModel(modelName) {
                const input = document.getElementById('image-gen-openrouter-model-input');
                if (input) {
                    input.value = modelName;
                    // Manually trigger the input event to update the Global Settings via the listener
                    input.dispatchEvent(new Event('input'));
                }
            },

            /**
             * Renders the list of saved OpenRouter image models in the settings modal.
             */
            renderSavedOpenRouterImageModels() {
                const container = document.getElementById('image-gen-openrouter-saved-models-list');
                if (!container) return;

                const globalSettings = StateManager.data.globalSettings;
                const models = globalSettings.savedOpenRouterImageModels || [];

                if (models.length === 0) {
                    container.innerHTML = '<span class="text-xs text-gray-500 italic">No saved models.</span>';
                    return;
                }

                container.innerHTML = models.map(model => {
                    // Simplify: show only the part after the slash if present
                    const shortName = model.includes('/') ? model.split('/').slice(1).join('/') : model;

                    return `
            <div class="inline-flex items-center bg-black/30 border border-gray-600 rounded-lg overflow-hidden" title="${model}">
                <button onclick="AppController.selectOpenRouterImageModel('${model}')" class="px-3 py-1 text-xs text-gray-300 hover:text-white hover:bg-white/10 transition-colors truncate max-w-[200px]">
                    ${shortName}
                </button>
                <button onclick="AppController.deleteOpenRouterImageModel('${model}')" class="px-2 py-1 text-xs text-gray-500 hover:text-red-400 hover:bg-black/20 border-l border-gray-600 transition-colors" title="Remove">
                    <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </div>
        `;
                }).join('');
            }
        };




        /**
         * =================================================================================================
         * LibraryController Module
         * Handles Story Creation, Deletion, Import/Export, and Library Management.
         * =================================================================================================
         */
        const LibraryController = {

            // --- Story Management ---

            /**
             * Creates a new, blank story in the library.
             */
            async createNewStory() {
                UIManager.showLoadingSpinner('Creating new story...');
                try {
                    // 1. Call the service to create and save the story in the DB
                    const newStory = await StoryService.createNewStory();

                    // 2. Add the new story (which is a stub) to the in-memory library
                    const library = StateManager.getLibrary();
                    library.stories.push(newStory);

                    // 3. Clear active session to ensure clean slate
                    library.active_story_id = null;
                    library.active_narrative_id = null;
                    StateManager.saveLibrary(); // Saves the (cleared) active IDs

                    // 4. Refresh the UI and open the details for the new story
                    UIManager.renderLibraryInterface();
                    UIManager.openStoryDetails(newStory.id);

                } catch (e) {
                    console.error("Failed to create new story:", e);
                    alert("Error: Could not create a new story in the database.");
                } finally {
                    UIManager.hideLoadingSpinner();
                }
            },

            /**
             * Renames a scenario within a story.
             * @param {string} storyId - The ID of the story.
             * @param {string} scenarioId - The ID of the scenario.
             */
            async renameScenario(storyId, scenarioId) {
                const story = await DBService.getStory(storyId);
                if (!story) return;

                const scenario = story.scenarios.find(sc => sc.id === scenarioId);
                if (!scenario) return;

                const newName = prompt("Enter new name for this scenario:", scenario.name);
                if (!newName || newName.trim() === "") return;

                try {
                    scenario.name = newName.trim();
                    story.last_modified = new Date().toISOString();

                    // 1. Save to DB
                    await DBService.saveStory(story);

                    // 2. Update In-Memory Library Stub
                    const library = StateManager.getLibrary();
                    const storyInLibrary = library.stories.find(s => s.id === storyId);
                    if (storyInLibrary) {
                        storyInLibrary.scenarios = story.scenarios;
                        storyInLibrary.last_modified = story.last_modified;
                    }

                    // 3. Refresh UI
                    UIManager.openStoryDetails(storyId);

                } catch (e) {
                    console.error("Failed to rename scenario:", e);
                    alert(`Error: ${e.message}`);
                }
            },

            /**
             * Deletes a story and all associated data.
             * @param {string} storyId - The ID of the story to delete.
             */
            async deleteStory(storyId) {
                const proceed = await UIManager.showConfirmationPromise('Are you sure you want to permanently delete this entire story, including all its narratives and scenarios?');
                if (!proceed) return;

                UIManager.showLoadingSpinner('Deleting story...');
                try {
                    // 1. Call the service to delete everything from DB
                    await StoryService.deleteStory(storyId);

                    // 2. Update the in-memory library
                    const library = StateManager.getLibrary();
                    library.stories = library.stories.filter(s => s.id !== storyId);
                    StateManager.updateTagCache();

                    // 3. Handle active session
                    if (library.active_story_id === storyId) {
                        library.active_story_id = null;
                        library.active_narrative_id = null;
                        StateManager.saveLibrary(); // Save cleared IDs
                        window.location.reload();
                    } else {
                        StateManager.saveLibrary();
                        // Close modal if open
                        AppController.closeModal('story-details-modal');
                        UIManager.renderLibraryInterface(); // Refresh library list
                    }
                } catch (e) {
                    console.error("Failed to delete story:", e);
                    alert(`Error: ${e.message}`);
                } finally {
                    UIManager.hideLoadingSpinner();
                }
            },

            /**
             * Duplicates an entire story structure, including narratives and scenarios.
             * @param {string} storyId - The ID of the story to duplicate.
             */
            async duplicateStory(storyId) {
                UIManager.showLoadingSpinner('Duplicating story...');
                try {
                    // 1. Get all data for the original story
                    const originalStory = await DBService.getStory(storyId);
                    if (!originalStory) throw new Error("Original story not found in database.");

                    const originalNarrativeStubs = originalStory.narratives || [];
                    const originalNarratives = await Promise.all(
                        originalNarrativeStubs.map(stub => DBService.getNarrative(stub.id))
                    );

                    // 2. Create new story object
                    const newStory = JSON.parse(JSON.stringify(originalStory));
                    newStory.id = UTILITY.uuid();
                    newStory.name = `${originalStory.name || 'Untitled Story'} (Copy)`;
                    newStory.last_modified = new Date().toISOString();
                    newStory.created_date = new Date().toISOString();

                    // Create ID Mapping for Characters
                    // We must track which Old ID maps to which New ID so we can update the chat history
                    const charIdMap = {};
                    (newStory.characters || []).forEach(c => {
                        const oldId = c.id;
                        const newId = UTILITY.uuid();
                        c.id = newId;
                        charIdMap[oldId] = newId;
                    });

                    // Helper to remap IDs in a history array
                    const remapHistory = (history) => {
                        if (!Array.isArray(history)) return;
                        history.forEach(msg => {
                            if (msg.character_id && charIdMap[msg.character_id]) {
                                msg.character_id = charIdMap[msg.character_id];
                            }
                        });
                    };

                    // Helper to remap active character lists
                    const remapActiveIds = (ids) => {
                        if (!Array.isArray(ids)) return ids;
                        return ids.map(id => charIdMap[id] || id);
                    };

                    // 3. Create new narratives with new IDs AND Remapped Character References
                    const newNarratives = [];
                    const newNarrativeStubs = [];

                    for (const narrative of originalNarratives) {
                        if (!narrative) continue;
                        const newNarrative = JSON.parse(JSON.stringify(narrative));
                        newNarrative.id = UTILITY.uuid();

                        // Update Chat History to point to new Character IDs
                        if (newNarrative.state && newNarrative.state.chat_history) {
                            remapHistory(newNarrative.state.chat_history);
                        }

                        // Update Active Character List
                        if (newNarrative.active_character_ids) {
                            newNarrative.active_character_ids = remapActiveIds(newNarrative.active_character_ids);
                        }

                        newNarratives.push(newNarrative);
                        newNarrativeStubs.push({ id: newNarrative.id, name: newNarrative.name, last_modified: newNarrative.last_modified });
                    }

                    // 4. Update new story with new narrative stubs
                    newStory.narratives = newNarrativeStubs;

                    // 5. Update Scenarios and other IDs
                    (newStory.scenarios || []).forEach(s => {
                        s.id = UTILITY.uuid();
                        // Update Scenario Example Dialogue and Active Lists
                        remapHistory(s.example_dialogue);
                        if (s.active_character_ids) {
                            s.active_character_ids = remapActiveIds(s.active_character_ids);
                        }
                    });

                    (newStory.dynamic_entries || []).forEach(e => e.id = UTILITY.uuid());

                    // 6. Save all new data to DB
                    await DBService.saveStory(newStory);
                    await Promise.all(newNarratives.map(n => DBService.saveNarrative(n)));

                    // 7. Update in-memory library
                    this.updateSearchIndex(newStory);
                    const library = StateManager.getLibrary();
                    library.stories.push(newStory);
                    StateManager.updateTagCache();

                    UIManager.renderLibraryInterface();
                    UIManager.openStoryDetails(newStory.id);

                } catch (e) {
                    console.error("Failed to duplicate story:", e);
                    alert(`Error: ${e.message}`);
                } finally {
                    UIManager.hideLoadingSpinner();
                }
            },

            /**
             * Updates a specific field of a story object (debounced).
             * This handles updating both the Database and the In-Memory Library Stub.
             * @param {string} storyId - The ID of the story.
             * @param {string} field - The field to update.
             * @param {*} value - The new value.
             */
            updateStoryField: debounce(async function (storyId, field, value) {
                try {
                    // 1. Call the service to update the DB
                    const updatedStory = await StoryService.updateStoryField(storyId, field, value);

                    // 2. Update the in-memory stub
                    const library = StateManager.getLibrary();
                    const storyInLibrary = library.stories.find(s => s.id === storyId);
                    if (storyInLibrary) {
                        storyInLibrary[field] = updatedStory[field];
                        storyInLibrary.last_modified = updatedStory.last_modified;
                    }

                    // 3. Update search index if needed
                    if (field === 'creator_notes' || field === 'name') {
                        this.updateSearchIndex(storyInLibrary);
                    }

                    // 4. If this is the active story, sync ReactiveStore to show changes live (e.g. title bar)
                    if (storyId === library.active_story_id && typeof ReactiveStore !== 'undefined') {
                        if (field === 'name') ReactiveStore.state.name = value;
                        // Note: creator_notes isn't usually reactive in the UI, but we could set it if needed
                    }

                } catch (e) {
                    console.error(`Failed to update story field ${field}:`, e);
                }
            }, 300),

            /**
             * Updates a story's tags (debounced).
             * @param {string} storyId - The ID of the story.
             * @param {string} value - The comma-separated tags string.
             */
            updateStoryTags: debounce(async function (storyId, value) {
                const tags = value.split(',').map(t => t.trim()).filter(Boolean);
                try {
                    // 1. Call the service to update the DB
                    const updatedStory = await StoryService.updateStoryField(storyId, 'tags', tags);

                    // 2. Update the in-memory stub
                    const library = StateManager.getLibrary();
                    const storyInLibrary = library.stories.find(s => s.id === storyId);
                    if (storyInLibrary) {
                        storyInLibrary.tags = updatedStory.tags;
                        storyInLibrary.last_modified = updatedStory.last_modified;
                    }

                    // 3. Update search and tag cache
                    this.updateSearchIndex(storyInLibrary);
                    StateManager.updateTagCache();

                    // 4. Sync ReactiveStore if active
                    if (storyId === library.active_story_id && typeof ReactiveStore !== 'undefined') {
                        ReactiveStore.state.tags = tags;
                    }

                } catch (e) {
                    console.error("Failed to update story tags:", e);
                }
            }, 500),

            // --- Scenario & Narrative Management ---

            /**
             * Loads a specific narrative and reloads the page.
             * @param {string} storyId - The ID of the story.
             * @param {string} narrativeId - The ID of the narrative.
             */
            loadNarrative(storyId, narrativeId) {
                const library = StateManager.getLibrary();
                library.active_story_id = storyId;
                library.active_narrative_id = narrativeId;
                StateManager.saveLibrary(); // Save IDs to localStorage
                window.location.reload();
            },

            /**
             * Creates a new narrative from a scenario template.
             * @param {string} storyId - The ID of the story.
             * @param {string} scenarioId - The ID of the scenario.
             */
            async createNarrativeFromScenario(storyId, scenarioId) {
                UIManager.showLoadingSpinner('Creating new narrative...');
                try {
                    // 1. Force save current state to be safe
                    if (typeof ReactiveStore !== 'undefined') await ReactiveStore.forceSave();

                    // 2. Block auto-save to prevent race condition on reload
                    if (typeof ReactiveStore !== 'undefined' && ReactiveStore.blockAutoSave) {
                        ReactiveStore.blockAutoSave();
                    }

                    const newNarrative = await StoryService.createNarrativeFromScenario(storyId, scenarioId);

                    const library = StateManager.getLibrary();
                    const storyInLibrary = library.stories.find(s => s.id === storyId);

                    if (storyInLibrary) {
                        if (!storyInLibrary.narratives) storyInLibrary.narratives = [];
                        storyInLibrary.narratives.push({
                            id: newNarrative.id,
                            name: newNarrative.name,
                            last_modified: newNarrative.last_modified
                        });
                        storyInLibrary.last_modified = new Date().toISOString();
                    }

                    this.loadNarrative(storyId, newNarrative.id);

                } catch (error) {
                    UIManager.hideLoadingSpinner();
                    console.error("Failed to create narrative from scenario:", error);
                    alert(`Error: ${error.message}`);
                }
            },

            /**
             * Deletes a narrative and its history.
             * @param {string} storyId - The ID of the story.
             * @param {string} narrativeId - The ID of the narrative.
             */
            async deleteNarrative(storyId, narrativeId) {
                const proceed = await UIManager.showConfirmationPromise('Are you sure you want to permanently delete this narrative and all its chat history?');
                if (!proceed) return;

                UIManager.showLoadingSpinner('Deleting narrative...');
                try {
                    const updatedStory = await StoryService.deleteNarrative(storyId, narrativeId);

                    const library = StateManager.getLibrary();
                    const storyInLibrary = library.stories.find(s => s.id === storyId);
                    if (storyInLibrary) {
                        storyInLibrary.narratives = updatedStory.narratives;
                        storyInLibrary.last_modified = updatedStory.last_modified;
                    }

                    if (library.active_narrative_id === narrativeId) {
                        library.active_narrative_id = null;
                        library.active_story_id = null;
                        StateManager.saveLibrary();
                        window.location.reload();
                    } else {
                        StateManager.saveLibrary();
                        UIManager.openStoryDetails(storyId); // Refresh UI
                    }
                } catch (e) {
                    console.error("Failed to delete narrative:", e);
                    alert(`Error: ${e.message}`);
                } finally {
                    UIManager.hideLoadingSpinner();
                }
            },

            /**
             * Duplicates an existing narrative.
             * @param {string} storyId - The ID of the story.
             * @param {string} narrativeId - The ID of the narrative.
             */
            async duplicateNarrative(storyId, narrativeId) {
                UIManager.showLoadingSpinner('Duplicating narrative...');
                try {
                    const story = await DBService.getStory(storyId);
                    const narrative = await DBService.getNarrative(narrativeId);
                    if (!story || !narrative) throw new Error("Data not found.");

                    const newNarrative = JSON.parse(JSON.stringify(narrative));
                    newNarrative.id = UTILITY.uuid();
                    newNarrative.name = `${narrative.name} (Copy)`;
                    newNarrative.last_modified = new Date().toISOString();

                    await DBService.saveNarrative(newNarrative);

                    story.narratives.push({ id: newNarrative.id, name: newNarrative.name, last_modified: newNarrative.last_modified });
                    story.last_modified = new Date().toISOString();
                    await DBService.saveStory(story);

                    const library = StateManager.getLibrary();
                    const storyInLibrary = library.stories.find(s => s.id === storyId);
                    if (storyInLibrary) {
                        storyInLibrary.narratives = story.narratives;
                        storyInLibrary.last_modified = story.last_modified;
                    }

                    UIManager.openStoryDetails(storyId);
                } catch (e) {
                    console.error("Failed to duplicate narrative:", e);
                    alert(`Error: ${e.message}`);
                } finally {
                    UIManager.hideLoadingSpinner();
                }
            },

            /**
             * Deletes a scenario from a story.
             * @param {string} storyId - The ID of the story.
             * @param {string} scenarioId - The ID of the scenario.
             */
            async deleteScenario(storyId, scenarioId) {
                const story = await DBService.getStory(storyId);
                if (!story) return;
                if (story.scenarios.length <= 1) {
                    alert("You cannot delete the last scenario.");
                    return;
                }

                const proceed = await UIManager.showConfirmationPromise('Are you sure you want to delete this scenario?');
                if (!proceed) return;

                try {
                    story.scenarios = story.scenarios.filter(sc => sc.id !== scenarioId);
                    story.last_modified = new Date().toISOString();
                    await DBService.saveStory(story);

                    const library = StateManager.getLibrary();
                    const storyInLibrary = library.stories.find(s => s.id === storyId);
                    if (storyInLibrary) {
                        storyInLibrary.scenarios = story.scenarios;
                        storyInLibrary.last_modified = story.last_modified;
                    }

                    UIManager.openStoryDetails(storyId);
                } catch (e) {
                    console.error("Failed to delete scenario:", e);
                    alert(`Error: ${e.message}`);
                }
            },

            /**
             * Duplicates an existing scenario.
             * @param {string} storyId - The ID of the story.
             * @param {string} scenarioId - The ID of the scenario.
             */
            async duplicateScenario(storyId, scenarioId) {
                UIManager.showLoadingSpinner('Duplicating scenario...');
                try {
                    const story = await DBService.getStory(storyId);
                    const scenario = story.scenarios.find(sc => sc.id === scenarioId);
                    if (!story || !scenario) throw new Error("Data not found.");

                    const newScenario = JSON.parse(JSON.stringify(scenario));
                    newScenario.id = UTILITY.uuid();
                    newScenario.name = `${scenario.name} (Copy)`;
                    story.scenarios.push(newScenario);
                    story.last_modified = new Date().toISOString();

                    await DBService.saveStory(story);

                    const library = StateManager.getLibrary();
                    const storyInLibrary = library.stories.find(s => s.id === storyId);
                    if (storyInLibrary) {
                        storyInLibrary.scenarios = story.scenarios;
                        storyInLibrary.last_modified = story.last_modified;
                    }

                    UIManager.openStoryDetails(storyId);
                } catch (e) {
                    console.error("Failed to duplicate scenario:", e);
                    alert(`Error: ${e.message}`);
                } finally {
                    UIManager.hideLoadingSpinner();
                }
            },

            /**
             * Promotes a narrative to a scenario, saving its current state as a template.
             * @param {string} storyId - The ID of the story.
             * @param {string} narrativeId - The ID of the narrative.
             */
            async elevateNarrativeToScenario(storyId, narrativeId) {
                UIManager.showLoadingSpinner('Creating scenario from chat...');
                try {
                    // Re-use Controller logic logic, but ensure it's fully encapsulated here
                    const story = await DBService.getStory(storyId);
                    const narrative = await DBService.getNarrative(narrativeId);
                    if (!story || !narrative) throw new Error("Data not found.");

                    const firstMessage = (narrative.state.chat_history || []).find(m => !m.isHidden && m.type === 'chat');
                    const exampleDialogue = (narrative.state.chat_history || []).filter(m => m.isHidden);
                    let activeIDs = narrative.active_character_ids || (story.characters || []).map(c => c.id);

                    const newScenario = {
                        id: UTILITY.uuid(),
                        name: `${narrative.name} (Scenario)`,
                        message: firstMessage ? firstMessage.content : "The story continues...",
                        static_entries: JSON.parse(JSON.stringify(narrative.state.static_entries || [])),
                        worldMap: JSON.parse(JSON.stringify(narrative.state.worldMap || {})),
                        example_dialogue: JSON.parse(JSON.stringify(exampleDialogue)),
                        active_character_ids: activeIDs,
                        // Snapshot dynamic entries and prompts from current story settings
                        dynamic_entries: JSON.parse(JSON.stringify(story.dynamic_entries || [])),
                        prompts: {
                            system_prompt: story.system_prompt,
                            event_master_base_prompt: story.event_master_base_prompt,
                            prompt_persona_gen: story.prompt_persona_gen,
                            prompt_world_map_gen: story.prompt_world_map_gen,
                            prompt_location_gen: story.prompt_location_gen,
                            prompt_entry_gen: story.prompt_entry_gen,
                            prompt_location_memory_gen: story.prompt_location_memory_gen,
                            font: story.font,
                            backgroundImageURL: story.backgroundImageURL,
                            bubbleOpacity: story.bubbleOpacity,
                            chatTextColor: story.chatTextColor
                        }
                    };

                    story.scenarios.push(newScenario);
                    story.last_modified = new Date().toISOString();
                    await DBService.saveStory(story);

                    const library = StateManager.getLibrary();
                    const storyInLibrary = library.stories.find(s => s.id === storyId);
                    if (storyInLibrary) {
                        storyInLibrary.scenarios = story.scenarios;
                        storyInLibrary.last_modified = story.last_modified;
                    }

                    UIManager.openStoryDetails(storyId);
                } catch (e) {
                    console.error("Failed to elevate narrative:", e);
                    alert(`Error: ${e.message}`);
                } finally {
                    UIManager.hideLoadingSpinner();
                }
            },

            // === STORY ARCHITECT ===

            RUNTIME_GEN: {
                draftStory: null,
                userPrompt: "",
                conceptData: null
            },

            /**
             * Phase 1 of Story Architect: Generates the initial story concept from a user prompt.
             * @param {Event} event - The click event from the Generate button.
             */
            async generateStoryPhase1(event) {
                const input = document.getElementById('gen-story-prompt');
                const userPrompt = input.value.trim();
                if (!userPrompt) { alert("Please enter a prompt."); return; }

                this.RUNTIME_GEN.userPrompt = userPrompt;

                // 1. VISUAL FEEDBACK: Disable Button
                let btn = null;
                if (event && event.target) {
                    btn = event.target.closest('button');
                    if (btn) {
                        btn.disabled = true;
                        btn.innerHTML = `<svg class="animate-spin -ml-1 mr-2 h-4 w-4 text-white inline" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg> Drafting...`;
                    }
                }

                // Reset UI
                document.getElementById('gen-story-input-view').classList.add('hidden');
                document.getElementById('gen-story-progress-view').classList.remove('hidden');
                document.getElementById('gen-story-progress-view').classList.add('flex');

                const updateUI = (pct, msg) => {
                    document.getElementById('gen-story-bar').style.width = `${pct}%`;
                    document.getElementById('gen-story-status').textContent = msg;
                };

                try {
                    // STEP 1: CONCEPT
                    updateUI(10, "Architecting the universe...");

                    // REFINED PROMPT: Demanding atmosphere and depth
                    const conceptPrompt = `You are a creative director for a high-quality interactive novel. Based on this prompt: "${userPrompt}", create a detailed story bible. Be imaginitive and unexpected yet logical to craft a world and scenario where participants will desire to explore and become immersed.
                    
                    Notes on output elements:
                    - Story should be as authentic as possible to the initiating prompt. Avoid adding magical elements to a realistic idea, or horror elements to a romantic comedy, for instance. Think about how each character may expand the narrative in compelling ways.
                    - The brief_summary should further define the genre, style, and atmosphere of the story. Then, build out the environment and setting, describe any relevant 'factions' or political alliances, and describe the inciting incident that will serve as the scenario.
                    - Create as many characters as makes sense for the narrative, with a minimum of 3. The first shall be the 'user'.

                    Respond with VALID JSON ONLY:
                    {
                        "title": "A Compelling Story Title",
                        "creator_notes": "An atmospheric, engaging introduction to the story's environment and tone (approx 2 paragraphs). Sell the concept.",
                        "tags": ["tag1", "tag2", "genre", "vibe"],
                        "scenario_name": "A creative name for the starting scene. This sets the tone for how the participants will interact in this world",
                        "brief_summary": "A rich summary of the world, the core conflict, and the stakes involved. Focus on the drama.",
                        "characters": [
                            {"name": "Name", "role": "User", "archetype": "The Protagonist (Describe their situation, not just 'You')"},
                            {"name": "Name", "role": "PrimaryAI", "archetype": "The Companion/Antagonist/Narrator (The main NPC interaction)"},
                            {"name": "Name", "role": "Secondary", "archetype": "Support/World Builder"} 
                        ]
                    }`;

                    const conceptData = await this._callAIWithRetry(conceptPrompt);
                    if (!conceptData) throw new Error("Failed to generate concept.");

                    this.RUNTIME_GEN.conceptData = conceptData;

                    // Switch to Edit/Approval View
                    document.getElementById('gen-story-progress-view').classList.remove('flex');
                    document.getElementById('gen-story-progress-view').classList.add('hidden');
                    document.getElementById('gen-story-approval-view').classList.remove('hidden');
                    document.getElementById('gen-story-approval-view').classList.add('flex');

                    // Populate Inputs for Editing
                    document.getElementById('gen-approval-title-input').value = conceptData.title;
                    document.getElementById('gen-approval-summary-input').value = conceptData.creator_notes; // Using creator_notes as summary for display
                    document.getElementById('gen-approval-tags-input').value = (conceptData.tags || []).join(', ');

                } catch (e) {
                    alert("Generation Error: " + e.message);
                    this.retryGenStory();
                }
            },

            /**
             * Resets the UI to the input phase for regenerating a story concept.
             */
            retryGenStory() {
                this.RUNTIME_GEN.draftStory = null;
                document.getElementById('gen-story-approval-view').classList.add('hidden');
                document.getElementById('gen-story-approval-view').classList.remove('flex');
                document.getElementById('gen-story-input-view').classList.remove('hidden');
            },

            /**
             * Confirms the generated story concept and proceeds to generate lore, characters, and scenario.
             * This is the "Phase 2" of the Story Architect flow.
             */
            async confirmGenStory() {
                // Read Edited Values
                const title = document.getElementById('gen-approval-title-input').value;
                const summary = document.getElementById('gen-approval-summary-input').value;
                const tagsStr = document.getElementById('gen-approval-tags-input').value;
                const tags = tagsStr.split(',').map(t => t.trim()).filter(Boolean);
                const shouldGenerateMap = document.getElementById('gen-approval-map-toggle').checked;

                // UI Switch
                document.getElementById('gen-story-approval-view').classList.remove('flex');
                document.getElementById('gen-story-approval-view').classList.add('hidden');
                document.getElementById('gen-story-progress-view').classList.remove('hidden');
                document.getElementById('gen-story-progress-view').classList.add('flex');

                const updateUI = (pct, msg) => {
                    document.getElementById('gen-story-bar').style.width = `${pct}%`;
                    document.getElementById('gen-story-status').textContent = msg;
                };

                // Init Draft
                const draft = {
                    id: UTILITY.uuid(), created_date: new Date().toISOString(), last_modified: new Date().toISOString(),
                    ...UTILITY.getDefaultApiSettings(), ...UTILITY.getDefaultUiSettings(),
                    ...UTILITY.getDefaultSystemPrompts(), ...UTILITY.getDefaultStorySettings(),
                    characters: [], static_entries: [], narratives: [], scenarios: [], dynamic_entries: [],
                    name: title, creator_notes: summary, tags: tags, backgroundImageURL: ""
                };

                const concept = this.RUNTIME_GEN.conceptData;
                // Update concept summary with user edits
                const contextSummary = `Title: ${title}\nSummary: ${summary}\nCore Conflict: ${concept.brief_summary}`;

                try {
                    // STEP 2: LORE
                    updateUI(20, "Forging history and lore...");

                    // REFINED PROMPT: Focus on worldbuilding flavor, not dry facts.
                    const lorePrompt = `Based on this summary: "${summary}", generate 3-10 deep worldbuilding entries (Lore).
                    Focus on history, culture, factions, secrets, or atmospheric details that make the world feel alive. Avoid generic definitions. Each entry should be an important piece of information within the environment of the story that adds to the narrative complexity. Ensure that each entry is authentic to the genre, style, and scenario of this narrative; a high fantasy narrative will have much differen lore than a slice-of-life tale set in Brooklyn, for example.
                    
                    Title: The entry title should be a clear, direct, and concise name for the entry.

                    Return VALID JSON: { "entries": [{"title": "Entry Title", "content": "Rich, descriptive content..."}] }`;

                    const loreData = await this._callAIWithRetry(lorePrompt);
                    if (loreData && loreData.entries) {
                        draft.static_entries = loreData.entries.map(e => ({ id: UTILITY.uuid(), title: e.title, content: e.content }));
                    }

                    // STEP 3: RELATIONSHIP MATRIX
                    updateUI(30, "Setting the board...");
                    const roster = concept.characters || [];
                    let relationshipContext = "";

                    try {
                        const relPrompt = `Given the characters: ${roster.map(c => c.name + ' (' + c.role + ')').join(', ')}.
                        Story Context: ${contextSummary}.
                        Define the specific relationship dynamics between the User and the Primary AI character, and then between other characters in this narrative. Focus on how they feel about each other and what their goals are when interacting with each other.
                        Return VALID JSON: { "relationship_description": "Analysis of their dynamic (allies, enemies, strangers, etc)." }`;

                        const relData = await this._callAIWithRetry(relPrompt);
                        if (relData && relData.relationship_description) {
                            relationshipContext = `\nRELATIONSHIPS:\n${relData.relationship_description}`;
                        }
                    } catch (e) { console.warn("Relationship gen failed, skipping."); }

                    // STEP 4: CHARACTERS (Sequential with Relationship Injection & Image Generation)
                    for (let i = 0; i < roster.length; i++) {
                        const charDef = roster[i];
                        updateUI(35 + (i * 10), `Breathing life into ${charDef.name}...`);

                        // Inject relationship context
                        const charContext = `${contextSummary}\nCharacter Role: ${charDef.role}\nArchetype: ${charDef.archetype}${relationshipContext}`;
                        const charData = await NarrativeController.generateCharacterProfile(charDef.name, charContext);

                        if (charData) {
                            const charId = UTILITY.uuid();
                            let imageUrl = '';

                            // --- AUTOMATED IMAGE GENERATION ---
                            // Only attempt if we have a backend configured (implicit check via service)
                            try {
                                updateUI(35 + (i * 10) + 5, `Painting ${charDef.name}...`);
                                const imagePrompt = `portrait of ${charDef.name}, ${charData.short_description || charData.description}, ${charDef.archetype}, detailed face, fantasy art, masterpiece`;
                                console.log(`Auto-Generating Image for ${charDef.name}:`, imagePrompt);

                                const blob = await ImageGenerationService.generateImage(imagePrompt);
                                if (blob) {
                                    await DBService.saveImage(charId, blob);
                                    imageUrl = `local_idb_${charId}`;
                                    // Pre-cache for immediate display upon story load
                                    UIManager.RUNTIME.characterImageCache[charId] = URL.createObjectURL(blob);
                                }
                            } catch (imgErr) {
                                console.warn(`Failed to auto-generate image for ${charDef.name}:`, imgErr);
                                // Proceed without image
                            }
                            // ----------------------------------

                            draft.characters.push({
                                id: charId,
                                name: charDef.name,
                                description: charData.description || "No description.",
                                short_description: charData.short_description || "A character.",
                                model_instructions: charData.model_instructions || `Act as ${charDef.name}.`,
                                tags: charData.tags || [],
                                is_user: charDef.role === 'User',
                                is_active: true,
                                is_narrator: charDef.role === 'PrimaryAI' && !roster.some(r => r.role === 'User'),
                                color: NarrativeController.CONSTANTS.CHARACTER_COLORS[i % NarrativeController.CONSTANTS.CHARACTER_COLORS.length],
                                image_url: imageUrl,
                                extra_portraits: []
                            });
                        }
                    }

                    // Fallback: Ensure a user exists if AI didn't generate one
                    if (!draft.characters.some(c => c.is_user)) {
                        draft.characters.push({ id: UTILITY.uuid(), name: "Traveler", description: "You.", short_description: "You.", is_user: true, is_active: true, color: { base: '#4b5563', bold: '#fff' }, image_url: '', extra_portraits: [], tags: [], model_instructions: "Act as User." });
                    }

                    // STEP 5: SCENARIO (Logic Fix: Determine Speaker First)
                    updateUI(80, "Setting the scene...");

                    // Identify the NPC Speaker and the User Target
                    const speakerChar = draft.characters.find(c => !c.is_user) || draft.characters[0];
                    const userChar = draft.characters.find(c => c.is_user) || { name: "You" };

                    // REFINED PROMPT: Enforce Perspective and Speaker Identity
                    const scenarioPrompt = `Context: ${contextSummary}${relationshipContext}
                    
                    Task:
                    1. Write an "opening_message" for the chat. This message is spoken or enacted by ${speakerChar.name}. 
                       It must be directed AT ${userChar.name}. 
                       Do NOT describe ${userChar.name}'s thoughts or actions. 
                       Only describe what ${speakerChar.name} says or does.
                       Use 'prose-style' writing with speech in quotations, rather than roleplay-style writing with actions in parentheses or asterisks.
                       Organically set the setting, scene, and at least a hint of the inciting incident so that the participants know how to interact.
                    
                    2. Write "scenario_lore". This is a static description of the narrative genre, style, and atmosphere, the setting/scene, and the inciting incident. This should establish the initial goals or intent of ${speakerChar.name}. 
                       Write this in 3rd Person (e.g., "The room is dark," not "You are in a dark room").
                    
                    Return VALID JSON:
                    {
                        "opening_message": "The opening lines of the scene...",
                        "scenario_lore": "Static lore describing the scene..."
                    }`;

                    const scenData = await this._callAIWithRetry(scenarioPrompt);
                    const firstMsg = scenData ? scenData.opening_message : "The story begins.";

                    if (scenData && scenData.scenario_lore) {
                        draft.static_entries.push({ id: UTILITY.uuid(), title: "Current Scenario", content: scenData.scenario_lore });
                    }

                    // STEP 6: SMART MAP SEEDING
                    updateUI(90, "Singing the world into existence...");
                    let grid = UTILITY.createDefaultMapGrid();

                    if (shouldGenerateMap) {
                        try {
                            // Extract Titles and Content for seeding
                            const loreDetails = draft.static_entries.map(e => `${e.title}: ${e.content}`).join('\n');
                            const mapContext = {
                                characters: draft.characters.map(c => c.name).join(', '),
                                static_lore: `${contextSummary}\nKey worldbuilding to respond to and expand upon with locations that are authentic and logical within the story framework and scale. Provide a physical description of the location, along with any importance within the environment or scenario:\n${loreDetails}`,
                                recent_events: firstMsg
                            };
                            grid = await WorldController.generateMapGrid(mapContext);
                        } catch (e) {
                            console.warn("Map Gen Failed, using default", e);
                        }
                    } else {
                        console.log("Skipping map generation per user request.");
                    }

                    // FINAL SAVE
                    updateUI(100, "Finalizing...");
                    const newScenario = {
                        id: UTILITY.uuid(), name: concept.scenario_name || "The Beginning", message: firstMsg,
                        active_character_ids: draft.characters.map(c => c.id),
                        static_entries: [], dynamic_entries: [], example_dialogue: [],
                        worldMap: { grid: grid, currentLocation: { x: 4, y: 4 }, destination: { x: null, y: null }, path: [] },
                        prompts: UTILITY.getDefaultSystemPrompts()
                    };
                    draft.scenarios.push(newScenario);

                    const newNarrative = {
                        id: UTILITY.uuid(), name: `${newScenario.name} - Chat`,
                        last_modified: new Date().toISOString(),
                        active_character_ids: draft.characters.map(c => c.id),
                        state: {
                            chat_history: [], messageCounter: 1,
                            static_entries: [...draft.static_entries],
                            worldMap: JSON.parse(JSON.stringify(newScenario.worldMap))
                        }
                    };

                    // Assign the message strictly to the NPC speaker we identified earlier
                    newNarrative.state.chat_history.push({
                        character_id: speakerChar.id,
                        content: firstMsg,
                        type: 'chat',
                        emotion: 'neutral',
                        timestamp: new Date().toISOString()
                    });

                    draft.narratives.push({ id: newNarrative.id, name: newNarrative.name, last_modified: newNarrative.last_modified });

                    await DBService.saveStory(draft);
                    await DBService.saveNarrative(newNarrative);

                    StateManager.getLibrary().stories.push(draft);
                    LibraryController.updateSearchIndex(draft);
                    StateManager.updateTagCache();

                    // Auto Load
                    StateManager.getLibrary().active_story_id = draft.id;
                    StateManager.getLibrary().active_narrative_id = newNarrative.id;
                    StateManager.saveLibrary();

                    AppController.closeModal('gen-story-modal');
                    window.location.reload();

                } catch (e) {
                    console.error(e);
                    alert("Generation Error: " + e.message);
                    this.retryGenStory();
                }
            },

            /**
             * Helper: Calls the AI service with automatic retries for JSON parsing.
             * @param {string} prompt - The prompt to send.
             * @param {number} [retries=2] - Number of retry attempts.
             * @returns {Promise<Object|null>} - The parsed JSON response or null on failure.
             */
            async _callAIWithRetry(prompt, retries = 2) {
                for (let i = 0; i <= retries; i++) {
                    try {
                        const res = await APIService.callAI(prompt, true);
                        const json = UTILITY.extractAndParseJSON(res);
                        if (json) return json;
                        throw new Error("Invalid JSON");
                    } catch (e) {
                        if (i === retries) return null;
                    }
                }
            },

            // --- Import / Export & File Handling ---

            /**
             * Handles the upload of a single story file (JSON, PNG, BYAF, ZIP).
             * Parses the file and imports it into the library.
             * @param {Event} event - The file input change event.
             */
            async handleFileUpload(event) {
                const file = event.target.files[0];
                if (!file) return;
                UIManager.showLoadingSpinner('Parsing file...');
                try {
                    // Accept backgroundImageBlob from the parser
                    const { story: newStory, imageBlob, backgroundImageBlob } = await ImportExportService.parseUploadedFile(file);
                    const library = StateManager.getLibrary();

                    // Duplicate Name Check
                    const existingStory = library.stories.find(s => s.name && newStory.name && s.name.toLowerCase() === newStory.name.toLowerCase());
                    if (existingStory) {
                        const now = new Date();
                        // Simple timestamp
                        newStory.name = `${newStory.name} - ${Date.now()}`;
                    }

                    // Separating Narratives from the Story Object
                    const narratives = newStory.narratives || [];
                    const narrativeStubs = narratives.map(n => ({ id: n.id, name: n.name, last_modified: n.last_modified }));
                    newStory.narratives = narrativeStubs;

                    // 1. Save Story to DB
                    await DBService.saveStory(newStory);

                    // 2. Save Narratives to DB (Sequentially for memory safety)
                    if (narratives.length > 0) {
                        for (const n of narratives) {
                            await DBService.saveNarrative(n);
                        }
                    }

                    // 3. Update In-Memory Library
                    library.stories.push(newStory);

                    // 4. Save Primary Image to DB
                    const primaryAiChar = newStory.characters?.find(c => !c.is_user);
                    if (imageBlob && primaryAiChar && primaryAiChar.id) {
                        await DBService.saveImage(primaryAiChar.id, imageBlob);

                        // Update Cache
                        UIManager.RUNTIME.characterImageCache = UIManager.RUNTIME.characterImageCache || {};
                        if (UIManager.RUNTIME.characterImageCache[primaryAiChar.id]) URL.revokeObjectURL(UIManager.RUNTIME.characterImageCache[primaryAiChar.id]);
                        UIManager.RUNTIME.characterImageCache[primaryAiChar.id] = URL.createObjectURL(imageBlob);
                    }

                    // Save Background Image if the parser found one (BYAF or JSON)
                    if (backgroundImageBlob) {
                        const bgKey = `bg_${newStory.id}`;
                        await DBService.saveImage(bgKey, backgroundImageBlob);

                        // Update the story setting to use local background
                        newStory.backgroundImageURL = 'local_idb_background';
                        await DBService.saveStory(newStory);
                    }

                    this.updateSearchIndex(newStory);
                    StateManager.updateTagCache();
                    StateManager.saveLibrary();
                    UIManager.hideLoadingSpinner();
                    alert(`Story "${newStory.name}" imported successfully!`);
                    UIManager.renderLibraryInterface();
                    AppController.closeModal('io-hub-modal');

                } catch (err) {
                    UIManager.hideLoadingSpinner();
                    alert(`Error importing file: ${err.message}`);
                } finally {
                    event.target.value = '';
                }
            },

            /**
             * Handles the bulk import of multiple story files from a directory.
             * Uses the File System Access API to read a directory.
             */
            async handleBulkImport() {
                if (!window.showDirectoryPicker) {
                    alert("Your browser does not support directory selection.");
                    return;
                }
                try {
                    const dirHandle = await window.showDirectoryPicker();
                    UIManager.showLoadingSpinner('Starting bulk import...');

                    let processedFiles = 0;
                    const failedFiles = [];
                    const importedStoryNames = [];
                    const library = StateManager.getLibrary();

                    for await (const entry of dirHandle.values()) {
                        if (entry.kind !== 'file' || !entry.name) continue;
                        const lowerCaseName = entry.name.toLowerCase();

                        if (lowerCaseName.endsWith('.png') || lowerCaseName.endsWith('.byaf') || lowerCaseName.endsWith('.zip') || lowerCaseName.endsWith('.json')) {
                            UIManager.showLoadingSpinner(`Processing file ${++processedFiles}: ${entry.name}`);
                            try {
                                const file = await entry.getFile();

                                // 1. Parse the file into memory
                                const { story: newStory, imageBlob } = await ImportExportService.parseUploadedFile(file, false);

                                if (!newStory || !newStory.name) throw new Error("Invalid parsed story data.");

                                // 2. Handle Duplicate Names
                                const existingStory = library.stories.find(s => s.name && s.name.toLowerCase() === newStory.name.toLowerCase());
                                if (existingStory) {
                                    newStory.name = `${newStory.name} - ${Date.now()}`;
                                }

                                // 3. Separate heavy narrative data from the story object
                                // We must separate the heavy narrative data from the story object to ensure the story object remains lightweight.
                                const narratives = newStory.narratives || [];
                                const narrativeStubs = narratives.map(n => ({
                                    id: n.id,
                                    name: n.name,
                                    last_modified: n.last_modified
                                }));

                                // Replace full narratives with stubs in the story object
                                newStory.narratives = narrativeStubs;

                                // Save the Story to DB
                                await DBService.saveStory(newStory);

                                // Save all Narratives to DB
                                for (const narrative of narratives) {
                                    await DBService.saveNarrative(narrative);
                                }

                                // 4. Save Image to DB
                                const primaryAiChar = newStory.characters?.find(c => !c.is_user);
                                if (imageBlob && primaryAiChar) {
                                    await DBService.saveImage(primaryAiChar.id, imageBlob);

                                    // Update cache immediately so it shows in UI
                                    UIManager.RUNTIME.characterImageCache = UIManager.RUNTIME.characterImageCache || {};
                                    if (UIManager.RUNTIME.characterImageCache[primaryAiChar.id]) {
                                        URL.revokeObjectURL(UIManager.RUNTIME.characterImageCache[primaryAiChar.id]);
                                    }
                                    UIManager.RUNTIME.characterImageCache[primaryAiChar.id] = URL.createObjectURL(imageBlob);
                                }

                                // 5. Update In-Memory Library (UI)
                                library.stories.push(newStory);
                                this.updateSearchIndex(newStory);
                                importedStoryNames.push(newStory.name);

                            } catch (err) {
                                console.error(`Failed to import ${entry.name}`, err);
                                failedFiles.push({ name: entry.name, reason: err.message || 'Unknown error' });
                            }
                        }
                    }

                    StateManager.updateTagCache();
                    // Save the library list order/meta-data
                    StateManager.saveLibrary();

                    UIManager.hideLoadingSpinner();
                    UIManager.showBulkImportReport(importedStoryNames, failedFiles);
                    UIManager.renderLibraryInterface();

                } catch (err) {
                    UIManager.hideLoadingSpinner();
                    if (err.name !== 'AbortError') alert(`Bulk import error: ${err.message}`);
                }
            },

            /**
             * Imports a full library backup from a ZIP file.
             * Replaces the current library with the imported one.
             * @param {Event} event - The file input change event.
             */
            async importLibrary(event) {
                const file = event.target.files[0];
                if (!file) return;
                event.target.value = ''; // Reset

                try {
                    const proceed = await UIManager.showConfirmationPromise('WARNING: This will permanently replace your entire story library. Are you sure?');
                    if (proceed) {
                        // Prevent ReactiveStore from saving the *old* state during the unload/reload cycle.
                        // If we don't do this, the 'beforeunload' event will trigger forceSave(), which will 
                        // write the old in-memory state back to the DB, corrupting the fresh import.
                        if (typeof ReactiveStore !== 'undefined') {
                            ReactiveStore.blockAutoSave();
                        }

                        // Clear in-memory references to prevent any accidental UI reads/writes during the process
                        StateManager.data.library.stories = [];
                        StateManager.data.activeNarrativeState = {};

                        UIManager.showLoadingSpinner('Importing library... Do not close this tab.');

                        await StoryService.importLibraryFromZip(file);

                        UIManager.hideLoadingSpinner();
                        alert("Library imported successfully! Reloading...");
                        setTimeout(() => window.location.reload(), 500);
                    }
                } catch (err) {
                    UIManager.hideLoadingSpinner();
                    console.error("Import failed:", err);
                    alert(`Error importing library: ${err.message}`);
                }
            },

            /**
             * Exports the entire library as a ZIP file.
             */
            async exportLibrary() {
                UIManager.showLoadingSpinner('Exporting entire library...');
                try {
                    const result = await StoryService.exportLibraryAsZip();
                    // Handle legacy return (blob only) vs new object return
                    const zipBlob = result.blob || result;
                    const report = result.report || { success: true, errors: [] };

                    const url = URL.createObjectURL(zipBlob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `ellipsis_library_backup_${new Date().toISOString().split('T')[0]}.zip`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);

                    if (report.errors && report.errors.length > 0) {
                        const errorMsg = report.errors.map(e => ` ${e.key}: ${e.error}`).join('\n');
                        alert(` Export Partial Success\n\nThe backup was created, BUT ${report.errors.length} files failed to be included:\n\n${errorMsg}\n\nPlease check your Console for details.`);
                        console.error("Export Failures:", report.errors);
                    }
                } catch (e) {
                    alert(`Library export failed: ${e.message}`);
                } finally {
                    UIManager.hideLoadingSpinner();
                }
            },

            /**
             * Exports the current story in the specified format (JSON, PNG, BYAF).
             * @param {string} format - The format to export as ('json', 'png', 'byaf').
             */
            /**
             * Exports the current story in the specified format (JSON, PNG, BYAF).
             * @param {string} format - The format to export as ('json', 'png', 'byaf').
             */
            async exportStoryAs(format) {
                const library = StateManager.getLibrary();
                const storyId = library.active_story_id;
                const narrativeId = library.active_narrative_id;

                if (!storyId || !narrativeId) {
                    alert("Please load a story to export.");
                    return;
                }

                if (format !== 'json' && format !== 'zip') {
                    const proceed = await UIManager.showConfirmationPromise("Exporting to a non-Ellipsis format may result in data loss. Continue?");
                    if (!proceed) return;
                }

                UIManager.showLoadingSpinner(`Exporting as ${format.toUpperCase()}...`);
                try {
                    // Fetch the FULL Story object from DB to ensure we have all characters and metadata
                    // The library stub is insufficient for export, especially for ZIPs which need image checks
                    const story = await DBService.getStory(storyId);

                    // Fetch the FULL narrative object from DB
                    const narrative = await DBService.getNarrative(narrativeId);

                    if (!story) throw new Error("Story not found in database.");
                    if (!narrative) throw new Error("Narrative data not found in database.");

                    // Default to the first non-user character (The "AI")
                    const selectorVal = document.getElementById('export-primary-character-selector')?.value;
                    const primaryCharId = selectorVal || story.characters?.find(c => !c.is_user)?.id;

                    // Ensure state exists to prevent crashes if data is malformed
                    if (!narrative.state) narrative.state = { worldMap: {}, chat_history: [], static_entries: [] };

                    if ((format === 'png' || format === 'byaf') && !primaryCharId) {
                        throw new Error("No AI character found to export.");
                    }

                    let blob, filename;
                    switch (format) {
                        case 'json':
                            // Hydrate the narrative stubs with full data
                            // The story object in memory only has stubs. We need the real data from IDB.
                            const fullNarratives = await Promise.all(
                                (story.narratives || []).map(n => DBService.getNarrative(n.id))
                            );

                            // Create a clone to avoid mutating the live object with heavy data
                            const exportObj = JSON.parse(JSON.stringify(story));
                            // Replace stubs with full objects (filtering out any nulls from DB errors)
                            exportObj.narratives = fullNarratives.filter(n => n);

                            blob = ImportExportService.exportStoryAsJSON(exportObj);
                            filename = `${story.name}.json`;
                            break;
                        case 'png':
                            blob = await ImportExportService.exportStoryAsV2(story, narrative, primaryCharId);
                            filename = `${story.name}.png`;
                            break;
                        case 'byaf':
                            blob = await ImportExportService.exportStoryAsBYAF(story, narrative, primaryCharId);
                            filename = `${story.name}.byaf`;
                            break;
                        case 'zip':
                            blob = await ImportExportService.exportStoryAsZip(story, narrative);
                            filename = `${story.name}.zip`;
                            break;
                    }

                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename.replace(/[/\\?%*:|"<>]/g, '-');
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);

                } catch (e) {
                    console.error(e);
                    alert(`Export failed: ${e.message}`);
                } finally {
                    UIManager.hideLoadingSpinner();
                }
            },

            // --- Meta / AI Helpers ---

            /**
             * Generates AI notes for the story based on its content.
             * @param {Event} event - The click event.
             * @param {string} storyId - The ID of the story.
             */
            async generateStoryNotesAI(event, storyId) {
                const context = await StoryService.buildStoryContext(storyId);
                const state = StateManager.getState(); // Access prompts from active state if avail, else defaults
                const prompt = state.prompt_story_notes_gen || UTILITY.getDefaultSystemPrompts().prompt_story_notes_gen;

                const result = await this._generateContentForField(event, prompt, { context });
                if (result) {
                    this.updateStoryField(storyId, 'creator_notes', result);
                    UIManager.openStoryDetails(storyId);
                }
            },

            /**
             * Generates AI tags for the story based on its content.
             * @param {Event} event - The click event.
             * @param {string} storyId - The ID of the story.
             */
            async generateStoryTagsAI(event, storyId) {
                const context = await StoryService.buildStoryContext(storyId);
                const state = StateManager.getState();
                const prompt = state.prompt_story_tags_gen || UTILITY.getDefaultSystemPrompts().prompt_story_tags_gen;

                const result = await this._generateContentForField(event, prompt, { context });
                if (result) {
                    const newTags = result.split(',').map(t => t.trim().toLowerCase());
                    const library = StateManager.getLibrary();
                    const story = library.stories.find(s => s.id === storyId);
                    const combined = [...new Set([...(story.tags || []), ...newTags])];
                    this.updateStoryTags(storyId, combined.join(', '));
                    UIManager.openStoryDetails(storyId);
                }
            },

            // --- Global Image Handling ---

            /**
             * Handles the upload of a custom background image for the story.
             * @param {Event} event - The file input change event.
             */
            async handleBackgroundImageUpload(event) {
                const file = event.target.files?.[0];
                if (!file) return;
                if (file.size > 5 * 1024 * 1024) { alert("Image too large (>5MB)."); return; }

                const library = StateManager.getLibrary();
                const storyId = library.active_story_id;
                if (!storyId) { alert("No active story to save background to."); return; }

                UIManager.showLoadingSpinner('Processing background...');
                try {
                    const blob = await ImageProcessor.processImageAsBlob(file);

                    // Save with Story-Specific Key (bg_UUID)
                    const key = `bg_${storyId}`;
                    const saved = await DBService.saveImage(key, blob);

                    if (!saved) throw new Error("Failed to save to database.");

                    if (UIManager.RUNTIME.globalBackgroundImageCache) URL.revokeObjectURL(UIManager.RUNTIME.globalBackgroundImageCache);
                    UIManager.RUNTIME.globalBackgroundImageCache = URL.createObjectURL(blob);

                    // Update State to use the marker
                    if (typeof ReactiveStore !== 'undefined' && ReactiveStore.state) {
                        ReactiveStore.state.backgroundImageURL = 'local_idb_background';
                        // Trigger save to persist the 'local_idb_background' setting to the story object
                        ReactiveStore.forceSave();
                    }

                    UIManager.applyStyling();

                    const bgHint = document.getElementById('background-image-hint');
                    if (bgHint) bgHint.textContent = 'Current: [Local Image]';
                } catch (e) {
                    alert(`Upload failed: ${e.message}`);
                } finally {
                    UIManager.hideLoadingSpinner();
                    event.target.value = '';
                }
            },

            /**
             * Clears the custom background image for the active story.
             */
            async clearBackgroundImage() {
                const library = StateManager.getLibrary();
                const storyId = library.active_story_id;

                // Delete Story-Specific Key
                if (storyId) {
                    await DBService.deleteImage(`bg_${storyId}`);
                }

                if (UIManager.RUNTIME.globalBackgroundImageCache) URL.revokeObjectURL(UIManager.RUNTIME.globalBackgroundImageCache);
                UIManager.RUNTIME.globalBackgroundImageCache = null;

                if (typeof ReactiveStore !== 'undefined' && ReactiveStore.state) {
                    ReactiveStore.state.backgroundImageURL = '';
                    ReactiveStore.forceSave();
                }

                UIManager.applyStyling();
                const bgHint = document.getElementById('background-image-hint');
                if (bgHint) bgHint.textContent = 'Current: None';
            },

            /**
             * Shared helper for AI generation buttons
             */
            /**
             * Helper function to generate AI content for a specific field.
             * @param {Event} event - The triggering event.
             * @param {string} promptTemplate - The prompt template to use.
             * @param {Object} context - The context object for prompt replacement.
             * @returns {Promise<string|null>} - The generated content or null.
             * @private
             */
            async _generateContentForField(event, promptTemplate, context) {
                const button = event.target.closest('button');
                if (!button) return null;
                const originalContent = button.innerHTML;
                button.disabled = true;
                button.innerHTML = '...';
                try {
                    let prompt = promptTemplate;
                    for (const key in context) {
                        prompt = prompt.replace(new RegExp(`{${key}}`, 'g'), context[key]);
                    }
                    return await APIService.callAI(prompt, false);
                } catch (error) {
                    alert(`AI generation failed: ${error.message}`);
                    return null;
                } finally {
                    button.disabled = false;
                    button.innerHTML = originalContent;
                }
            },

            /**
             * Updates the search index for a story object.
             * @param {Object} story - The story object to update.
             */
            updateSearchIndex(story) {
                if (!story) return;
                let index = [story.name];
                if (story.tags) index.push(...story.tags);
                if (story.creator_notes) index.push(story.creator_notes);
                if (story.characters) {
                    story.characters.forEach(char => {
                        index.push(char.name);
                        index.push(char.description);
                        if (char.tags) index.push(...char.tags);
                    });
                }
                story.search_index = index.join(' ').toLowerCase();
            }
        };




        /**
         * =================================================================================================
         * VisualMaster Module
         * Orchestrates scene visualization events separate from the Event Master.
         * =================================================================================================
         */
        const VisualMaster = {
            RUNTIME: {
                isProcessing: false,
                imageUrls: {}
            },

            /**
             * Checks if a visual event should be triggered.
             */
            async checkTrigger() {
                if (this.RUNTIME.isProcessing) return;

                // Guard: Global Image Gen Disabled
                if (typeof UIManager !== 'undefined' && !UIManager.isImageGenEnabled()) return;

                const state = ReactiveStore.state;
                // Guard: Probability Check
                const probability = parseFloat(state.visual_master_probability || 0);
                if (probability <= 0) return;

                // Dice Roll
                if (Math.random() * 100 > probability) return;

                // Trigger Visual Event
                this.RUNTIME.isProcessing = true;
                // Visual cues shouldn't block the user from typing, but we show a spinner
                UIManager.showLoadingSpinner("Visual Master: Painting the scene...");

                try {
                    console.log("Visual Master:  Roll successful. Generating scene...");
                    await this.triggerVisualEvent();
                } catch (e) {
                    console.warn("Visual Master failed:", e);
                } finally {
                    this.RUNTIME.isProcessing = false;
                    UIManager.hideLoadingSpinner();
                }
            },

            /**
             * Orchestrates the visual generation process.
             * @param {number} [atIndex] - Optional index to generate from (history slicing).
             * @param {HTMLElement} [btnElement] - Optional button element to show loading state.
             */
            async triggerVisualEvent(atIndex = null, btnElement = null) {
                // Guard: Global Image Gen Disabled
                if (typeof UIManager !== 'undefined' && !UIManager.isImageGenEnabled()) {
                    UIManager.showNotification("Image generation is disabled in settings.", "warning");
                    return;
                }

                const state = ReactiveStore.state;

                // 1. Determine Range
                let historySlice;
                let contextDescription = "";

                if (typeof atIndex === 'number') {
                    // Specific point in history: [atIndex-4 ... atIndex]
                    // Safe slice handling
                    const start = Math.max(0, atIndex - 4);
                    const end = atIndex + 1; // slice end is exclusive
                    historySlice = state.chat_history.slice(start, end);
                    contextDescription = `(Context: History at message #${atIndex})`;
                } else {
                    // Default: Last 5 messages
                    historySlice = state.chat_history.slice(-5);
                }

                // 1.5 Build Context (Last 5 messages)
                const recentHistory = historySlice
                    .filter(m => m && m.type === 'chat' && !m.isHidden)
                    .map(m => {
                        const char = state.characters.find(c => c.id === m.character_id);
                        return `${char ? char.name : 'Unknown'}: ${m.content}`;
                    })
                    .join('\n');

                // 2. Gather Personas & Location
                const activeChars = state.characters.filter(c => c.is_active || c.is_user); // Include user? Usually yes if they are in the scene
                const charPersonas = activeChars.map(c => `${c.name}: ${c.description.substring(0, 300)}`).join('\n\n');

                let locationContext = "";
                if (state.worldMap && state.worldMap.currentLocation) {
                    const loc = state.worldMap.grid.find(l => l.coords.x === state.worldMap.currentLocation.x && l.coords.y === state.worldMap.currentLocation.y);
                    if (loc) locationContext = `Location: ${loc.name} - ${loc.description}`;
                }

                // 2. Generate Prompt using AI
                const systemPrompt = state.visual_master_base_prompt || UTILITY.getDefaultSystemPrompts().visual_master_base_prompt;

                const prompt = `${systemPrompt}\n\nCHARACTERS:\n${charPersonas}\n\nSETTING:\n${locationContext}\n\nDIALOGUE:\n${recentHistory}\n\nKey:`;

                const visualDescription = await APIService.callAI(prompt, false);
                if (!visualDescription) throw new Error("Failed to generate visual description.");

                // 3. Generate Image
                // UI feedback on button if present
                let originalIcon = '';
                if (btnElement) {
                    originalIcon = btnElement.innerHTML;
                    btnElement.innerHTML = `<svg class="animate-spin h-4 w-4 text-indigo-400" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>`;
                    btnElement.disabled = true;
                    btnElement.classList.add('cursor-not-allowed');
                    // Notify the user globally as well
                    UIManager.showNotification("Visual Master: Generating scene...", "info");
                } else {
                    UIManager.showLoadingSpinner();
                }

                try {
                    // 3. Generate Image
                    const blob = await ImageGenerationService.generateImage(
                        visualDescription, // prompt
                        "nsfw, nude, naked, bad anatomy, text, watermark, blurry, low quality", // negativePrompt
                        { // options
                            width: StateManager.data.globalSettings.imageGenWidth || 512,
                            height: StateManager.data.globalSettings.imageGenHeight || 512,
                            steps: StateManager.data.globalSettings.koboldImageGenSteps || 20
                        }
                    );

                    if (!blob) throw new Error("Image generation failed.");

                    // 4. Save Ephemeral Blob to IDB
                    const imageId = `visual_event_${Date.now()}`;
                    await DBService.saveImage(imageId, blob);

                    // 5. Add to Chat History
                    const visualEntry = {
                        type: 'visual_event',
                        content: visualDescription, // The prompt/caption
                        image_key: imageId,
                        timestamp: new Date().toISOString(),
                        isNew: true
                    };

                    // CRITICAL FIX: Insert AFTER the triggering index, or push if at end
                    if (typeof atIndex === 'number' && atIndex < state.chat_history.length - 1) {
                        // Splice into array using splice (ReactiveStore should trap this)
                        state.chat_history.splice(atIndex + 1, 0, visualEntry);
                    } else {
                        state.chat_history.push(visualEntry);
                    }

                    await ReactiveStore.forceSave();

                    // Scroll to bottom only if we pushed to end, otherwise maybe scroll to index?
                    if (typeof atIndex !== 'number' || atIndex >= state.chat_history.length - 2) {
                        setTimeout(() => {
                            const chatWindow = document.getElementById('chat-window');
                            if (chatWindow) chatWindow.scrollTop = chatWindow.scrollHeight;
                        }, 50);
                    }

                } catch (err) {
                    console.error("Visual Event Error:", err);
                    UIManager.showNotification("Visual generation failed: " + err.message, "error");
                } finally {
                    if (btnElement) {
                        btnElement.innerHTML = originalIcon;
                        btnElement.disabled = false;
                        btnElement.classList.remove('cursor-not-allowed');
                    } else {
                        UIManager.hideLoadingSpinner();
                    }
                }
            }
        };


        /**
         * =================================================================================================
         * NarrativeController Module
         * Handles Chat, Characters, AI Generation, and Interaction Logic.
         * =================================================================================================
         */
        const NarrativeController = {
            CONSTANTS: {
                CHARACTER_COLORS: [
                    { base: '#334155', bold: '#94a3b8' }, // Slate
                    { base: '#1e3a8a', bold: '#60a5fa' }, // Blue
                    { base: '#581c87', bold: '#f472b6' }, // Fuchsia
                    { base: '#78350f', bold: '#fbbf24' }, // Amber
                    { base: '#365314', bold: '#a3e635' }, // Lime
                    { base: '#5b21b6', bold: '#a78bfa' }, // Violet
                    { base: '#881337', bold: '#fb7185' }, // Rose
                    { base: '#155e75', bold: '#22d3ee' }  // Cyan
                ]
            },

            RUNTIME: {
                streamingInterval: null,
                activeRequestAbortController: null
            },

            // --- Chat Interaction ---

            /**
             * Handles the primary action button (Send/Write).
             * Delegates to writeForMe or sendMessage based on input.
             */
            handlePrimaryAction() {
                if (!StateManager.getLibrary().active_story_id) {
                    UIManager.showConfirmationModal("Please load or create a story from the Story Library first.", () => AppController.openModal('story-library-modal'));
                    return;
                }
                const input = document.getElementById('chat-input');
                input.value.trim() === '' ? this.writeForMe() : this.sendMessage();
            },
            /**
             * Pure Generation Function (Reused by Quick Create & Story Architect).
             * Generates a character profile JSON based on context.
             * @param {string} name - The name of the character.
             * @param {string} contextString - The context string for generation.
             * @returns {Promise<Object>} - The generated character profile.
             */
            async generateCharacterProfile(name, contextString) {
                const prompt = `You are a character designer.
                Based on the context provided, generate a detailed character profile for "${name}".
                
                CONTEXT:
                ${contextString}
                
                INSTRUCTIONS:
                Infer their personality, appearance, and role.
                Respond with VALID JSON ONLY:
                {
                    "description": "Full personality and physical description.",
                    "short_description": "A very brief, one-sentence summary.",
                    "tags": ["tag1", "tag2", "tag3"],
                    "model_instructions": "Specific instructions for the AI on how to roleplay this character (e.g., 'Act as ${name}, speak in a rough tone...')",
                    "color_hex": "#71717a"
                }`;

                const response = await APIService.callAI(prompt, true);
                return UTILITY.extractAndParseJSON(response);
            },
            /**
             * Checks if the "Event Master" should trigger a random event.
             * Rolls a die and, if successful, generates a system instruction for the AI.
             */
            async checkEventMaster() {
                const state = ReactiveStore.state;

                // 1. Configuration Guard
                if (!state.event_master_base_prompt) return;

                // 2. Dice Roll: Configurable Chance
                // Strictly parse probability to prevent NaN causing 100% trigger rate
                let probability = parseInt(state.event_master_probability);
                if (isNaN(probability)) probability = 15; // Default if invalid

                // Logic: If random roll (0-100) is GREATER than probability, we SKIP.
                // Example: Prob 15. Roll 20. 20 > 15 is True. Return (Skip).
                if (Math.random() * 100 > probability) return;

                // 3. Overlap Guard
                if (state.event_master_prompt) return;

                // 4. Show UI Feedback
                // Since this blocks the chat, we must tell the user what is happening.
                UIManager.showLoadingSpinner("The Event Master is plotting...");

                try {
                    console.log("Event Master:  Roll successful. Analyzing narrative...");

                    // 5. Build Context (Last 10 messages)
                    const recentHistory = state.chat_history
                        .slice(-10)
                        .filter(m => m && m.type === 'chat' && !m.isHidden)
                        .map(m => {
                            const char = state.characters.find(c => c.id === m.character_id);
                            return `${char ? char.name : 'Unknown'}: ${m.content}`;
                        })
                        .join('\n');

                    // 6. Construct Prompt
                    const prompt = `${state.event_master_base_prompt}
            
            RECENT CHAT HISTORY:
            ${recentHistory}
            
            INSTRUCTION:
            Analyze the chat history. Generate a single, concise "System Instruction" that introduces a plot twist, a sudden event, or a change in tone to push the story in a new direction.
            
            Output ONLY the instruction. Do not write a chat message.
            Example Output: "A sudden thunderstorm knocks out the power."`;

                    // 7. Blocking API Call
                    // We use a new AbortController so this specific request has its own lifecycle
                    const controller = new AbortController();
                    const instruction = await APIService.callAI(prompt, false, controller.signal);

                    if (instruction && instruction.trim().length > 0) {
                        console.log("Event Master Triggered:", instruction);
                        // Save to state. 
                        // The PromptBuilder will inject this into the System Prompt when triggerAIResponse runs next.
                        state.event_master_prompt = instruction;
                    }

                } catch (e) {
                    console.warn("Event Master skipped turn:", e);
                } finally {
                    // 8. Always hide the spinner, whether we succeeded or failed
                    UIManager.hideLoadingSpinner();
                }
            },

            /**
             * Checks if it's time to generate static knowledge (every 6 messages).
             */
            async checkAutoStaticKnowledge() {
                const state = ReactiveStore.state;
                if (state.messageCounter > 0 && state.messageCounter % 6 === 0) {
                    const history = state.chat_history;
                    // Get last 6 chat messages
                    const recent = history.filter(m => m.type === 'chat').slice(-6);
                    if (recent.length < 6) return;

                    const transcript = recent.map(m => {
                        const char = state.characters.find(c => c.id === m.character_id);
                        return `${char ? char.name : 'Unknown'}: ${m.content}`;
                    }).join('\n');

                    const promptTemplate = state.prompt_auto_static_knowledge || UTILITY.getDefaultSystemPrompts().prompt_auto_static_knowledge;
                    const prompt = promptTemplate.replace('{transcript}', transcript);

                    try {
                        // Silent update (no notification unless successful)
                        const response = await APIService.callAI(prompt);
                        const rawData = UTILITY.extractAndParseJSON(response);
                        if (!rawData) return;

                        const entries = Array.isArray(rawData) ? rawData : [rawData];
                        let addedCount = 0;

                        if (!state.static_entries) state.static_entries = [];

                        for (const data of entries) {
                            if (data && data.title && data.content) {
                                state.static_entries.push({
                                    id: UTILITY.uuid(),
                                    title: data.title,
                                    content: data.content
                                });
                                addedCount++;
                            }
                        }

                        if (addedCount > 0) {
                            UIManager.showNotification(`New Knowledge: ${addedCount} entr${addedCount > 1 ? 'ies' : 'y'} added.`);
                            ReactiveStore.forceSave();
                        }
                    } catch (e) {
                        console.warn("Auto-Static Knowledge failed:", e);
                    }
                }
            },

            /**
             * Sends a user message.
             * Adds the message, checks triggers, runs Event Master, and triggers AI response.
             */
            async sendMessage() {
                if (this.RUNTIME.activeRequestAbortController) {
                    this.stopGeneration();
                }
                if (UIManager.RUNTIME.streamingInterval) {
                    clearInterval(UIManager.RUNTIME.streamingInterval);
                    UIManager.RUNTIME.streamingInterval = null;
                }

                const state = ReactiveStore.state;
                const input = document.getElementById('chat-input');
                const userChar = state.characters.find(c => c.is_user);

                if (!userChar) {
                    alert("No character is set as the 'User'.");
                    return;
                }

                const messageContent = input.value.trim();
                if (!messageContent) return;

                // 1. Add user message immediately
                this.addMessageToHistory(userChar.id, messageContent);
                input.value = '';

                // 2. Check triggers (Lore)
                this.checkDynamicEntryTriggers();

                // 3. Run Event Master (BLOCKING)
                // This "cuts in line" before the character replies.
                await this.checkEventMaster();

                // 3.5. Run Visual Master
                if (typeof VisualMaster !== 'undefined') {
                    await VisualMaster.checkTrigger();
                }

                // 4. Trigger Character Response
                // The character will now see the Event Master's instruction in the prompt context.
                await this.triggerAIResponse(null, messageContent);

                // 5. Cleanup / Auto-Save logic is handled by ReactiveStore
            },

            /**
             * Triggers the AI to write a message on behalf of the user.
             * Uses a placeholder animation during generation.
             */
            async writeForMe() {
                if (this.RUNTIME.activeRequestAbortController || UIManager.RUNTIME.streamingInterval) return;
                // Clear errors here too
                this.clearSystemErrors();
                const state = ReactiveStore.state;
                const userChar = state.characters.find(c => c.is_user);
                if (!userChar) return;
                const input = document.getElementById('chat-input');

                UIManager.setButtonToStopMode();
                this.RUNTIME.activeRequestAbortController = new AbortController();

                // Start Placeholder Animation
                // Cycles through: "." -> ". ." -> ". . ."
                let dotFrame = 0;
                input.placeholder = ".";

                this.RUNTIME.placeholderInterval = setInterval(() => {
                    dotFrame = (dotFrame + 1) % 3;
                    // Create string based on frame: 0=".", 1=". .", 2=". . ."
                    input.placeholder = Array(dotFrame + 1).fill(".").join(" ");
                }, 500);

                try {
                    const prompt = PromptBuilder.buildPrompt(userChar.id, true);
                    const response = await APIService.callAI(prompt, false, this.RUNTIME.activeRequestAbortController.signal);
                    input.value = response;
                } catch (error) {
                    if (error.name === 'AbortError') console.log("Write For Me stopped.");
                    else console.error("Write for Me failed:", error);
                } finally {
                    // Stop Animation & Restore Original Text
                    if (this.RUNTIME.placeholderInterval) {
                        clearInterval(this.RUNTIME.placeholderInterval);
                        this.RUNTIME.placeholderInterval = null;
                    }
                    input.placeholder = "Enter your message...";

                    UIManager.setButtonToSendMode();
                    this.RUNTIME.activeRequestAbortController = null;
                }
            },

            /**
             * Regenerates the last AI response.
             * Removes the last message and triggers a new response.
             */
            async handleRegen() {
                const state = ReactiveStore.state;
                if (!StateManager.getLibrary().active_narrative_id) { alert("Load a narrative first."); return; }
                if (this.RUNTIME.activeRequestAbortController || UIManager.RUNTIME.streamingInterval) return;

                let selectedCharId = document.getElementById('ai-character-selector').value;
                if (selectedCharId === 'any') {
                    selectedCharId = await this.determineNextSpeaker(false);
                }

                // Check if last message was AI
                const lastMsg = state.chat_history.filter(m => m.type === 'chat').pop();
                const lastChar = lastMsg ? state.characters.find(c => c.id === lastMsg.character_id) : null;

                if (lastChar && !lastChar.is_user && lastMsg.character_id === selectedCharId) {
                    this.undoLastTurn();
                    await this.triggerAIResponse(selectedCharId);
                } else {
                    await this.triggerAIResponse(selectedCharId);
                }
            },

            /**
             * Adds a message to the chat history and updates the state.
             * @param {string} id - The character ID.
             * @param {string} content - The message content.
             * @param {string} [type='chat'] - The message type.
             * @param {string} [emotion='neutral'] - The emotion associated with the message.
             */
            async addMessageToHistory(id, content, type = 'chat', emotion = 'neutral') {
                if (UIManager.RUNTIME.streamingInterval) {
                    clearInterval(UIManager.RUNTIME.streamingInterval);
                    UIManager.RUNTIME.streamingInterval = null;
                }

                const state = ReactiveStore.state;

                if (state.chat_history.length > 0) {
                    const cleanHistory = state.chat_history.filter(msg =>
                        !(msg.type === 'system_event' && (msg.content.startsWith('AI Error') || msg.content.includes('Failed to fetch')))
                    );
                    if (cleanHistory.length !== state.chat_history.length) {
                        state.chat_history = cleanHistory;
                    }
                }

                const newMessage = {
                    character_id: id, content, type, emotion,
                    timestamp: new Date().toISOString(), isNew: true
                };

                // Push to state
                ReactiveStore.state.chat_history.push(newMessage);

                if (type === 'chat') {
                    ReactiveStore.state.messageCounter++;
                    this.checkAutoStaticKnowledge();
                }

                // Await the save operation to ensure iOS persistence
                await ReactiveStore.forceSave();

                setTimeout(() => {
                    const chatWindow = document.getElementById('chat-window');
                    if (chatWindow) chatWindow.scrollTop = chatWindow.scrollHeight;
                }, 50);
            },

            /**
             * Adds a system message to the chat history.
             * @param {string} content - The system message content.
             */
            addSystemMessageToHistory(content) {
                ReactiveStore.state.chat_history.push({
                    type: 'system_event', content, timestamp: new Date().toISOString(), isNew: true
                });
            },

            /**
             * Deletes a single message by index.
             * @param {number} index - The index of the message.
             */
            deleteMessage(index) {
                UIManager.showConfirmationModal('Delete this message?', () => {
                    const msg = ReactiveStore.state.chat_history[index];
                    if (msg && msg.type === 'chat') {
                        ReactiveStore.state.messageCounter--;
                    }
                    ReactiveStore.state.chat_history.splice(index, 1);
                });
            },

            /**
             * Opens the delete options modal for a message.
             * @param {number} index - The index of the message.
             */
            confirmDeleteMessage(index) {
                UIManager.showDeleteMessageOptions(index);
            },

            /**
             * Executes the deletion of messages based on the selected mode.
             * @param {number} index - The index of the message.
             * @param {string} mode - 'single' or 'forward'.
             */
            executeDelete(index, mode) {
                const state = ReactiveStore.state;

                if (mode === 'single') {
                    const msg = state.chat_history[index];
                    if (msg && msg.type === 'chat') state.messageCounter--;
                    state.chat_history.splice(index, 1);
                }
                else if (mode === 'forward') {
                    // Delete this index and everything after it
                    // Count how many chat messages we are removing to update counter
                    const removed = state.chat_history.slice(index);
                    const chatCount = removed.filter(m => m.type === 'chat').length;
                    state.messageCounter = Math.max(0, state.messageCounter - chatCount);

                    // Perform truncate
                    state.chat_history.splice(index);
                }

                AppController.closeModal('confirmation-modal');
            },

            /**
             * Undoes the last turn (removes the last message).
             */
            undoLastTurn() {
                if (this.RUNTIME.activeRequestAbortController || UIManager.RUNTIME.streamingInterval) return;
                const history = ReactiveStore.state.chat_history;
                if (history.length === 0) return;

                let removedChatMessage = false;
                let i = history.length - 1;
                while (i >= 0 && !removedChatMessage) {
                    const msg = history[i];
                    history.splice(i, 1); // Reactive splice
                    if (msg.type === 'chat') {
                        ReactiveStore.state.messageCounter--;
                        removedChatMessage = true;
                    }
                    i--;
                }
            },

            /**
             * Copies the content of a message to the clipboard.
             * @param {number} index - The index of the message.
             */
            copyMessage(index) {
                const msg = ReactiveStore.state.chat_history[index];
                if (!msg) return;

                // Use modern Clipboard API
                navigator.clipboard.writeText(msg.content).then(() => {
                    // UI Feedback
                    const btn = document.querySelector(`[data-message-index='${index}'] button[data-action='chat-copy']`);
                    if (btn) {
                        const original = btn.innerHTML;
                        btn.innerHTML = `<span class="text-xs text-green-400 font-bold">Copied!</span>`;
                        setTimeout(() => btn.innerHTML = original, 1500);
                    }
                }).catch(err => {
                    console.error('Failed to copy text: ', err);
                    alert("Failed to copy to clipboard.");
                });
            },

            /**
             * Opens the edit modal for a specific message.
             * @param {number} index - The index of the message.
             */
            openEditModal(index) {
                const message = ReactiveStore.state.chat_history[index];
                if (!message) return;

                const input = document.getElementById('edit-modal-input');
                input.value = message.content;

                // Bind save button dynamically to this index
                const saveBtn = document.getElementById('edit-modal-save-button');
                // Remove old listener to prevent stacking
                const newBtn = saveBtn.cloneNode(true);
                saveBtn.parentNode.replaceChild(newBtn, saveBtn);

                newBtn.onclick = () => {
                    ReactiveStore.state.chat_history[index].content = input.value;
                    AppController.closeModal('edit-response-modal');
                };

                AppController.openModal('edit-response-modal');
            },

            /**
             * Renames the active narrative (debounced).
             * @param {string} newName - The new name.
             */
            renameActiveNarrative: debounce(function (newName) {
                const state = ReactiveStore.state;
                if (!state) return;

                // 1. Update Reactive State immediately
                state.narrativeName = newName;

                // 2. Force a save immediately to sync this name to the DB Stubs
                // This relies on our new "Surgical Update" in StoryService.saveActiveState
                ReactiveStore.forceSave();

            }, 500),

            /**
             * Handles actions for visual events (Save, Set Background).
             * @param {string} action - 'save' or 'background'.
             * @param {string} key - The IndexedDB key of the image.
             */
            async handleVisualAction(action, key) {
                if (!key) return;
                const blob = await DBService.getImage(key);
                if (!blob) { alert("Image not found locally."); return; }

                if (action === 'save') {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `Ellipsis_Scene_${Date.now()}.png`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                } else if (action === 'background') {
                    if (confirm("Set this image as the background for this story?")) {
                        // Save as persistent background
                        const library = StateManager.getLibrary();
                        const storyId = library.active_story_id;
                        if (!storyId) return;

                        // Use standard key format (bg_UUID)
                        const bgKey = `bg_${storyId}`;
                        const saved = await DBService.saveImage(bgKey, blob);
                        if (!saved) { alert("Failed to save background."); return; }

                        // Update Cache immediately (Critical for applyStyling)
                        if (UIManager.RUNTIME.globalBackgroundImageCache) URL.revokeObjectURL(UIManager.RUNTIME.globalBackgroundImageCache);
                        UIManager.RUNTIME.globalBackgroundImageCache = URL.createObjectURL(blob);

                        // Update State
                        StateManager.getState().backgroundImageURL = 'local_idb_background';
                        await ReactiveStore.forceSave();

                        // Apply
                        UIManager.applyStyling();

                        // Update UI hint if setting modal is open
                        const bgHint = document.getElementById('background-image-hint');
                        if (bgHint) bgHint.textContent = 'Current: [Visual Master Image]';
                    }
                }
            },

            // --- AI Generation Logic ---

            /**
             * Clears any system error messages from the chat history.
             */
            clearSystemErrors() {
                const state = ReactiveStore.state;
                if (state.chat_history.length > 0) {
                    // Filter out system events starting with "AI Error"
                    const cleanHistory = state.chat_history.filter(msg =>
                        !(msg.type === 'system_event' && msg.content.startsWith('AI Error'))
                    );

                    if (cleanHistory.length !== state.chat_history.length) {
                        state.chat_history = cleanHistory;
                    }
                }
            },

            /**
             * Triggers the AI to generate a response.
             * Handles character selection, prompt building, API calls, and streaming.
             * @param {string|null} charId - The ID of the character to speak.
             * @param {string} userMessage - The user's last message (for analysis).
             * @param {boolean} isAfterMove - Whether this follows a location move.
             */
            async triggerAIResponse(charId = null, userMessage = '', isAfterMove = false) {
                const state = ReactiveStore.state;

                // Clear previous error messages before starting new generation
                this.clearSystemErrors();

                // 1. Validation
                const activeAiChars = state.characters.filter(c => !c.is_user && c.is_active);
                if (activeAiChars.length === 0) {
                    this.addSystemMessageToHistory("No active AI characters.");
                    return;
                }
                if (!this._isModelConfigured(state)) {
                    this.addSystemMessageToHistory("AI model not configured. Check Settings.");
                    return;
                }

                // 2. Determine Speaker
                const selectorVal = document.getElementById('ai-character-selector').value;
                let targetId = charId;

                if (!targetId) {
                    if (selectorVal === 'any') {
                        targetId = await this.determineNextSpeaker(isAfterMove);
                    } else {
                        targetId = selectorVal;
                    }
                }

                if (!targetId) return;

                // 3. Setup UI for Generation
                UIManager.showTypingIndicator(targetId);
                UIManager.setButtonToStopMode();
                this.RUNTIME.activeRequestAbortController = new AbortController();

                try {
                    // 4. Generate Response
                    const prompt = PromptBuilder.buildPrompt(targetId);
                    const responseText = await APIService.callAI(prompt, false, this.RUNTIME.activeRequestAbortController.signal);

                    // 5. Analyze for Emotion/Location (Parallel)
                    let emotion = 'neutral';
                    if (userMessage) {
                        this.analyzeTurn(userMessage).then(analysis => {
                            if (analysis.locationName && typeof WorldController !== 'undefined') {
                                const grid = state.worldMap.grid;
                                const target = grid.find(l => l.name.toLowerCase() === analysis.locationName.toLowerCase());
                                const current = grid.find(l => l.coords.x === state.worldMap.currentLocation.x && l.coords.y === state.worldMap.currentLocation.y);

                                if (target && target.name !== current?.name) {
                                    setTimeout(() => WorldController.moveToLocation(target.coords.x, target.coords.y), 1500);
                                }
                            }
                        });
                    }
                    // Analyze AI Response for Sentiment (Emotion)
                    // We await this so the portrait is correct when the bubble appears
                    try {
                        const aiAnalysis = await this.analyzeTurn(responseText);
                        emotion = aiAnalysis.emotion;
                    } catch (err) {
                        console.warn("Sentiment analysis failed, defaulting to neutral.");
                    }

                    // 6. Stream Result
                    UIManager.hideTypingIndicator();
                    UIManager.startStreamingResponse(targetId, responseText, emotion);

                } catch (error) {
                    if (error.name === 'AbortError') console.log("Stopped.");
                    else this.addSystemMessageToHistory(`AI Error: ${error.message}`);
                    UIManager.hideTypingIndicator();
                } finally {
                    UIManager.setButtonToSendMode();
                    this.RUNTIME.activeRequestAbortController = null;
                    UIManager.hideTypingIndicator();
                }
            },

            /**
             * Stops the current AI generation process.
             */
            stopGeneration() {
                if (this.RUNTIME.activeRequestAbortController) {
                    this.RUNTIME.activeRequestAbortController.abort();
                }
                const state = ReactiveStore.state;
                if (state.apiProvider === 'koboldcpp' && state.koboldcpp_url) {
                    fetch(`${state.koboldcpp_url}/api/v1/generate/stop`, { method: 'POST' }).catch(() => { });
                }

                if (UIManager.RUNTIME.streamingInterval) {
                    clearInterval(UIManager.RUNTIME.streamingInterval);
                    UIManager.RUNTIME.streamingInterval = null;
                }

                UIManager.hideTypingIndicator();
                UIManager.setButtonToSendMode();
                this.RUNTIME.activeRequestAbortController = null;
            },

            /**
             * Determines the next speaker using an LLM "Scriptwriter" agent.
             * @param {boolean} isAfterMove - Whether this follows a location move.
             * @returns {Promise<string|null>} - The ID of the next speaker.
             */
            async determineNextSpeaker(isAfterMove) {
                const state = ReactiveStore.state;
                const pool = state.characters.filter(c => !c.is_user && c.is_active);

                if (pool.length === 0) return null;
                if (pool.length === 1 && !isAfterMove) return pool[0].id; // Optimization for single char

                UIManager.showTypingIndicator(null, "...", "...");

                try {
                    // 1. Gather Context
                    const activeChars = pool.map(c => c.name).join(', ');

                    // Supporting cast: Non-active chars that have spoken recently (last 8 messages)
                    const recentMsgIds = [...new Set(state.chat_history.slice(-8).map(m => m.character_id))];
                    const supportingChars = state.characters
                        .filter(c => !c.is_user && !c.is_active && !c.is_narrator && recentMsgIds.includes(c.id))
                        .map(c => c.name)
                        .join(', ');

                    const narrators = state.characters.filter(c => c.is_narrator).map(c => c.name).join(', ');

                    const recentHistory = state.chat_history.slice(-10).map(m => {
                        const char = state.characters.find(c => c.id === m.character_id);
                        return `${char ? char.name : 'System'}: ${m.content}`;
                    }).join('\n');

                    // 2. Construct Scriptwriter Prompt
                    const prompt = `You are a scriptwriter responsible for selecting the next character to respond in an ongoing roleplay. 
The list of existing characters in the roleplay is provided below. You may select any of these characters *or* choose an unlisted character if it makes sense within the roleplay.
For example, if the characters are ordering drinks, 'Bartender' might be an appropriate next responder even if not listed.
Always prioritize characters actively participating in the roleplay, either responding or mentioned.

Active characters: ${activeChars || "None"}
Supporting characters: ${supportingChars || "None"}
Narrators: ${narrators || "None"}

RECENT CONVERSATION:
${recentHistory}

Format your response as follows:
\`\`\`
[Active characters: List of currently participating characters.]
[Top 3: Three most likely responders.]
[Selection: The chosen next responder.]
\`\`\`

Rules:
1. Names must be exact.
2. The selected characters name **must** be the last line of the response.
3. Character lists are comma-separated.

Now, you shall respond in the exact format noted above to determine the next character to respond in the roleplay.`;

                    console.log("[Scriptwriter Prompt]:", prompt);

                    // 3. Call AI
                    const response = await APIService.callAI(prompt, false);
                    console.log("[Scriptwriter Response]:", response);

                    // 4. Parse Selection
                    let selection = null;
                    const selectionMatch = response.match(/\[Selection:\s*(.*?)\]/i);

                    if (selectionMatch && selectionMatch[1]) {
                        selection = selectionMatch[1].trim();
                        // Remove any trailing punctuation or markdown
                        selection = selection.replace(/['"`\.]*$/, '');
                    } else {
                        // Fallback: Search for known names
                        const allChars = state.characters.filter(c => !c.is_user);
                        // Priority search: Active > Supporting > Narrator
                        const priorityList = [...pool, ...state.characters.filter(c => !c.is_user && !c.is_active)];

                        for (const char of priorityList) {
                            if (response.includes(char.name)) {
                                selection = char.name;
                                break;
                            }
                        }
                    }

                    if (!selection) {
                        UIManager.showNotification("Scriptwriter could not determine next speaker.", "error");
                        return null;
                    }

                    console.log(`Scriptwriter selected: ${selection}`);

                    // 5. Resolve Selection to ID
                    // Try exact match
                    let targetChar = state.characters.find(c => c.name.toLowerCase() === selection.toLowerCase());

                    if (!targetChar) {
                        // Unlisted Character Logic
                        // Verify it's not a user error (fuzzy match?)
                        // For now, strict creation as per plan

                        const aiCount = state.characters.filter(c => !c.is_user).length;
                        const color = this.CONSTANTS.CHARACTER_COLORS[aiCount % this.CONSTANTS.CHARACTER_COLORS.length];

                        targetChar = {
                            id: UTILITY.uuid(),
                            name: selection, // Original casing
                            description: "A character in the scene.",
                            short_description: "Unlisted character",
                            model_instructions: "", // Default prompt applies
                            image_url: "",
                            extra_portraits: [],
                            tags: ["unlisted"],
                            is_user: false,
                            is_active: false, // Keep them inactive so they don't flood the selector? 
                            // Actually, if they speak, they become part of history. 
                            // User might want to adopt them.
                            color: color,
                            is_narrator: false
                        };

                        state.characters.push(targetChar);
                        await ReactiveStore.forceSave(); // Persist immediately

                        UIManager.showNotification(`New character '${selection}' entered the scene.`, "info");
                    }

                    return targetChar.id;

                } catch (error) {
                    console.error("Scriptwriter Error:", error);
                    UIManager.showNotification("Error determining next speaker.", "error");
                    return null;
                } finally {
                    UIManager.hideTypingIndicator(); // Ensure bubble is removed
                }
            },

            /**
             * Analyzes a text turn for emotion and location changes.
             * @param {string} text - The text to analyze.
             * @returns {Promise<Object>} - The analysis result { emotion, locationName }.
             */
            async analyzeTurn(text) {
                const state = ReactiveStore.state;

                // 1. Check Toggle
                if (state.enableAnalysis === false) return { emotion: 'neutral', locationName: null };

                // 2. Context-Aware Location List (Current + Adjacent)
                const grid = state.worldMap?.grid || [];
                const currentCoords = state.worldMap?.currentLocation;
                let validLocations = [];

                if (currentCoords) {
                    const cur = grid.find(l => l.coords.x === currentCoords.x && l.coords.y === currentCoords.y);
                    if (cur) validLocations.push(cur.name);
                    for (let dx = -1; dx <= 1; dx++) {
                        for (let dy = -1; dy <= 1; dy++) {
                            if (dx === 0 && dy === 0) continue;
                            const adj = grid.find(l => l.coords.x === currentCoords.x + dx && l.coords.y === currentCoords.y + dy);
                            if (adj && adj.name) validLocations.push(adj.name);
                        }
                    }
                }
                if (validLocations.length === 0) validLocations = grid.map(l => l.name);
                validLocations = [...new Set(validLocations)].filter(Boolean);
                const locStr = validLocations.join(', ');

                try {
                    const prompt = `Analyze the text.
                    1. Identify the speaker's emotion. Options: 'happy', 'sad', 'angry', 'surprised', 'neutral'.
                    2. Determine if the text explicitly indicates moving to a location.
                    IMPORTANT: You may ONLY select a location from this list: [${locStr}].
                    If the text does not strictly match a location in that list, set "locationName" to null.
                    TEXT: "${text}"
                    Return valid JSON: { "emotion": "string", "locationName": "string" or null }`;

                    const res = await APIService.callAI(prompt, true);
                    const data = UTILITY.extractAndParseJSON(res); // Use safe parser

                    const validEmotions = ['happy', 'sad', 'angry', 'surprised', 'neutral'];
                    const emotion = (data?.emotion && validEmotions.includes(data.emotion.toLowerCase())) ? data.emotion.toLowerCase() : 'neutral';
                    return { emotion, locationName: data?.locationName || null };
                } catch (e) {
                    return { emotion: 'neutral', locationName: null };
                }
            },

            // --- Character Management ---

            /**
             * Adds a new character to the roster.
             */
            addCharacter() {
                const aiCount = ReactiveStore.state.characters.filter(c => !c.is_user).length;
                const color = this.CONSTANTS.CHARACTER_COLORS[aiCount % this.CONSTANTS.CHARACTER_COLORS.length];

                const newChar = {
                    id: UTILITY.uuid(), name: "New Character", description: "", short_description: "Summary",
                    model_instructions: "Act as {character}.", image_url: "", extra_portraits: [],
                    tags: [], is_user: false, is_active: true, color: color, is_narrator: false
                };

                ReactiveStore.state.characters.push(newChar);
                AppController.openModal('character-detail-modal', newChar.id);
            },

            /**
             * Deletes a character by ID.
             * @param {string} id - The character ID.
             */
            deleteCharacter(id) {
                UIManager.showConfirmationModal('Delete this character?', () => {
                    ReactiveStore.state.characters = ReactiveStore.state.characters.filter(c => c.id !== id);
                    DBService.deleteImage(id);
                    AppController.closeModal('character-detail-modal');
                });
            },

            /**
             * Quickly creates a new character using AI based on a name and context.
             */
            async quickCreateCharacter() {
                const state = ReactiveStore.state;
                if (!state || !state.chat_history) {
                    alert("Please load a story first.");
                    return;
                }

                // 1. Get the name
                const name = prompt("Who would you like to create? Enter a name mentioned in the story:");
                if (!name || name.trim() === "") return;

                UIManager.showLoadingSpinner(`Dreaming up ${name}...`);

                try {
                    // 2. Gather Context (Last 30 messages + World Info)
                    const recentHistory = state.chat_history
                        .slice(-30)
                        .filter(m => m.type === 'chat' && !m.isHidden)
                        .map(m => {
                            const char = state.characters.find(c => c.id === m.character_id);
                            return `${char ? char.name : 'Unknown'}: ${m.content}`;
                        })
                        .join('\n');
                    const staticLore = (state.static_entries || []).map(e => `${e.title}: ${e.content}`).join('\n');

                    const context = `LORE:\n${staticLore}\n\nRECENT CHAT:\n${recentHistory}`;

                    // 3. Call Shared Generator
                    const data = await this.generateCharacterProfile(name, context);

                    if (!data) throw new Error("AI returned invalid JSON or failed to generate profile.");

                    // 4. Create Character Object
                    const aiCount = state.characters.filter(c => !c.is_user).length;

                    // Use AI-suggested color or cycle through defaults
                    const color = data.color_hex
                        ? { base: data.color_hex, bold: '#ffffff' }
                        : this.CONSTANTS.CHARACTER_COLORS[aiCount % this.CONSTANTS.CHARACTER_COLORS.length];

                    const newChar = {
                        id: UTILITY.uuid(),
                        name: name.trim(),
                        description: data.description || "A mysterious character.",
                        short_description: data.short_description || "A new character.",
                        model_instructions: data.model_instructions || `Act as ${name}.`,
                        image_url: "",
                        extra_portraits: [],
                        tags: data.tags || [],
                        is_user: false,
                        is_active: true,
                        color: color,
                        is_narrator: false
                    };

                    // 5. Save and Open
                    state.characters.push(newChar);
                    await ReactiveStore.forceSave(); // Ensure persistence

                    UIManager.hideLoadingSpinner();
                    UIManager.renderCharacters();

                    // Open the detail modal so user can refine it
                    AppController.openModal('character-detail-modal', newChar.id);

                } catch (error) {
                    UIManager.hideLoadingSpinner();
                    console.error("Quick Create failed:", error);
                    alert(`Failed to generate character: ${error.message}`);
                }
            },

            /**
             * Updates a specific field of a character (debounced).
             * @param {string} id - The character ID.
             * @param {string} field - The field to update.
             * @param {string} value - The new value.
             */
            updateCharacterField: debounce(function (id, field, value) {
                const char = ReactiveStore.state.characters.find(c => c.id === id);
                if (char) {
                    char[field] = value;
                    if (field === 'name') { // Live update modal header
                        const header = document.querySelector(`#character-detail-modal-content h2[data-char-id="${id}"]`);
                        if (header) header.textContent = value;
                    }
                }
            }, 300),

            /**
             * Updates a character's tags (debounced).
             * @param {string} id - The character ID.
             * @param {string} value - The comma-separated tags string.
             */
            updateCharacterTags: debounce(function (id, value) {
                const char = ReactiveStore.state.characters.find(c => c.id === id);
                if (char) {
                    char.tags = value.split(',').map(t => t.trim()).filter(Boolean);
                }
            }, 300),

            /**
             * Sets the role of a character (user or narrator).
             * @param {string} charId - The character ID.
             * @param {string} role - 'user' or 'narrator'.
             */
            setCharacterRole(charId, role) {
                ReactiveStore.state.characters.forEach(c => {
                    if (c.id === charId) {
                        c.is_user = (role === 'user');
                        c.is_narrator = (role === 'narrator');
                    } else if (role === 'user') {
                        c.is_user = false; // Single user enforcement
                    }
                });
                UIManager.openCharacterDetailModal(charId); // Refresh view
            },

            /**
             * Toggles a character's active status.
             * @param {Event} event - The checkbox change event.
             * @param {string} id - The character ID.
             */
            toggleCharacterActive(event, id) {
                const char = ReactiveStore.state.characters.find(c => c.id === id);
                if (char) char.is_active = event.target.checked;
            },

            // Character Colors ---
            /**
             * Updates a character's color settings (debounced).
             * @param {string} id - The character ID.
             * @param {string} type - 'base' or 'bold'.
             * @param {string} value - The hex color code.
             */
            updateCharacterColor: debounce(function (id, type, value) {
                const char = ReactiveStore.state.characters.find(c => c.id === id);
                if (char) {
                    if (!char.color) char.color = { base: '#334155', bold: '#94a3b8' };
                    char.color[type] = value;
                    // Force styling refresh if needed, though ReactiveStore should handle standard bindings.
                    // However, message bubbles use color directly from state during renderChat.
                    // If we want live update of existing bubbles without full re-render, we might need UIManager.renderChat();
                    UIManager.renderChat();
                }
            }, 300),

            // Emotional Portraits ---
            /**
             * Adds a new extra portrait slot for a character.
             * @param {string} charId - The character ID.
             */
            addExtraPortrait(charId) {
                const char = ReactiveStore.state.characters.find(c => c.id === charId);
                if (!char) return;
                if (!char.extra_portraits) char.extra_portraits = [];

                // Capture scroll position
                const container = document.getElementById('character-detail-modal-content');
                const scrollTop = container ? container.scrollTop : 0;

                char.extra_portraits.push({ emotion: 'neutral', url: '' });
                UIManager.openCharacterDetailModal(charId); // Refresh modal

                // Restore scroll position
                const newContainer = document.getElementById('character-detail-modal-content');
                if (newContainer) newContainer.scrollTop = scrollTop;
            },

            /**
             * Removes an extra portrait slot.
             * @param {string} charId - The character ID.
             * @param {number} index - The index of the portrait.
             */
            removeExtraPortrait(charId, index) {
                const char = ReactiveStore.state.characters.find(c => c.id === charId);
                if (!char || !char.extra_portraits) return;
                char.extra_portraits.splice(index, 1);

                // Clean up IDB image if exists
                const emoKey = `${charId}::emotion::${index}`; // Note: Logic in hydration uses emotion name, but deletion might be tricky if emotion name changed. 
                // Simplified: We just refresh the UI. Actual image cleanup usually happens on story delete or explicit cleanup.
                UIManager.openCharacterDetailModal(charId);
            },

            /**
             * Updates a field of an extra portrait (debounced).
             * @param {string} charId - The character ID.
             * @param {number} index - The index of the portrait.
             * @param {string} field - The field to update.
             * @param {string} value - The new value.
             */
            updateExtraPortrait: debounce(function (charId, index, field, value) {
                const char = ReactiveStore.state.characters.find(c => c.id === charId);
                if (char && char.extra_portraits && char.extra_portraits[index]) {
                    char.extra_portraits[index][field] = value;
                }
            }, 300),

            /**
             * Handles the upload of a local image for a specific emotion.
             * @param {Event} event - The file input change event.
             * @param {string} charId - The character ID.
             * @param {number} index - The index of the portrait.
             */
            async handleLocalEmotionImageUpload(event, charId, index) {
                const file = event.target.files[0];
                if (!file) return;
                const char = ReactiveStore.state.characters.find(c => c.id === charId);
                if (!char || !char.extra_portraits[index]) return;

                try {
                    const emotion = char.extra_portraits[index].emotion || 'neutral';
                    const blob = await ImageProcessor.processImageAsBlob(file);
                    const key = `${charId}::emotion::${emotion}`;

                    await DBService.saveImage(key, blob);
                    UIManager.RUNTIME.characterImageCache[key] = URL.createObjectURL(blob);

                    // Clear manual URL to indicate local preference
                    char.extra_portraits[index].url = '';

                    UIManager.openCharacterDetailModal(charId);
                } catch (e) { alert("Image upload failed."); }
            },

            // --- Example Dialogue Logic ---

            /**
             * Adds a new turn to the example dialogue.
             */
            addExampleDialogueTurn() {
                const state = ReactiveStore.state;
                const firstAi = state.characters.find(c => !c.is_user);
                if (!firstAi) return alert("Need AI character.");
                state.chat_history.push({
                    character_id: firstAi.id, content: "New example.", type: 'chat',
                    emotion: 'neutral', timestamp: new Date().toISOString(), isHidden: true
                });
                UIManager.renderExampleDialogueModal();
            },

            /**
             * Deletes a turn from the example dialogue.
             * @param {number} index - The index of the turn.
             */
            deleteExampleDialogueTurn(index) {
                ReactiveStore.state.chat_history.splice(index, 1);
                UIManager.renderExampleDialogueModal();
            },

            /**
             * Moves an example dialogue turn up or down.
             * @param {number} index - The index of the turn.
             * @param {string} direction - 'up' or 'down'.
             */
            moveExampleDialogueTurn(index, direction) {
                const history = ReactiveStore.state.chat_history;
                if (!history[index]) return;

                let swapIndex = -1;
                // Find next/prev hidden message
                if (direction === 'up') {
                    for (let i = index - 1; i >= 0; i--) { if (history[i].isHidden) { swapIndex = i; break; } }
                } else {
                    for (let i = index + 1; i < history.length; i++) { if (history[i].isHidden) { swapIndex = i; break; } }
                }

                if (swapIndex !== -1) {
                    const temp = history[swapIndex];
                    history[swapIndex] = history[index];
                    history[index] = temp;
                    UIManager.renderExampleDialogueModal();
                }
            },

            /**
             * Updates a field of an example dialogue turn (debounced).
             * @param {number} index - The index of the turn.
             * @param {string} field - The field to update.
             * @param {string} value - The new value.
             */
            updateExampleDialogueTurn: debounce(function (index, field, value) {
                if (ReactiveStore.state.chat_history[index]) {
                    ReactiveStore.state.chat_history[index][field] = value;
                }
            }, 300),

            // --- Helpers ---

            /**
             * Enhances a character's description using AI.
             * @param {Event} event - The click event.
             * @param {string} charId - The character ID.
             */
            async enhancePersonaWithAI(event, charId) {
                const char = ReactiveStore.state.characters.find(c => c.id === charId);
                if (!char) return;
                UIManager.showConfirmationModal('Overwrite persona?', async () => {
                    const prompt = ReactiveStore.state.prompt_persona_gen.replace('{concept}', char.description);
                    const res = await this._gen(event, prompt);
                    if (res) {
                        char.description = res;
                        // Update UI manually for immediate feedback if open
                        const el = document.getElementById(`persona-description-${char.id}`);
                        if (el) el.value = res;
                    }
                });
            },

            /**
             * Opens the Generic Image Generator for a character.
             * @param {string} charId - The Character ID.
             * @param {string} type - 'primary' or 'extra'.
             * @param {number} [index] - Index for extra emotions.
             */
            openCharacterImageGenerator(charId, type = 'primary', index = null) {
                const state = StateManager.getState();
                const char = state.characters.find(c => c.id === charId);
                if (!char) return;

                // Use the full persona description (up to 500 chars to avoid URL limit issues if passed around, but effectively full)
                const initialPrompt = char.description.substring(0, 500);

                UIManager.openGenericImageGenerator({
                    title: `Generate: ${char.name}`,
                    initialPrompt: initialPrompt,
                    onSave: async (blob) => {
                        if (type === 'primary') {
                            await this.handleLocalImageUpload({ target: { files: [new File([blob], "generated_portrait.png", { type: "image/png" })] } }, charId);
                        } else {
                            await this.handleLocalEmotionImageUpload({ target: { files: [new File([blob], "generated_emotion.png", { type: "image/png" })] } }, charId, index);
                        }
                        UIManager.renderCharacters();
                    }
                });
            },

            /**
             * Generates tags for a character using AI.
             * @param {Event} event - The click event.
             * @param {string} charId - The character ID.
             */
            async generateTagsForCharacter(event, charId) {
                const char = ReactiveStore.state.characters.find(c => c.id === charId);
                if (!char) return;
                const prompt = `Generate 3-5 tags for: ${char.name}. Description: ${char.description}`;
                const res = await this._gen(event, prompt);
                if (res) {
                    const tags = res.split(',').map(t => t.trim().toLowerCase());
                    char.tags = [...new Set([...(char.tags || []), ...tags])];
                }
            },

            /**
             * Generates model instructions for a character using AI.
             * @param {Event} event - The click event.
             * @param {string} charId - The character ID.
             */
            async generateModelInstructions(event, charId) {
                const char = ReactiveStore.state.characters.find(c => c.id === charId);
                if (!char) return;
                const prompt = `Generate model instructions for ${char.name} based on: ${char.description}`;
                const res = await this._gen(event, prompt);
                if (res) {
                    char.model_instructions = res;
                    UIManager.openCharacterDetailModal(charId);
                }
            },

            /**
             * Handles the upload of a local image for a character.
             * @param {Event} event - The file input change event.
             * @param {string} charId - The character ID.
             */
            async handleLocalImageUpload(event, charId) {
                const file = event.target.files[0];
                if (!file) return;
                try {
                    const blob = await ImageProcessor.processImageAsBlob(file);
                    await DBService.saveImage(charId, blob);
                    UIManager.RUNTIME.characterImageCache[charId] = URL.createObjectURL(blob);
                    this.updateCharacterField(charId, 'image_url', ''); // Clear legacy
                    UIManager.renderCharacters();
                } catch (e) { alert("Image upload failed."); }
            },

            /**
             * Compiles a regex for a keyword trigger.
             * @param {string} keyword - The keyword to match.
             * @returns {RegExp} - The compiled regex.
             * @private
             */
            _compileTriggerRegex(keyword) {
                // Escape special regex characters
                const escaped = keyword.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                // Matches whole word/phrase, case insensitive
                return new RegExp(`\\b${escaped}\\b`, 'i');
            },

            /**
             * Parses a trigger string into groups and probability chance.
             * @param {string} triggersStr - The raw trigger string.
             * @returns {Object} - { groups: Array, chance: number }.
             */
            parseTriggers(triggersStr) {
                if (!triggersStr) return { groups: [], chance: 0 };
                const parts = triggersStr.split(',').map(s => s.trim());
                const chancePart = parts.find(p => p.match(/^\d+\s*\%$/));
                const chance = chancePart ? parseInt(chancePart.replace('%', '')) : 0;
                const keywordParts = parts.filter(p => p && !p.match(/^\d+\s*\%$/));

                const groups = keywordParts.map(part => {
                    if (part.includes(' XOR ')) {
                        const keywords = part.split(' XOR ').map(k => k.trim().toLowerCase()).filter(Boolean);
                        if (keywords.length === 2) return { type: 'XOR', keywords };
                    }
                    if (part.includes(' AND ')) {
                        const keywords = part.split(' AND ').map(k => k.trim().toLowerCase()).filter(Boolean);
                        if (keywords.length > 0) return { type: 'AND', keywords };
                    }
                    return { type: 'OR', keywords: [part.toLowerCase()] };
                });
                return { groups, chance };
            },

            /**
             * Checks the last message for dynamic entry keyphrases.
             * If triggered, injects the entry into the history (and optionally removes previous reveals).
             * @returns {boolean} - True if state changed (requires re-render).
             */
            checkDynamicEntryTriggers() {
                const state = ReactiveStore.state;

                const lastMsg = state.chat_history.slice().reverse().find(m => m && m.type === 'chat');
                if (!lastMsg) return false; // Return false if no check occurred

                const content = lastMsg.content;
                let stateChanged = false;

                (state.dynamic_entries || []).forEach(entry => {
                    // 1. Check triggers
                    const { groups, chance } = this.parseTriggers(entry.triggers);

                    const keywordMatch = groups.some(group => {
                        const patterns = group.keywords.map(kw => this._compileTriggerRegex(kw));
                        switch (group.type) {
                            case 'OR': return patterns.some(regex => regex.test(content));
                            case 'AND': return patterns.every(regex => regex.test(content));
                            case 'XOR':
                                const [f, s] = [patterns[0].test(content), patterns[1].test(content)];
                                return (f && !s) || (!f && s);
                            default: return false;
                        }
                    });

                    // 2. If triggered:
                    if (keywordMatch || (Math.random() * 100 < chance)) {

                        // 3. De-duplicate: Look-behind 20 messages
                        const searchWindowStart = Math.max(0, state.chat_history.length - 20);
                        let foundIndex = -1;

                        for (let i = state.chat_history.length - 1; i >= searchWindowStart; i--) {
                            const msg = state.chat_history[i];
                            if (msg && msg.type === 'lore_reveal' && msg.dynamic_entry_id === entry.id) {
                                foundIndex = i;
                                break;
                            }
                        }

                        if (foundIndex !== -1) {
                            state.chat_history.splice(foundIndex, 1);
                            stateChanged = true;
                        }

                        // 4. Sequential Logic
                        const contentIndex = entry.current_index || 0;
                        if (!entry.content_fields || entry.content_fields.length === 0) return;

                        const contentToReveal = entry.content_fields[contentIndex];

                        let nextIndex = contentIndex + 1;
                        if (nextIndex >= entry.content_fields.length) {
                            nextIndex = entry.content_fields.length - 1;
                        }
                        entry.current_index = nextIndex;

                        // 5. Add the new entry inline
                        state.chat_history.push({
                            type: 'lore_reveal',
                            title: entry.title,
                            content: contentToReveal,
                            dynamic_entry_id: entry.id,
                            timestamp: new Date().toISOString(),
                            isHidden: true
                        });
                        console.log(`Dynamic Entry triggered: ${entry.title}`);
                        stateChanged = true;

                        if (entry.triggered_at_turn !== null) {
                            entry.triggered_at_turn = null;
                        }
                    }
                });

                if (stateChanged) {
                    UIManager.renderDynamicEntries();
                }

                // Return the boolean so UIManager knows if indices shifted
                return stateChanged;
            },


            /**
             * Helper for AI generation buttons.
             * @param {Event} event - The triggering event.
             * @param {string} prompt - The prompt to send.
             * @returns {Promise<string|null>} - The generated content or null.
             * @private
             */
            async _gen(event, prompt) {
                // Helper for button state handling
                const btn = event.target.closest('button');
                if (btn) { btn.disabled = true; btn.innerHTML = '...'; }
                try { return await APIService.callAI(prompt); }
                catch (e) { alert(e.message); return null; }
                finally { if (btn) { btn.disabled = false; btn.innerHTML = 'Gen'; } }
            },

            /**
             * Checks if an AI model is properly configured.
             * Checks both local state and global settings.
             */
            _isModelConfigured(s) {
                const global = StateManager.data.globalSettings;

                if (s.apiProvider === 'gemini') {
                    return (s.geminiApiKey && s.geminiApiKey.trim() !== '') ||
                        (global.geminiApiKey && global.geminiApiKey.trim() !== '');
                }
                if (s.apiProvider === 'openrouter') {
                    return (s.openRouterKey && s.openRouterKey.trim() !== '') ||
                        (global.openRouterKey && global.openRouterKey.trim() !== '');
                }
                if (s.apiProvider === 'koboldcpp') return !!s.koboldcpp_url;
                if (s.apiProvider === 'lmstudio') return !!s.lmstudio_url;

                return false;
            },

            /**
             * Displays the raw prompt that would be sent to the AI.
             * Useful for debugging.
             */
            viewRawPrompt() {
                const state = ReactiveStore.state;

                // 1. Determine who the prompt is for
                let charId = document.getElementById('ai-character-selector').value;
                if (charId === 'any') charId = this.determineNextSpeaker(false);

                if (!charId) {
                    alert("No active AI character found to build a prompt for.");
                    return;
                }

                // 2. Build the prompt string using the shared logic
                const promptText = PromptBuilder.buildPrompt(charId);

                // 3. Generate Metadata Header for the view
                let metaInfo = `--- DEBUG INFO ---\n`;
                metaInfo += `Active Provider: ${state.apiProvider}\n`;

                if (state.apiProvider === 'koboldcpp') {
                    // Show specific template being used
                    const template = state.koboldcpp_template || 'none';
                    metaInfo += `Active Template: ${template.toUpperCase()}\n`;

                    // Estimate Token Count (Roughly 4 chars per token)
                    const estTokens = Math.ceil(promptText.length / 4);
                    const maxCtx = 4096; // Default context limit
                    const usage = Math.round((estTokens / maxCtx) * 100);
                    metaInfo += `Est. Context Usage: ~${estTokens} / ${maxCtx} tokens (${usage}%)\n`;
                } else {
                    metaInfo += `Template: Standard (Cloud/Default)\n`;
                }

                metaInfo += `------------------\n\n`;

                // 4. Render
                const contentEl = document.getElementById('raw-prompt-content');
                if (contentEl) {
                    contentEl.textContent = metaInfo + promptText;
                }

                AppController.openModal('view-raw-prompt-modal');
            },






        };

        /**
         * =================================================================================================
         * WorldController Module
         * Handles World Map, Navigation, Static Lore, and Dynamic Lore.
         * =================================================================================================
         */
        const WorldController = {
            RUNTIME: {
                activeWorldMapTab: 'move',
                selectedMapTile: null,
                pendingMove: null,
                turnOfArrival: 0,
                selectedLocalStaticEntryId: null
            },

            // --- World Map Navigation ---

            /**
             * Switches the active tab in the World Map modal.
             * @param {string} tabName - 'move' or 'edit'.
             */
            switchWorldMapTab(tabName) {
                this.RUNTIME.activeWorldMapTab = tabName;
                UIManager.renderWorldMapModal();
            },



            /**
             * Selects a tile for a pending move operation.
             * @param {number} x - The x-coordinate.
             * @param {number} y - The y-coordinate.
             */
            selectPendingMove(x, y) {
                this.RUNTIME.pendingMove = { x, y };
                UIManager.renderWorldMapModal();
            },

            /**
             * Confirms and executes the pending move.
             */
            confirmMove() {
                const state = ReactiveStore.state;
                const { pendingMove } = this.RUNTIME;
                const { currentLocation } = state.worldMap;

                if (pendingMove && (pendingMove.x !== currentLocation.x || pendingMove.y !== currentLocation.y)) {
                    this.moveToLocation(pendingMove.x, pendingMove.y);
                }

                this.RUNTIME.pendingMove = null;
                AppController.closeModal('world-map-modal');
            },

            /**
             * Moves the party to a specific location.
             * Updates state, path, background, and triggers AI response.
             * @param {number} x - The x-coordinate.
             * @param {number} y - The y-coordinate.
             */
            moveToLocation(x, y) {
                const state = ReactiveStore.state;
                const targetLocation = state.worldMap.grid.find(loc => loc.coords.x === x && loc.coords.y === y);

                if (targetLocation) {
                    const previousLocationCoords = { ...state.worldMap.currentLocation };
                    const turnOfDeparture = state.messageCounter;

                    // Trigger memory summary (Async side effect)
                    if (this.RUNTIME.turnOfArrival !== null && turnOfDeparture > this.RUNTIME.turnOfArrival) {
                        this.summarizeActivityForLocation(previousLocationCoords, this.RUNTIME.turnOfArrival);
                    }

                    // 1. Update Location (Triggers auto-save)
                    state.worldMap.currentLocation = { x, y };
                    this.RUNTIME.turnOfArrival = state.messageCounter;

                    // 2. Update Path
                    if (state.worldMap.destination && state.worldMap.destination.x !== null) {
                        state.worldMap.path = UTILITY.findPath(state.worldMap.grid, state.worldMap.currentLocation, state.worldMap.destination);
                    } else {
                        state.worldMap.path = [];
                    }

                    // 3. Add System Message
                    if (typeof NarrativeController !== 'undefined') {
                        NarrativeController.addSystemMessageToHistory(`You have moved to ${targetLocation.name}.`);
                    }

                    // 4. Reset UI Selection Runtime State
                    this.RUNTIME.selectedMapTile = null;
                    this.RUNTIME.pendingMove = null;

                    // 5. Trigger AI Response (Narrator prefers to speak on move)
                    const narrator = state.characters.find(c => c.is_narrator && c.is_active);
                    if (typeof NarrativeController !== 'undefined') {
                        NarrativeController.triggerAIResponse(narrator ? narrator.id : null, '', true);
                    }

                    // 6. Update Background
                    UIManager.applyStyling();
                }
            },

            /**
             * Generates a summary of activity at a location upon departure.
             * @param {Object} locationCoords - The coordinates of the location.
             * @param {number} startTurn - The turn number when arrived.
             */
            async summarizeActivityForLocation(locationCoords, startTurn) {
                try {
                    const state = ReactiveStore.state;
                    const endTurn = state.messageCounter;

                    // Access raw array from proxy to avoid issues, though proxy access is usually fine for read
                    const history = state.chat_history;
                    const relevantHistory = history.slice(startTurn, endTurn).filter(msg => msg.type === 'chat' && !msg.isHidden);

                    if (relevantHistory.length === 0) return;

                    const chatTranscript = relevantHistory.map(msg => {
                        const char = state.characters.find(c => c.id === msg.character_id);
                        return `${char ? char.name : 'Unknown'}: ${msg.content}`;
                    }).join('\n');

                    const promptTemplate = state.prompt_location_memory_gen || UTILITY.getDefaultSystemPrompts().prompt_location_memory_gen;
                    const prompt = promptTemplate.replace('{transcript}', chatTranscript);

                    const summaryContent = await APIService.callAI(prompt);

                    // Find location in ReactiveStore to update
                    const location = state.worldMap.grid.find(loc => loc.coords.x === locationCoords.x && loc.coords.y === locationCoords.y);
                    if (location) {
                        if (!location.local_static_entries) location.local_static_entries = [];

                        location.local_static_entries.push({
                            id: UTILITY.uuid(),
                            title: `Events from turn ${startTurn} to ${endTurn}`,
                            content: summaryContent
                        });
                    }
                } catch (error) {
                    console.error("Failed to auto-generate location memory:", error);
                }
            },

            // --- Map Management (Edit Mode) ---

            /**
             * Selects a map tile for editing or viewing details.
             * @param {number} x - The x-coordinate.
             * @param {number} y - The y-coordinate.
             */
            selectMapTile(x, y) {
                const state = ReactiveStore.state;
                const tile = state.worldMap.grid.find(loc => loc.coords.x === x && loc.coords.y === y);
                this.RUNTIME.selectedMapTile = tile || null;
                this.RUNTIME.selectedLocalStaticEntryId = null;

                // Open the specific location details modal
                if (this.RUNTIME.selectedMapTile) {
                    AppController.openModal('location-details-modal');
                    UIManager.renderLocationDetailsModal();
                }
            },

            // Update image upload handler to refresh the new modal if open
            /**
             * Handles the upload of a custom image for a location.
             * @param {Event} event - The file input change event.
             * @param {number} x - The x-coordinate.
             * @param {number} y - The y-coordinate.
             */
            async handleWorldMapLocationImageUpload(event, x, y) {
                const file = event.target.files?.[0];
                if (!file) return;
                if (file.size > 5 * 1024 * 1024) { alert("Image too large."); return; }

                UIManager.showLoadingSpinner('Processing location image...');
                try {
                    const blob = await ImageProcessor.processImageAsBlob(file);
                    const locationKey = `location::${x},${y}`;
                    await DBService.saveImage(locationKey, blob);

                    UIManager.RUNTIME.worldImageCache = UIManager.RUNTIME.worldImageCache || {};
                    if (UIManager.RUNTIME.worldImageCache[locationKey]) URL.revokeObjectURL(UIManager.RUNTIME.worldImageCache[locationKey]);
                    UIManager.RUNTIME.worldImageCache[locationKey] = URL.createObjectURL(blob);

                    const grid = ReactiveStore.state.worldMap.grid;
                    const location = grid.find(loc => loc.coords.x === x && loc.coords.y === y);
                    if (location) location.imageUrl = `local_idb_location::${x},${y}`;

                    // Refresh the new modal
                    UIManager.renderLocationDetailsModal();
                    UIManager.applyStyling();

                } catch (err) {
                    alert(`Upload failed: ${err.message}`);
                } finally {
                    UIManager.hideLoadingSpinner();
                    event.target.value = '';
                }
            },

            /**
             * Sets the current selected tile as the travel destination.
             * Calculates the path.
             */
            setDestination() {
                const selected = this.RUNTIME.selectedMapTile;
                if (!selected) return;

                const state = ReactiveStore.state;
                state.worldMap.destination = selected.coords;
                state.worldMap.path = UTILITY.findPath(state.worldMap.grid, state.worldMap.currentLocation, selected.coords);

                UIManager.renderWorldMapModal();
            },

            /**
             * Updates a field of the selected location (debounced).
             * @param {string} field - The field to update.
             * @param {string} value - The new value.
             */
            updateLocationDetail: debounce(function (field, value) {
                const selected = this.RUNTIME.selectedMapTile;
                if (!selected) return;

                // Find the object INSIDE the ReactiveStore array to trigger the proxy
                const grid = ReactiveStore.state.worldMap.grid;
                const locationInGrid = grid.find(loc => loc.coords.x === selected.coords.x && loc.coords.y === selected.coords.y);

                if (locationInGrid) {
                    locationInGrid[field] = value;
                }
            }, 500),




            /**
             * Clears the entire world map after confirmation.
             */
            async clearWorldMap() {
                const proceed = await UIManager.showConfirmationPromise('Are you sure you want to clear the entire world map? This cannot be undone.');
                if (!proceed) return;

                const state = ReactiveStore.state;
                state.worldMap.grid = UTILITY.createDefaultMapGrid();
                state.worldMap.currentLocation = { x: 4, y: 4 };
                state.worldMap.destination = { x: null, y: null };
                state.worldMap.path = [];
                this.RUNTIME.selectedMapTile = null;

                UIManager.renderWorldMapModal();
                UIManager.applyStyling();
            },

            /**
             * Pure Generator Function.
             * Generates a 8x8 map grid based on context.
             * @param {Object} contextObj - The context for generation.
             * @returns {Promise<Array>} - The generated grid.
             */
            async generateMapGrid(contextObj) {
                const promptTemplate = StateManager.getState().prompt_world_map_gen || UTILITY.getDefaultSystemPrompts().prompt_world_map_gen;
                let prompt = promptTemplate
                    .replace('{characters}', contextObj.characters || '')
                    .replace('{static}', contextObj.static_lore || '')
                    .replace('{recent}', contextObj.recent_events || '');

                const response = await APIService.callAI(prompt, true);
                const data = UTILITY.extractAndParseJSON(response);
                if (data && data.grid && data.grid.length === 64) {
                    // Sanitize
                    data.grid.forEach(l => {
                        if (!l.local_static_entries) l.local_static_entries = [];
                        if (!l.imageUrl) l.imageUrl = "";
                        if (!l.prompt) l.prompt = "";
                        if (!l.name || l.name === "Undefined") l.name = "";
                    });
                    return data.grid;
                }
                throw new Error("Invalid grid");
            },

            /**
             * UI Handler for generating the world map.
             * Requests user confirmation before overwriting.
             * @param {Event} event - The click event.
             */
            async generateWorldMap(event) {
                const proceed = await UIManager.showConfirmationPromise('Overwrite map with AI generation?');
                if (!proceed) return;

                const state = ReactiveStore.state;
                const btn = event.target.closest('button');
                if (btn) { btn.disabled = true; btn.innerHTML = '...'; }

                try {
                    const context = {
                        characters: state.characters.map(c => `${c.name}: ${c.short_description}`).join('\n'),
                        static_lore: (state.static_entries || []).map(e => `* ${e.title}: ${e.content}`).join('\n'),
                        recent_events: (state.chat_history || []).filter(m => m.type === 'chat').slice(-3).map(m => m.content).join('\n---\n')
                    };

                    const newGrid = await this.generateMapGrid(context);
                    state.worldMap.grid = newGrid;
                    state.worldMap.currentLocation = { x: 4, y: 4 };
                    state.worldMap.destination = { x: null, y: null };
                    state.worldMap.path = [];

                    this.RUNTIME.selectedMapTile = null;
                    UIManager.renderWorldMapModal();
                    UIManager.applyStyling();
                } catch (e) {
                    alert(e.message);
                } finally {
                    if (btn) { btn.disabled = false; btn.innerHTML = UIManager.getAIGenIcon(); }
                }
            },

            /**
             * Generates a description for a location using AI.
             * @param {Event} event - The click event.
             */
            async generateLocationPromptAI(event) {
                const state = ReactiveStore.state;
                const location = this.RUNTIME.selectedMapTile;
                if (!location) return;

                // Resolve button first
                const button = event.target.closest('button');
                if (!button) return;

                button.disabled = true; button.innerHTML = '...';

                try {
                    const prompt = state.prompt_location_gen
                        .replace('{name}', location.name)
                        .replace('{description}', location.description);

                    const newContent = await APIService.callAI(prompt);
                    this.updateLocationDetail('prompt', newContent);

                    // Find textarea relative to the BUTTON
                    const textarea = button.parentElement.querySelector('textarea');
                    if (textarea) textarea.value = newContent;

                } catch (e) { alert(e.message); }
                finally { button.disabled = false; button.innerHTML = UIManager.getAIGenIcon(); }
            },

            // --- Local Static Lore (Map Specific) ---

            /**
             * Adds a new local static entry to the selected location.
             */
            addLocalStaticEntry() {
                const location = this.RUNTIME.selectedMapTile;
                if (!location) return;

                // We must operate on the reactive object
                const state = ReactiveStore.state;
                const reactiveLoc = state.worldMap.grid.find(l => l.coords.x === location.coords.x && l.coords.y === location.coords.y);

                if (reactiveLoc) {
                    if (!reactiveLoc.local_static_entries) reactiveLoc.local_static_entries = [];
                    const newEntry = { id: UTILITY.uuid(), title: "New Local Entry", content: "" };
                    reactiveLoc.local_static_entries.push(newEntry);
                    this.RUNTIME.selectedLocalStaticEntryId = newEntry.id;

                    UIManager.renderLocalStaticEntriesList();
                    UIManager.renderLocalStaticEntryDetails();
                }
            },

            /**
             * Deletes a local static entry.
             * @param {string} entryId - The entry ID.
             */
            deleteLocalStaticEntry(entryId) {
                const location = this.RUNTIME.selectedMapTile;
                if (!location) return;

                const state = ReactiveStore.state;
                const reactiveLoc = state.worldMap.grid.find(l => l.coords.x === location.coords.x && l.coords.y === location.coords.y);

                if (reactiveLoc && reactiveLoc.local_static_entries) {
                    reactiveLoc.local_static_entries = reactiveLoc.local_static_entries.filter(e => e.id !== entryId);
                    if (this.RUNTIME.selectedLocalStaticEntryId === entryId) {
                        this.RUNTIME.selectedLocalStaticEntryId = null;
                    }
                    UIManager.renderLocalStaticEntriesList();
                    UIManager.renderLocalStaticEntryDetails();
                }
            },

            /**
             * Opens the Generic Image Generator for a location.
             */
            openLocationImageGenerator() {
                const { selectedMapTile } = this.RUNTIME;
                if (!selectedMapTile) return;

                // Prioritize the AI-generated prompt if available, else usage Name + Description
                const promptContent = selectedMapTile.prompt || selectedMapTile.description || "";
                const initialPrompt = `${selectedMapTile.name}: ${promptContent}`;

                UIManager.openGenericImageGenerator({
                    title: `Generate: ${selectedMapTile.name}`,
                    initialPrompt: initialPrompt,
                    onSave: async (blob) => {
                        await this.handleWorldMapLocationImageUpload({ target: { files: [new File([blob], "generated_location.png", { type: "image/png" })] } }, selectedMapTile.coords.x, selectedMapTile.coords.y);
                        // Modal re-render is handled by upload
                    }
                });
            },

            /**
             * Selects a local static entry for viewing/editing.
             * @param {string} entryId - The entry ID.
             */
            selectLocalStaticEntry(entryId) {
                this.RUNTIME.selectedLocalStaticEntryId = entryId;
                UIManager.renderLocalStaticEntriesList();
                UIManager.renderLocalStaticEntryDetails();
            },

            /**
             * Updates a field of a local static entry (debounced).
             * @param {string} entryId - The entry ID.
             * @param {string} field - The field to update.
             * @param {string} value - The new value.
             */
            updateLocalStaticEntryField: debounce(function (entryId, field, value) {
                const location = this.RUNTIME.selectedMapTile;
                if (!location) return;
                const state = ReactiveStore.state;
                const reactiveLoc = state.worldMap.grid.find(l => l.coords.x === location.coords.x && l.coords.y === location.coords.y);

                if (reactiveLoc && reactiveLoc.local_static_entries) {
                    const entry = reactiveLoc.local_static_entries.find(e => e.id === entryId);
                    if (entry) entry[field] = value;
                }
            }, 300),

            // --- Static Knowledge (Global) ---

            /**
             * Adds a new global static entry.
             */
            addStaticEntry() {
                const newEntry = { id: UTILITY.uuid(), title: "New Static Entry", content: "" };
                ReactiveStore.state.static_entries.push(newEntry);
                ReactiveStore.state.selectedStaticEntryId = newEntry.id;

                // Force re-render of the list and details
                // WorldController (which owns the UI for this) needs to be triggered.
                // Since this method is seemingly part of WorldController logic that leaked into Narrative or similar?
                // Wait, addStaticEntry is usually in WorldController or AppController?
                // Looking at the context, this seems to be inside WorldController...
                // Let's assume WorldController context.
                this.renderStaticEntriesList();
                this.renderStaticEntryDetails();
            },

            /**
             * Deletes a global static entry.
             * @param {string} id - The entry ID.
             */
            deleteStaticEntry(id) {
                ReactiveStore.state.static_entries = ReactiveStore.state.static_entries.filter(e => e.id !== id);
                if (ReactiveStore.state.selectedStaticEntryId === id) {
                    ReactiveStore.state.selectedStaticEntryId = null;
                }
            },

            /**
             * Selects a global static entry for viewing/editing.
             * @param {string} id - The entry ID.
             */
            selectStaticEntry(id) {
                ReactiveStore.state.selectedStaticEntryId = id;
            },

            /**
             * Updates a field of a global static entry (debounced).
             * @param {string} id - The entry ID.
             * @param {string} field - The field to update.
             * @param {string} value - The new value.
             */
            updateStaticEntryField: debounce(function (id, field, value) {
                const entry = ReactiveStore.state.static_entries.find(e => e.id === id);
                if (entry) entry[field] = value;
            }, 300),

            /**
             * Generates content for a static entry using AI.
             * @param {Event} event - The click event.
             * @param {string} entryId - The entry ID.
             */
            async generateStaticEntryContentAI(event, entryId) {
                const entry = ReactiveStore.state.static_entries.find(e => e.id === entryId);
                if (!entry) return;

                // Resolve button first
                const button = event.target.closest('button');
                if (!button) return;

                button.disabled = true; button.innerHTML = '...';

                try {
                    const prompt = ReactiveStore.state.prompt_entry_gen.replace('{title}', entry.title).replace('{triggers}', '');
                    const content = await APIService.callAI(prompt);
                    this.updateStaticEntryField(entryId, 'content', content);

                    // Find textarea relative to the BUTTON
                    const textarea = button.parentElement.querySelector('textarea');
                    if (textarea) textarea.value = content;
                } catch (e) { alert(e.message); }
                finally { button.disabled = false; button.innerHTML = UIManager.getAIGenIcon(); }
            },

            // --- Dynamic Knowledge ---

            /**
             * Adds a new dynamic entry.
             */
            addDynamicEntry() {
                const newEntry = {
                    id: UTILITY.uuid(),
                    title: "New Dynamic Entry",
                    triggers: "",
                    content_fields: [""],
                    current_index: 0,
                    triggered_at_turn: null
                };
                ReactiveStore.state.dynamic_entries.push(newEntry);
                ReactiveStore.state.selectedDynamicEntryId = newEntry.id;
            },

            /**
             * Deletes a dynamic entry.
             * @param {string} id - The entry ID.
             */
            deleteDynamicEntry(id) {
                ReactiveStore.state.dynamic_entries = ReactiveStore.state.dynamic_entries.filter(e => e.id !== id);
                if (ReactiveStore.state.selectedDynamicEntryId === id) {
                    ReactiveStore.state.selectedDynamicEntryId = null;
                }
            },

            /**
             * Selects a dynamic entry for viewing/editing.
             * @param {string} id - The entry ID.
             */
            selectDynamicEntry(id) {
                ReactiveStore.state.selectedDynamicEntryId = id;
            },

            /**
             * Updates a field of a dynamic entry (debounced).
             * @param {string} id - The entry ID.
             * @param {string} field - The field to update.
             * @param {string} value - The new value.
             */
            updateDynamicEntryField: debounce(function (id, field, value) {
                const entry = ReactiveStore.state.dynamic_entries.find(e => e.id === id);
                if (entry && (field === 'title' || field === 'triggers')) {
                    entry[field] = value;
                }
            }, 300),

            /**
             * Adds a new content field to a dynamic entry.
             * @param {string} entryId - The entry ID.
             */
            addDynamicContentField(entryId) {
                const entry = ReactiveStore.state.dynamic_entries.find(e => e.id === entryId);
                if (entry) {
                    entry.content_fields.push("");
                    // Force UI refresh since subscription protects inputs
                    UIManager.renderDynamicEntryDetails();
                }
            },

            /**
             * Updates a content field of a dynamic entry (debounced).
             * @param {string} entryId - The entry ID.
             * @param {number} index - The index of the field.
             * @param {string} value - The new value.
             */
            updateDynamicContentField: debounce(function (entryId, index, value) {
                const entry = ReactiveStore.state.dynamic_entries.find(e => e.id === entryId);
                if (entry && entry.content_fields[index] !== undefined) {
                    entry.content_fields[index] = value;
                }
            }, 300),

            /**
             * Generates content for a dynamic entry field using AI.
             * @param {Event} event - The click event.
             * @param {string} entryId - The entry ID.
             * @param {number} index - The index of the field.
             */
            async generateDynamicEntryContentAI(event, entryId, index) {
                const entry = ReactiveStore.state.dynamic_entries.find(e => e.id === entryId);
                if (!entry) return;

                // Resolve button first
                const button = event.target.closest('button');
                if (!button) return;

                button.disabled = true; button.innerHTML = '...';

                try {
                    const prompt = ReactiveStore.state.prompt_entry_gen
                        .replace('{title}', entry.title)
                        .replace('{triggers}', entry.triggers);

                    const content = await APIService.callAI(prompt);
                    this.updateDynamicContentField(entryId, index, content);

                    // Find textarea relative to the BUTTON, not the click target (event.target)
                    const textarea = button.parentElement.querySelector('textarea');
                    if (textarea) textarea.value = content;
                } catch (e) { alert(e.message); }
                finally { button.disabled = false; button.innerHTML = UIManager.getAIGenIcon(); }
            },

            /**
             * Cleans up empty content fields in dynamic entries.
             */
            cleanupEmptyDynamicFields() {
                const state = ReactiveStore.state;
                if (state.dynamic_entries) {
                    state.dynamic_entries.forEach(entry => {
                        if (entry.content_fields) {
                            // Filter out whitespace-only fields
                            entry.content_fields = entry.content_fields.filter(field => field.trim() !== "");
                            // Ensure at least one field exists
                            if (entry.content_fields.length === 0) entry.content_fields.push("");
                            // Clamp index
                            if (entry.current_index >= entry.content_fields.length) {
                                entry.current_index = entry.content_fields.length - 1;
                            }
                        }
                    });
                }
            },

            // --- Background Agents ---

            /**
             * Runs the World Info Agent to update static knowledge based on recent chat.
             * @param {boolean} [silent=false] - Whether to suppress UI feedback.
             */
            async checkWorldInfoAgent(silent = false) {
                const state = ReactiveStore.state;
                if (!StateManager.getLibrary().active_narrative_id) return;

                if (!silent) UIManager.showTypingIndicator('static-entry-agent', 'Updating static knowledge...');

                try {
                    // Build Context
                    let recentTranscript = "";
                    (state.chat_history || [])
                        .filter(m => m.type === 'chat')
                        .slice(-8)
                        .forEach(msg => {
                            const c = state.characters.find(i => i.id === msg.character_id);
                            if (c) recentTranscript += `${c.name}: ${msg.content}\n`;
                        });

                    const existingTitles = (state.static_entries || []).map(e => e.title);

                    const prompt = `As an AI Archivist, read the chat transcript. Identify NEW facts not present in the existing knowledge.
            Existing Entries: ${JSON.stringify(existingTitles)}
            
            Output valid JSON: { "add": [{"title": "Title", "content": "Fact"}], "modify": [{"title": "Existing Title", "new_content": "Updated Fact"}] }
            If no updates needed, return empty object {}.
            
            TRANSCRIPT:
            ${recentTranscript}`;

                    const response = await APIService.callAI(prompt, true);
                    const updates = JSON.parse(response);

                    let changed = false;

                    if (updates.add) {
                        updates.add.forEach(item => {
                            // Duplicate check by title
                            if (!state.static_entries.some(e => e.title.toLowerCase() === item.title.toLowerCase())) {
                                state.static_entries.push({ id: UTILITY.uuid(), ...item });
                                changed = true;
                            }
                        });
                    }

                    if (updates.modify) {
                        updates.modify.forEach(item => {
                            const entry = state.static_entries.find(e => e.title.toLowerCase() === item.title.toLowerCase());
                            if (entry) {
                                entry.content = item.new_content;
                                changed = true;
                            }
                        });
                    }

                    if (changed && !silent) {
                        UIManager.renderStaticEntries();
                        alert("Static knowledge updated successfully.");
                    }

                } catch (e) {
                    if (!silent) {
                        console.error("Static Entry Agent failed:", e);
                        alert("The AI failed to update static entries.");
                    }
                } finally {
                    if (!silent) UIManager.hideTypingIndicator();
                }
            },

            // --- New Features ---

            /**
             * Creates a new static entry from a specific chat message.
             * @param {number} index - The index of the message.
             */
            async createStaticFromMessage(index) {
                const state = ReactiveStore.state;
                const msg = state.chat_history[index];
                if (!msg) return;

                // 1. Show Feedback
                UIManager.showLoadingSpinner("Extracting knowledge...");

                // Defaults (Fallback)
                let entryTitle = "Extracted Memory";
                let entryContent = msg.content;

                try {
                    // 2. Construct Prompt
                    const char = state.characters.find(c => c.id === msg.character_id);
                    const speaker = char ? char.name : "Unknown Character";

                    const prompt = `Analyze the following roleplay message from ${speaker}.
            Extract the most significant static facts, lore, or plot developments into a concise World Info entry.
            
            Return valid JSON only:
            {
                "title": "A short, descriptive title for this entry (3-6 words)",
                "content": "A concise, objective summary of the new information found in the message."
            }

            MESSAGE:
            "${msg.content}"`;

                    // 3. Call AI
                    const response = await APIService.callAI(prompt, true); // true = parses JSON automatically logic in APIService or returns string to parse

                    // Note: APIService.callAI(..., true) returns the JSON string block, we must parse it.
                    const data = JSON.parse(response);

                    if (data.title) entryTitle = data.title;
                    if (data.content) entryContent = data.content;

                } catch (e) {
                    console.warn("AI extraction failed, falling back to raw text:", e);
                    // We proceed with the raw text defaults defined above
                }

                // 4. Create Entry
                const newEntry = {
                    id: UTILITY.uuid(),
                    title: entryTitle,
                    content: entryContent
                };

                state.static_entries.push(newEntry);
                state.selectedStaticEntryId = newEntry.id;

                // 5. Update UI
                UIManager.hideLoadingSpinner();
                AppController.openModal('knowledge-modal');
                UIManager.switchKnowledgeTab('static');
            },

            /**
             * Converts a static entry into a dynamic entry.
             * @param {string} staticId - The ID of the static entry.
             */
            convertStaticToDynamic(staticId) {
                const state = ReactiveStore.state;
                const staticEntry = state.static_entries.find(e => e.id === staticId);

                if (!staticEntry) return;

                if (confirm("Convert this to a Dynamic Entry? The Static entry will be removed.")) {
                    // 1. Create Dynamic
                    const newDynamic = {
                        id: UTILITY.uuid(),
                        title: staticEntry.title,
                        triggers: staticEntry.title, // Default trigger to title
                        content_fields: [staticEntry.content],
                        current_index: 0,
                        triggered_at_turn: null
                    };

                    // 2. Add Dynamic, Remove Static
                    state.dynamic_entries.push(newDynamic);
                    state.static_entries = state.static_entries.filter(e => e.id !== staticId);

                    // 3. Switch Views
                    state.selectedDynamicEntryId = newDynamic.id;
                    state.selectedStaticEntryId = null;

                    // 4. Force UI Refresh
                    UIManager.switchKnowledgeTab('dynamic');
                }
            },

        };



        /**
         * =================================================================================================
         * ActionDispatcher Module
         * The "Glue" that connects UI Events (ActionHandler) to the specific Controllers.
         * =================================================================================================
         */
        const ActionDispatcher = {
            /**
             * Initializes the ActionDispatcher.
             * Registers all action handlers to their respective controllers.
             */
            init() {

                ActionHandler.register('gen-story-phase-1', (ds, val, e) => LibraryController.generateStoryPhase1(e));
                ActionHandler.register('gen-story-retry', () => LibraryController.retryGenStory());
                ActionHandler.register('gen-story-confirm', () => LibraryController.confirmGenStory());

                // --- AppController (Navigation & Global UI) ---
                ActionHandler.register('open-modal', (ds) => AppController.openModal(ds.target, ds.id));
                ActionHandler.register('close-modal', (ds) => AppController.closeModal(ds.id));
                ActionHandler.register('toggle-mobile-menu', () => AppController.toggleMobileMenu());

                // Settings are mostly bi-directional bindings handled inside AppController.bindSettingsListeners,
                // but we can map specific actions here if needed in the future.

                // --- LibraryController (Stories, Scenarios, IO) ---
                ActionHandler.register('open-story', (ds) => UIManager.openStoryDetails(ds.id));
                ActionHandler.register('duplicate-story', (ds) => LibraryController.duplicateStory(ds.id));
                ActionHandler.register('delete-story', (ds) => LibraryController.deleteStory(ds.id));
                ActionHandler.register('gen-story-notes', (ds, e) => LibraryController.generateStoryNotesAI(e, ds.id));
                ActionHandler.register('gen-story-tags', (ds, e) => LibraryController.generateStoryTagsAI(e, ds.id));

                // Lightbox Actions
                ActionHandler.register('open-lightbox', (ds) => UIManager.openLightbox(ds.index));
                ActionHandler.register('lightbox-next', () => UIManager.navigateLightbox(1));
                ActionHandler.register('lightbox-prev', () => UIManager.navigateLightbox(-1));
                ActionHandler.register('close-lightbox', () => UIManager.closeLightbox());

                // Scenario Actions (Load, Rename, Delete)
                ActionHandler.register('load-scenario', (ds) => LibraryController.createNarrativeFromScenario(ds.storyId, ds.scenarioId));
                ActionHandler.register('rename-scenario', (ds) => LibraryController.renameScenario(ds.storyId, ds.scenarioId));
                ActionHandler.register('delete-scenario', (ds) => LibraryController.deleteScenario(ds.storyId, ds.scenarioId));

                // Narrative Actions
                ActionHandler.register('load-narrative', (ds) => LibraryController.loadNarrative(ds.storyId, ds.narrativeId));
                ActionHandler.register('duplicate-narrative', (ds) => LibraryController.duplicateNarrative(ds.storyId, ds.narrativeId));
                ActionHandler.register('delete-narrative', (ds) => LibraryController.deleteNarrative(ds.storyId, ds.narrativeId));
                ActionHandler.register('elevate-narrative', (ds) => LibraryController.elevateNarrativeToScenario(ds.storyId, ds.narrativeId));

                // Import / Export
                ActionHandler.register('handle-file-upload', (ds, val, e) => LibraryController.handleFileUpload(e));
                ActionHandler.register('handle-bulk-import', () => LibraryController.handleBulkImport());
                ActionHandler.register('import-library', (ds, val, e) => LibraryController.importLibrary(e));
                ActionHandler.register('export-story', (ds) => LibraryController.exportStoryAs(ds.format));
                ActionHandler.register('export-library', () => LibraryController.exportLibrary());

                // --- NarrativeController (Chat, Characters, AI) ---
                ActionHandler.register('chat-copy', (ds) => NarrativeController.copyMessage(ds.index));
                ActionHandler.register('chat-edit', (ds) => NarrativeController.openEditModal(ds.index));
                ActionHandler.register('chat-delete', (ds) => NarrativeController.deleteMessage(ds.index));
                ActionHandler.register('quick-create-character', () => NarrativeController.quickCreateCharacter());

                ActionHandler.register('move-example-turn', (ds) => NarrativeController.moveExampleDialogueTurn(parseInt(ds.index), ds.direction));
                ActionHandler.register('delete-example-turn', (ds) => NarrativeController.deleteExampleDialogueTurn(parseInt(ds.index)));

                ActionHandler.register('open-character-detail', (ds) => AppController.openModal('character-detail-modal', ds.id));
                ActionHandler.register('delete-character', (ds) => NarrativeController.deleteCharacter(ds.id));
                ActionHandler.register('set-char-role', (ds) => NarrativeController.setCharacterRole(ds.id, ds.role));
                ActionHandler.register('gen-char-tags', (ds, e) => NarrativeController.generateTagsForCharacter(e, ds.id));
                ActionHandler.register('enhance-persona', (ds, e) => NarrativeController.enhancePersonaWithAI(e, ds.id));
                ActionHandler.register('gen-model-instructions', (ds, e) => NarrativeController.generateModelInstructions(e, ds.id));
                ActionHandler.register('add-extra-portrait', (ds) => NarrativeController.addExtraPortrait(ds.id));
                ActionHandler.register('remove-extra-portrait', (ds) => NarrativeController.removeExtraPortrait(ds.id, ds.index));
                ActionHandler.register('upload-local-image', (ds, val, e) => NarrativeController.handleLocalImageUpload(e, ds.id));
                ActionHandler.register('upload-emo-image', (ds, val, e) => NarrativeController.handleLocalEmotionImageUpload(e, ds.id, ds.index));

                // --- WorldController (Map, Lore) ---
                ActionHandler.register('switch-world-map-tab', (ds) => WorldController.switchWorldMapTab(ds.tab));
                ActionHandler.register('gen-world-map', (ds, e) => WorldController.generateWorldMap(e));
                ActionHandler.register('clear-world-map', () => WorldController.clearWorldMap());
                ActionHandler.register('select-pending-move', (ds) => WorldController.selectPendingMove(parseInt(ds.x), parseInt(ds.y)));
                ActionHandler.register('confirm-move', () => WorldController.confirmMove());
                ActionHandler.register('select-map-tile', (ds) => WorldController.selectMapTile(parseInt(ds.x), parseInt(ds.y)));
                ActionHandler.register('upload-loc-image', (ds, val, e) => WorldController.handleWorldMapLocationImageUpload(e, ds.x, ds.y));
                ActionHandler.register('gen-loc-prompt', (ds, e) => WorldController.generateLocationPromptAI(e));
                ActionHandler.register('set-destination', () => WorldController.setDestination());
                ActionHandler.register('jump-to-location', (ds) => {
                    WorldController.moveToLocation(parseInt(ds.x), parseInt(ds.y));
                    AppController.closeModal('world-map-modal');
                });

                ActionHandler.register('add-static-entry', () => WorldController.addStaticEntry());
                ActionHandler.register('select-static-entry', (ds) => WorldController.selectStaticEntry(ds.id));
                ActionHandler.register('gen-static-ai', (ds, e) => WorldController.generateStaticEntryContentAI(e, ds.id));
                ActionHandler.register('delete-static-entry', (ds) => WorldController.deleteStaticEntry(ds.id));
                ActionHandler.register('check-world-info', () => WorldController.checkWorldInfoAgent());
                ActionHandler.register('gen-location-image', (ds) => WorldController.openLocationImageGenerator());

                ActionHandler.register('add-dynamic-entry', () => WorldController.addDynamicEntry());
                ActionHandler.register('select-dynamic-entry', (ds) => WorldController.selectDynamicEntry(ds.id));
                ActionHandler.register('gen-dynamic-ai', (ds, e) => WorldController.generateDynamicEntryContentAI(e, ds.id, ds.index));
                ActionHandler.register('add-dynamic-field', (ds) => WorldController.addDynamicContentField(ds.id));
                ActionHandler.register('delete-dynamic-entry', (ds) => WorldController.deleteDynamicEntry(ds.id));

                ActionHandler.register('add-local-static-entry', () => WorldController.addLocalStaticEntry());
                ActionHandler.register('select-local-static-entry', (ds) => WorldController.selectLocalStaticEntry(ds.id));
                ActionHandler.register('delete-local-static-entry', (ds) => WorldController.deleteLocalStaticEntry(ds.id));

                // Narrative Actions
                ActionHandler.register('view-chat-image', (ds) => UIManager.viewChatImage(ds.src));
                ActionHandler.register('create-static-from-message', (ds) => WorldController.createStaticFromMessage(parseInt(ds.index)));
                ActionHandler.register('confirm-delete-message', (ds) => NarrativeController.confirmDeleteMessage(parseInt(ds.index)));
            }
        };






        /**
         * app Module
         * The Application Initializer.
         */
        const app = {
            /**
             * Initializes the application.
             * Sets up core services, loads library, hydrates images, and initializes the UI.
             */
            async init() {
                if ('scrollRestoration' in history) {
                    history.scrollRestoration = 'manual';
                }

                // 1. Initialize Core Services
                try { await DBService.init(); } catch (e) { console.warn("DB init failed", e); }

                // 2. Load Library
                await StateManager.loadLibrary();
                const library = StateManager.getLibrary();

                if (library.stories.length === 0) {
                    const { newStory, newNarrative } = await StoryService.createDefaultStoryAndNarrative();
                    localStorage.setItem('active_story_id', newStory.id);
                    localStorage.setItem('active_narrative_id', newNarrative.id);
                    window.location.reload();
                    return;
                }

                // 3. Hydrate Images (Optimized for performance)
                if (library.stories.length > 0) {
                    UIManager.RUNTIME.characterImageCache = UIManager.RUNTIME.characterImageCache || {};

                    // Loop over ALL stories in the library
                    for (const story of library.stories) {
                        if (!story.characters) continue;

                        // Hydrate Character Images
                        for (const char of story.characters) {
                            try {
                                // 1. Base Portrait
                                if (!UIManager.RUNTIME.characterImageCache[char.id]) {
                                    const blob = await DBService.getImage(char.id);
                                    if (blob) {
                                        UIManager.RUNTIME.characterImageCache[char.id] = URL.createObjectURL(blob);
                                    }
                                }

                                // 2. Emotion Portraits
                                if (Array.isArray(char.extra_portraits)) {
                                    for (const p of char.extra_portraits) {
                                        const emotion = (p.emotion || 'neutral').toLowerCase();
                                        const emoKey = `${char.id}::emotion::${emotion}`;
                                        if (!UIManager.RUNTIME.characterImageCache[emoKey]) {
                                            const blob = await DBService.getImage(emoKey);
                                            if (blob) {
                                                UIManager.RUNTIME.characterImageCache[emoKey] = URL.createObjectURL(blob);
                                            }
                                        }
                                    }
                                }
                            } catch (e) {
                                console.warn("Image hydration failed for char", char.id, e);
                            }
                        }
                    }
                    console.log("Image hydration complete.");
                }

                // Hydrate Scoped Background Image
                const activeStoryId = localStorage.getItem('active_story_id');
                if (activeStoryId) {
                    try {
                        // Try fetching story-specific background
                        const bgBlob = await DBService.getImage(`bg_${activeStoryId}`);
                        if (bgBlob) {
                            UIManager.RUNTIME.globalBackgroundImageCache = URL.createObjectURL(bgBlob);
                            console.log("Scoped background hydrated.");
                        } else {
                            // Fallback: Check for legacy global image (migration path)
                            const globalBlob = await DBService.getImage('global_background_image');
                            if (globalBlob) {
                                // We don't auto-migrate here to avoid side effects, but we respect it if it exists
                                // and the story claims to use it.
                                UIManager.RUNTIME.globalBackgroundImageCache = URL.createObjectURL(globalBlob);
                            }
                        }
                    } catch (e) {
                        console.warn("Background hydration failed:", e);
                    }
                }

                // 4. Load Active Narrative
                await StateManager.loadActiveNarrative();
                const state = StateManager.getState();

                // 5. Initialize Event System (THE NEW LOGIC)
                this.setupEventListeners();      // Updates layout
                UIManager.setButtonToSendMode(); // Sets initial button state
                ActionHandler.init();            // Starts listening for clicks
                ActionDispatcher.init();         // Wires clicks to Controllers

                // 6. Initialize Reactive State
                if (!state || Object.keys(state).length === 0) {
                    // Empty state fallback
                    const activeStory = library.stories.find(s => s.id === library.active_story_id);
                    const title = activeStory ? activeStory.name : "No Story Loaded";
                    if (document.getElementById('story-title-input')) document.getElementById('story-title-input').value = title;
                    if (document.getElementById('mobile-story-title-overlay')) document.getElementById('mobile-story-title-overlay').value = title;

                    ReactiveStore.init({});
                    UIManager.renderChat();
                } else {
                    // Initialize Store
                    ReactiveStore.init(state);

                    // Initialize Runtime Variables
                    if (typeof WorldController !== 'undefined') {
                        WorldController.RUNTIME.turnOfArrival = state.messageCounter;
                    }

                    // Ensure Colors
                    // Ensure Colors for ALL characters, including User
                    let aiCharCount = 0;
                    (state.characters || []).forEach(char => {
                        if (!char.color) {
                            if (char.is_user) {
                                // Default User Gray
                                char.color = { base: '#4b5563', bold: '#e5e7eb' };
                            } else {
                                // Cycle through AI colors
                                char.color = NarrativeController.CONSTANTS.CHARACTER_COLORS[aiCharCount % 8];
                                aiCharCount++;
                            }
                        } else if (!char.is_user) {
                            // Just increment counter if AI already has color, to keep variety for next new char
                            aiCharCount++;
                        }
                    });

                    // Setup Subscriptions (Mapped to UIManager)
                    [
                        'font', 'chatTextColor', 'textSize', 'bubbleOpacity', 'backgroundBlur',
                        'bubbleImageSize', 'backgroundImageURL', 'characterImageMode',
                        // Colors
                        'md_h1_color', 'md_h2_color', 'md_h3_color', 'md_bold_color',
                        'md_italic_color', 'md_quote_color',
                        // Fonts (The missing keys causing the update issue)
                        'md_h1_font', 'md_h2_font', 'md_h3_font', 'md_bold_font',
                        'md_italic_font', 'md_quote_font'
                    ]
                        .forEach(key => {
                            ReactiveStore.subscribe(key, () => UIManager.applyStyling());
                        });

                    // Smart Subscriptions (prevent focus loss)
                    ReactiveStore.subscribe('characters', () => {
                        const active = document.activeElement;
                        const isTypingInRoster = active && active.tagName === 'INPUT' && active.closest('#character-detail-modal-content');
                        if (!isTypingInRoster) {
                            UIManager.renderCharacters();
                            UIManager.updateAICharacterSelector();
                        }
                    });

                    // Don't re-render if we are manually handling the DOM (e.g., finishing a stream)
                    ReactiveStore.subscribe('chat_history', () => {
                        if (!UIManager.RUNTIME.suppressChatRender) UIManager.renderChat();
                    });

                    ReactiveStore.subscribe('static_entries', () => {
                        if (!document.activeElement?.closest('#static-entry-details')) UIManager.renderStaticEntries();
                    });
                    ReactiveStore.subscribe('dynamic_entries', () => {
                        if (!document.activeElement?.closest('#dynamic-entry-details')) UIManager.renderDynamicEntries();
                    });

                    ReactiveStore.subscribe('worldMap', () => {
                        UIManager.applyStyling();
                        if (!document.activeElement?.closest('#world-map-modal-content') && document.getElementById('world-map-modal').style.display !== 'none') {
                            UIManager.renderWorldMapModal();
                        }
                    });

                    ReactiveStore.subscribe('selectedStaticEntryId', () => { UIManager.renderStaticEntries(); UIManager.renderStaticEntryDetails(); });
                    ReactiveStore.subscribe('selectedDynamicEntryId', () => { UIManager.renderDynamicEntries(); UIManager.renderDynamicEntryDetails(); });

                    // Initial Render
                    AppController.updateImageGenSettingsVisibility();
                    UIManager.applyStyling();
                    UIManager.renderAll();
                }

                // Enable line breaks for single newlines (Chat Style Markdown)
                if (typeof marked !== 'undefined') {
                    marked.use({ breaks: true, gfm: true });
                }

                if ('scrollRestoration' in history) {
                    history.scrollRestoration = 'manual';
                }
            },

            /**
             * Sets up global event listeners for the application.
             * Handles resizing, input events, and mobile menu interactions.
             */
            setupEventListeners() {
                this.updateLayout();
                window.addEventListener('resize', debounce(() => this.updateLayout(), 100));

                // Update: Use LibraryController for title renaming
                const titleInputHandler = (e) => {
                    if (typeof NarrativeController !== 'undefined') {
                        NarrativeController.renameActiveNarrative(e.target.value);
                    }
                };

                const titleInput = document.getElementById('story-title-input');
                const mobileTitle = document.getElementById('mobile-story-title-overlay');
                if (titleInput) titleInput.addEventListener('input', titleInputHandler);
                if (mobileTitle) mobileTitle.addEventListener('input', titleInputHandler);

                // Enter-to-Send Logic
                const chatInput = document.getElementById('chat-input');
                if (chatInput) {
                    chatInput.addEventListener('keydown', (e) => {
                        // Check if Enter was pressed WITHOUT Shift
                        if (e.key === 'Enter' && !e.shiftKey) {
                            // Prevent the default new line insertion
                            e.preventDefault();
                            // Trigger the send action
                            NarrativeController.handlePrimaryAction();
                        }
                    });
                }

                // Hamburger Menu
                const hamburgerBtn = document.getElementById('hamburger-menu-button');
                if (hamburgerBtn) {
                    hamburgerBtn.addEventListener('click', (e) => { e.stopPropagation(); AppController.toggleMobileMenu(); });
                }

                document.addEventListener('click', (e) => {
                    // Mobile Menu Logic
                    const menu = document.getElementById('mobile-menu');
                    const btn = document.getElementById('hamburger-menu-button');
                    if (menu && !menu.classList.contains('hidden') && !menu.contains(e.target) && (!btn || !btn.contains(e.target))) {
                        AppController.toggleMobileMenu();
                    }

                    // Story Library Dropdown Logic
                    const dropdown = document.getElementById('new-story-dropdown');
                    if (dropdown && !dropdown.classList.contains('hidden')) {
                        // Only close if we clicked OUTSIDE the dropdown
                        // (Clicks inside are handled by their own buttons or need to bubble for data-action)
                        if (!dropdown.contains(e.target)) {
                            dropdown.classList.add('hidden');
                        }
                    }
                });

                // Mobile Title Fade Logic
                const titleTrigger = document.getElementById('title-trigger-area');

                const showTitle = () => {
                    if (document.body.classList.contains('layout-vertical') && mobileTitle) {
                        clearTimeout(UIManager.RUNTIME.titleTimeout);
                        mobileTitle.style.opacity = '1';
                        mobileTitle.style.pointerEvents = 'auto';
                    }
                };

                const hideTitle = (immediate = false) => {
                    if (document.body.classList.contains('layout-vertical') && mobileTitle) {
                        clearTimeout(UIManager.RUNTIME.titleTimeout);
                        if (document.activeElement !== mobileTitle) {
                            const doHide = () => {
                                mobileTitle.style.opacity = '0';
                                mobileTitle.style.pointerEvents = 'none';
                            };
                            if (immediate) { doHide(); } else { UIManager.RUNTIME.titleTimeout = setTimeout(doHide, 2500); }
                        }
                    }
                };

                if (titleTrigger) {
                    titleTrigger.addEventListener('mouseenter', showTitle);
                    titleTrigger.addEventListener('mouseleave', () => hideTitle());
                    titleTrigger.addEventListener('touchstart', (e) => { e.preventDefault(); if (mobileTitle && mobileTitle.style.opacity === '1') { hideTitle(true); } else { showTitle(); hideTitle(); } });
                }

                // Update: Use NarrativeController for Chat Buttons
                const regenBtn = document.getElementById('regen-btn');
                const undoBtn = document.getElementById('undo-btn');
                if (regenBtn) regenBtn.addEventListener('click', () => NarrativeController.handleRegen());
                if (undoBtn) undoBtn.addEventListener('click', () => NarrativeController.undoLastTurn());
            },




            /**
             * Updates the layout based on window dimensions.
             * Toggles between vertical and horizontal layouts.
             */
            updateLayout() {
                const isVertical = window.innerHeight > window.innerWidth;
                const wasVertical = document.body.classList.contains('layout-vertical');
                const layoutChanged = isVertical !== wasVertical;

                if (isVertical) {
                    document.body.classList.add('layout-vertical');
                    document.body.classList.remove('layout-horizontal');
                } else {
                    document.body.classList.add('layout-horizontal');
                    document.body.classList.remove('layout-vertical');
                }
                UIManager.updateSidePortrait();

                // FIX: Force library re-render if layout changed (Mobile <-> Desktop)
                if (layoutChanged) {
                    const libModal = document.getElementById('story-library-modal');
                    if (libModal && !libModal.classList.contains('hidden')) {
                        // Capture current filter state
                        const search = document.getElementById('lib-search')?.value;
                        const sort = document.getElementById('lib-sort')?.value;
                        const tag = document.getElementById('lib-tag')?.value;

                        // Clear container to bypass 'Early Return' optimization in renderLibraryInterface
                        const container = document.getElementById('library-content-container');
                        if (container) container.innerHTML = '';

                        UIManager.renderLibraryInterface({
                            searchTerm: search,
                            sortBy: sort,
                            filterTag: tag
                        });

                        // Re-open Story Details if one was active
                        if (UIManager.RUNTIME.viewingStoryId) {
                            // If switching to Horizontal (Desktop), ensure the Mobile Overlay is hidden
                            if (!isVertical) {
                                const mobileOverlay = document.getElementById('story-details-modal');
                                if (mobileOverlay) mobileOverlay.classList.add('hidden');
                            }
                            // Re-trigger open to render in the correct new container
                            UIManager.openStoryDetails(UIManager.RUNTIME.viewingStoryId);
                        }
                    }
                }
            },


        };

        // Start the application once the DOM is fully loaded.
        document.addEventListener('DOMContentLoaded', () => app.init());

    </script>
</body>

</html>
